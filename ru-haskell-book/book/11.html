<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#ленивые-чудеса">Ленивые чудеса</a><ul>
<li><a href="#численные-методы">Численные методы</a><ul>
<li><a href="#дифференцирование">Дифференцирование</a></li>
<li><a href="#интегрирование">Интегрирование</a></li>
</ul></li>
<li><a href="#степенные-ряды">Степенные ряды</a><ul>
<li><a href="#арифметика-рядов">Арифметика рядов</a><ul>
<li><a href="#сложение">Сложение</a></li>
<li><a href="#умножение">Умножение</a></li>
<li><a href="#класс-num">Класс Num</a></li>
<li><a href="#деление">Деление</a></li>
</ul></li>
<li><a href="#производная-и-интеграл">Производная и интеграл</a></li>
<li><a href="#элементарные-функции">Элементарные функции</a></li>
</ul></li>
<li><a href="#водосборы">Водосборы</a></li>
<li><a href="#ленивее-некуда">Ленивее некуда</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="10.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="12.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<p></p>
<h1 id="ленивые-чудеса"><a href="#TOC">Ленивые чудеса</a></h1>
<p>В прошлой главе мы узнали, что такое ленивые вычисления. В этой главе мы посмотрим чем они хороши. С ними можно делать невозможные вещи. Обращаться к ещё не вычисленным значениям, работать с бесконечными данными.</p>
<p>Мы пишем программу, чтобы решить какую-нибудь сложную задачу. Часто так бывает, что сложная задача оказывается сложной до тех пор пока её не удаётся разбить на отдельные независимые подзадачи. Мы решаем задачи по-меньше, потом собираем из них решения, из этих решений собираем другие решения и вот уже готова программа. Но мы решаем задачу не на листочке, нам необходимо объяснить её компьютеру. И тот язык, на котором мы пишем программу, оказывает сильное влияние на то как мы будем решать задачу. Мы не можем разбить программу на независимые подзадачи, если в том языке на котором мы собираемся объяснять задачу компьютеру нет средств для того, чтобы собрать эти решения вместе.</p>
<p>Об этом говорит <em>Джон Хьюз</em> (John Huges) в статье “Why functional programming matters”. Он приводит такую метафору. Если мы делаем стул и у нас нет хорошего клея. Единственное что нам остаётся это вырезать из дерева стул целиком. Это невероятно трудная задача. Гораздо проще сделать отдельные части и потом собрать вместе. Функциональные языки программирования предоставляют два новых вида “клея”. Это функции высшего порядка и ленивые вычисления. В статье можно найти много примеров. Некоторые из них мы рассмотрим в этой главе.</p>
<p>С функциями высших порядков мы уже знакомы, они позволяют склеивать небольшие решения. С их помощью мы можем параметризовать функцию другой функцией (поведением). Они дают нам возможность выделять сложные закономерности и собирать их в функции. Ленивые вычисления же предназначены для склеивания больших программ. Они синхронизируют выполнение подзадач, избавляя нас от необходимости выполнять это вручную.</p>
<p>Эта идея разбиения программы на независимые части приводит нас к понятию модульности. Когда мы решаем задачу мы пытаемся разложить её на простейшие составляющие. При этом часто оказывается, что эти составляющие применимы не только для нашей задачи, но и для многих других. Мы получаем целый букет решений, там где искали одно.</p>
<h2 id="численные-методы"><a href="#TOC">Численные методы</a></h2>
<p>Рассмотрим несколько численных методов. Все эти методы построены на понятии сходимости. У нас есть последовательность решений и она сходится к одному решению, но мы не знаем когда. Мы только знаем, что промежуточные решения будут всё ближе и ближе к итоговому.</p>
<p>Поскольку у нас ленивый язык мы сначала построим все возможные решения, а затем выберем итоговое. Так же как мы делали это в прошлой главе, когда искали корни уравнения методом неподвижной точки. Эти примеры взяты из статьи “Why functional programming matters” Джона Хьюза.</p>
<h3 id="дифференцирование"><a href="#TOC">Дифференцирование</a></h3>
<p>Найдём производную функции в точке. Посмотрим на математическое определение производной:</p>
<p><span class="LaTeX">$f^\prime(x)\ =\lim_{h\to0}\frac{f(x+h)-f(x)}{h}$</span></p>
<p>Производная это предел последовательности таких отношений, при <span class="LaTeX">$h$</span> стремящемся к нулю. Если предел сходится, то производная определена. Для того чтобы решить эту задачу мы начнём с небольшого значения <span class="LaTeX">$h$</span> и будем постепенно уменьшать его, вычисляя промежуточные значения производной. Как только они перестанут сильно изменяться мы будем считать, что мы нашли предел последовательности</p>
<p>Этот процесс напоминает то, что мы делали при поиске корня уравнения методом неподвижной точки. Мы можем взять из того решения функцию определения сходимости последовательности:</p>
<pre><font color=Black>converge</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> a<font color=Black>,</font> <font color=Green>Num</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>converge</font> eps <font color=Black>(</font>a<font color="#b2590f">:</font>b<font color="#b2590f">:</font>xs<font color=Black>)</font> 
    <font color="#b2590f">|</font> abs <font color=Black>(</font>a <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>&lt;=</font> eps    <font color="#b2590f">=</font> a
    <font color="#b2590f">|</font> otherwise             <font color="#b2590f">=</font> converge eps <font color=Black>(</font>b<font color="#b2590f">:</font>xs<font color=Black>)</font></pre>
<p>Теперь осталось только создать последовательность значений производных. Напишем функцию, которая вычисляет промежуточные решения:</p>
<pre><font color=Black>easydiff</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>easydiff</font> f x h <font color="#b2590f">=</font> <font color=Black>(</font>f <font color=Black>(</font>x <font color=Black>+</font> h<font color=Black>)</font> <font color="#2149c1">-</font> f x<font color=Black>)</font> <font color=Black>/</font> h</pre>
<p>Мы возьмём начальное значение шага и будем последовательно уменьшать его вдвое:</p>
<pre><font color=Black>halves</font> <font color="#b2590f">=</font> iterate <font color=Black>(</font><font color=Black>/</font><font color="#0000ee">2</font><font color=Black>)</font> </pre>
<p>Соберём все части вместе:</p>
<pre><font color=Black>diff</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> a<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>diff</font> h0 eps f x <font color="#b2590f">=</font> converge eps <font color=Black>$</font> map <font color=Black>(</font>easydiff f x<font color=Black>)</font> <font color=Black>$</font> iterate <font color=Black>(</font><font color=Black>/</font><font color="#0000ee">2</font><font color=Black>)</font> h0
    <font color="#b2590f">where</font> easydiff f x h <font color="#b2590f">=</font> <font color=Black>(</font>f <font color=Black>(</font>x <font color=Black>+</font> h<font color=Black>)</font> <font color="#2149c1">-</font> f x<font color=Black>)</font> <font color=Black>/</font> h</pre>
<p>Сохраним эти определения в отдельном модуле и найдём производную какой-нибудь функции. Протестируем решение на экспоненте. Известно, что производная экспоненты равна самой себе:</p>
<pre><font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> exp' <font color="#b2590f">=</font> diff <font color="#0000ee">1</font> <font color="#0000ee">1e-5</font> exp
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> test x <font color="#b2590f">=</font> abs <font color=Black>$</font> exp x <font color="#2149c1">-</font> exp' x
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> test <font color="#0000ee">2</font>
<font color="#0000ee">1.4093421286887065e-5</font>
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> test <font color="#0000ee">5</font>
<font color="#0000ee">1.767240203776055e-5</font></pre>
<h3 id="интегрирование"><a href="#TOC">Интегрирование</a></h3>
<p>Теперь давайте поинтегрируем функции одного аргумента. Интеграл это площадь кривой под графиком функции. Если бы кривая была прямой, то мы могли бы вычислить интеграл по формуле трапеций:</p>
<pre><font color=Black>easyintegrate</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>easyintegrate</font> f a b <font color="#b2590f">=</font> <font color=Black>(</font>f a <font color=Black>+</font> f b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>b <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font></pre>
<p>Но мы хотим интегрировать не только прямые линии. Мы представим, что функция является ломаной прямой линией. Мы посчитаем интеграл на каждом из участков и сложим ответы. При этом чем ближе точки друг к другу, тем точнее можно представить функцию в виде ломаной прямой линии, тем точнее будет значение интеграла.</p>
<p>Проблема в том, что мы не знаем заранее насколько близки должны быть точки друг к другу. Это зависит от функции, которую мы хотим проинтегрировать. Но мы можем построить последовательность решений. На каждом шаге мы будем приближать функцию ломаной прямой, и на каждом шаге число изломов будет расти вдвое. Как только решение перестанет меняться мы вернём ответ.</p>
<p>Построим последовательность решений:</p>
<pre><font color=Black>integrate</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>integrate</font> f a b <font color="#b2590f">=</font> easyintegrate f a b <font color="#b2590f">:</font> 
    zipWith <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color=Black>(</font>integrate a mid<font color=Black>)</font> <font color=Black>(</font>integrate mid b<font color=Black>)</font>
    <font color="#b2590f">where</font> mid <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font></pre>
<p>Первое решение является площадью под прямой, которая соединяет концы отрезка. Потом мы делим отрезок пополам, строим последовательность приближений и складываем частичные суммы с помощью функции <code><font color=Black>zipWith</font></code>.</p>
<p>Эта версия функции хоть и наглядная, но не эффективная. Функция <code><font color=Black>f</font></code> вычисляется заново при каждом рекурсивном вызове. Было бы хорошо вычислять её только для новых значений. Для этого мы будем передавать значения с предыдущего шага:</p>
<pre><font color=Black>integrate</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>integrate</font> f a b <font color="#b2590f">=</font> integ f a b <font color=Black>(</font>f a<font color=Black>)</font> <font color=Black>(</font>f b<font color=Black>)</font>
    <font color="#b2590f">where</font> integ f a b fa fb <font color="#b2590f">=</font> <font color=Black>(</font>fa<font color=Black>+</font>fb<font color=Black>)</font><font color=Black>*</font><font color=Black>(</font>b<font color="#2149c1">-</font>a<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font> <font color="#b2590f">:</font>
                zipWith <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color=Black>(</font>integ f a m fa fm<font color=Black>)</font> 
                            <font color=Black>(</font>integ f m b fm fb<font color=Black>)</font>
                <font color="#b2590f">where</font> m  <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font>
                      fm <font color="#b2590f">=</font> f m </pre>
<p>В этой версии мы вычисляем значения в функции <code><font color=Black>f</font></code> лишь один раз для каждой точки. Запишем итоговое решение:</p>
<pre><font color=Black>int</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> a<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>int</font> eps f a b <font color="#b2590f">=</font> converge eps <font color=Black>$</font> integrate f a b</pre>
<p>Мы опять воспользовались функцией <code><font color=Black>converge</font></code>, нам не нужно было её переписывать. Проверим решение. Для проверки также воспользуемся экспонентой. В прошлой главе мы узнали, что</p>
<p><span class="LaTeX">$e^x = 1 + \int_0^x e^t dt$</span></p>
<p>Посмотрим, так ли это для нашего алгоритма:</p>
<pre><font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> exp' <font color="#b2590f">=</font> int <font color="#0000ee">1e-5</font> exp <font color="#0000ee">0</font>
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> test x <font color="#b2590f">=</font> abs <font color=Black>$</font> exp x <font color="#2149c1">-</font> <font color="#0000ee">1</font> <font color="#2149c1">-</font>  exp' x 
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> test <font color="#0000ee">2</font>
<font color="#0000ee">8.124102876649886e-6</font>
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> test <font color="#0000ee">5</font>
<font color="#0000ee">4.576306736225888e-6</font>
<font color=Black>*</font><font color=Green>Numeric</font><font color=Black>&gt;</font> test <font color="#0000ee">10</font>
<font color="#0000ee">1.0683757864171639e-5</font></pre>
<p>Алгоритм работает. В статье ещё рассмотрены методы повышения точности этих алгоритмов. Что интересно для улучшения точности не надо менять существующий код. Функция принимает последовательность промежуточных решений и преобразует её.</p>
<h2 id="степенные-ряды"><a href="#TOC">Степенные ряды</a></h2>
<p>Напишем модуль для вычисления степенных рядов. Этот пример взят из статьи Дугласа МакИлроя (Douglas McIlroy) “Power Series, Power Serious”. Степенной ряд представляет собой функцию, которая определяется списком коэффициентов:</p>
<p><span class="LaTeX">$F(x) = f_0 + f_1 x + f_2 x^2 + f_3 x^3 + f_4 x^4 + ...$</span></p>
<p>Степенной ряд содержит бесконечное число слагаемых. Для вычисления нам потребуются функции сложения и умножения. Ряд <span class="LaTeX">$F(x)$</span> можно записать и по-другому:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$F(x)$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$F_0 (x)$</span></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$f_0 + x F_1 (x)$</span></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$f_0 + x (f_1 + x F_2 (x))$</span></td>
</tr>
</tbody>
</table>
<p>Это определение очень похоже на определение списка. Ряд есть коэффициент <span class="LaTeX">$f_0$</span> и другой ряд <span class="LaTeX">$F_1(x)$</span> умноженный на <code><font color=Black>x</font></code>. Поэтому для представления рядов мы выберем конструкцию похожую на список:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Ps</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:+:</font> <font color=Green>Ps</font> a
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font></pre>
<p>Но в нашем случае списки бесконечны, поэтому у нас лишь один конструктор. Далее мы будем писать просто <span class="LaTeX">$f + x F_1$</span>, без скобок для аргумента.</p>
<p>Определим вспомогательные функции для создания рядов:</p>
<pre><font color=Black>p0</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a
<font color=Black>p0</font> x <font color="#b2590f">=</font> x <font color="#b2590f">:+:</font> p0 <font color="#0000ee">0</font>

<font color=Black>ps</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a
<font color=Black>ps</font> <font color=Green>[]</font>     <font color="#b2590f">=</font> p0 <font color="#0000ee">0</font>
<font color=Black>ps</font> <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font> <font color="#b2590f">=</font> a <font color="#b2590f">:+:</font> ps <font color="#b2590f">as</font></pre>
<p>Обратите внимание на то, как мы дописываем бесконечный хвост нулей в конец ряда. Теперь давайте определим функцию вычисления ряда. Мы будем вычислять лишь конечное число степеней.</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>eval</font> <font color="#0000ee">0</font> <font color="#b2590f">_</font>         <font color="#b2590f">_</font> <font color="#b2590f">=</font> <font color="#0000ee">0</font>
<font color=Black>eval</font> n <font color=Black>(</font>a <font color="#b2590f">:+:</font> p<font color=Black>)</font> x <font color="#b2590f">=</font> a <font color=Black>+</font> x <font color=Black>*</font> eval <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font> p x</pre>
<p>В первом случае мы хотим вычислить ноль степеней ряда, поэтому мы возвращаем ноль, а во втором случае значение ряда <span class="LaTeX">$a + x P$</span> складывается из числа <span class="LaTeX">$a$</span> и значения ряда <span class="LaTeX">$P$</span> умноженного на заданное значение.</p>
<h3 id="арифметика-рядов"><a href="#TOC">Арифметика рядов</a></h3>
<p>В результате сложения и умножения рядов также получается ряд. Также мы можем создать ряд из числа. Эти операции говорят о том, что мы можем сделать степенной ряд экземпляром класса <code><font color=Green>Num</font></code>.</p>
<h4 id="сложение"><a href="#TOC">Сложение</a></h4>
<p>Рекурсивное представление ряда <span class="LaTeX">$f + x F$</span> позволяет нам очень кратко выражать операции, которые мы хотим определить. Теперь у нас нет бесконечного набора коэффициентов, у нас всего лишь одно число и ещё один ряд. Операции существенно упрощаются. Так сложение двух бесконечных рядов имеет вид:</p>
<p><span class="LaTeX">$F + G = (f + x F_1) + (g + x G_1) = (f+g) + x (F_1 + G_1)$</span></p>
<p>Переведём на Haskell:</p>
<pre><font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>f <font color=Black>+</font> g<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>fs <font color=Black>+</font> gs<font color=Black>)</font></pre>
<h4 id="умножение"><a href="#TOC">Умножение</a></h4>
<p>Умножим два ряда:</p>
<p><span class="LaTeX">$F*G = (f + x F_1) * (g + x G_1) = f g + x (f G_1 + F_1 * G)$</span></p>
<p>Переведём:</p>
<pre><font color=Black>(</font><font color=Black>.*</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a
<font color=Black>k</font> <font color=Black>.*</font> <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>k <font color=Black>*</font> f<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>k <font color=Black>.*</font> fs<font color=Black>)</font>  

<font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>f <font color=Black>*</font> g<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>f <font color=Black>.*</font> gs <font color=Black>+</font> fs <font color=Black>*</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font><font color=Black>)</font></pre>
<p>Дополнительная операция <code><font color=Black>(</font><font color=Black>.*</font><font color=Black>)</font></code> выполняет умножение всех коэффициентов ряда на число.</p>
<h4 id="класс-num"><a href="#TOC">Класс Num</a></h4>
<p>Соберём определения для методов класса <code><font color=Green>Num</font></code> вместе:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Num</font> <font color=Black>(</font><font color=Green>Ps</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>f <font color=Black>+</font> g<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>fs <font color=Black>+</font> gs<font color=Black>)</font>
    <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>f <font color=Black>*</font> g<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>f <font color=Black>.*</font> gs <font color=Black>+</font> fs <font color=Black>*</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font><font color=Black>)</font>
    negate <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color="#b2590f">=</font> negate f <font color="#b2590f">:+:</font> negate fs
    fromInteger n <font color="#b2590f">=</font> p0 <font color=Black>(</font>fromInteger n<font color=Black>)</font>


<font color=Black>(</font><font color=Black>.*</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a
<font color=Black>k</font> <font color=Black>.*</font> <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>k <font color=Black>*</font> f<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>k <font color=Black>.*</font> fs<font color=Black>)</font>  </pre>
<p>Методы <code><font color=Black>abs</font></code> и <code><font color=Black>signum</font></code> не определены для рядов. Обратите внимание на то, как рекурсивное определение рядов приводит к рекурсивным определениям функций для рядов. Этот приём очень характерен для Haskell. Поскольку наш ряд это число и ещё один ряд за счёт рекурсии мы можем воспользоваться операцией, которую мы определяем, на “хвостовом” ряде.</p>
<h4 id="деление"><a href="#TOC">Деление</a></h4>
<p>Результат деления <span class="LaTeX">$Q$</span> удовлетворяет соотношению:</p>
<p><span class="LaTeX">$F = Q * G$</span></p>
<p>Переписав <span class="LaTeX">$F$</span>, <span class="LaTeX">$G$</span> и <span class="LaTeX">$Q$</span> в нашем представлении, получим</p>
<table>
<col width="20%" />
<col width="15%" />
<col width="43%" />
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$f + x F_1$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$(q + x Q_1) * G = qG + x Q_1 * G = q(g + x G_1) + x Q_1 * G$</span></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$q g + x (q G_1 + Q_1 * G)$</span></td>
</tr>
</tbody>
</table>
<p>Следовательно</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$q$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$f/g$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$Q_1$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$(F_1 - q G_1)/G$</span></td>
</tr>
</tbody>
</table>
<p>Если <span class="LaTeX">$g = 0$</span> деление имеет смысл только в том случае, если и <span class="LaTeX">$f = 0$</span>. Переведём на Haskell:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Fractional</font> <font color=Black>(</font><font color=Green>Ps</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    <font color=Black>(</font><font color="#0000ee">0</font> <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color=Black>/</font> <font color=Black>(</font><font color="#0000ee">0</font> <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> fs <font color=Black>/</font> gs
    <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color=Black>/</font> <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> q <font color="#b2590f">:+:</font> <font color=Black>(</font><font color=Black>(</font>fs <font color="#2149c1">-</font> q <font color=Black>.*</font> gs<font color=Black>)</font><font color=Black>/</font><font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font><font color=Black>)</font>
        <font color="#b2590f">where</font> q <font color="#b2590f">=</font> f<font color=Black>/</font>g

    fromRational x <font color="#b2590f">=</font> p0 <font color=Black>(</font>fromRational x<font color=Black>)</font></pre>
<h3 id="производная-и-интеграл"><a href="#TOC">Производная и интеграл</a></h3>
<p>Производная одного члена ряда вычисляется так:</p>
<p><span class="LaTeX">$\frac{d}{dx} x^n = n x^{n-1}$</span></p>
<p>Из этого выражения по свойствам производной</p>
<p><span class="LaTeX">$\frac{d}{dx}(f(x) + g(x)) = \frac{d}{dx}f(x) + \frac{d}{dx}g(x)$</span></p>
<p><span class="LaTeX">$\frac{d}{dx} (k * f(x)) = k * \frac{d}{dx} f(x)$</span></p>
<p>мы можем получить формулу для всего ряда:</p>
<p><span class="LaTeX">$\frac{d}{dx} F(x) = f_1 + 2 f_2 x + 3 f_3 x^2 + 4 f_4 x^3 + ...$</span></p>
<p>Для реализации нам понадобится вспомогательная функция, которая будет обновлять значение дополнительного множителя <span class="LaTeX">$n$</span> в выражении <span class="LaTeX">$n x^{n-1}$</span>:</p>
<pre><font color=Black>diff</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Ps</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a
<font color=Black>diff</font> <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color="#b2590f">=</font> diff' <font color="#0000ee">1</font> fs
    <font color="#b2590f">where</font> diff' n <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>n <font color=Black>*</font> g<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>diff' <font color=Black>(</font>n<font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> gs<font color=Black>)</font></pre>
<p>Также мы можем вычислить и интеграл степенного ряда:</p>
<pre><font color=Black>int</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Ps</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ps</font> a
<font color=Black>int</font> <font color=Black>(</font>f <font color="#b2590f">:+:</font> fs<font color=Black>)</font> <font color="#b2590f">=</font> <font color="#0000ee">0</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>int' <font color="#0000ee">1</font> fs<font color=Black>)</font> 
    <font color="#b2590f">where</font> int' n <font color=Black>(</font>g <font color="#b2590f">:+:</font> gs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>g <font color=Black>/</font> n<font color=Black>)</font> <font color="#b2590f">:+:</font> <font color=Black>(</font>int' <font color=Black>(</font>n<font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> gs<font color=Black>)</font></pre>
<h3 id="элементарные-функции"><a href="#TOC">Элементарные функции</a></h3>
<p>Мы можем выразить элементарные функции через операции взятия производной и интегрирования. К примеру уравнение для <span class="LaTeX">$e^x$</span> выглядит так:</p>
<p><span class="LaTeX">$\frac{dy}{dx} = y$</span></p>
<p>Проинтегрируем с начальным условием <span class="LaTeX">$y(0) = 1$</span>:</p>
<p><span class="LaTeX">$y(x) = 1 + \int_0^x y(t) dt$</span></p>
<p>Теперь переведём на Haskell:</p>
<pre><font color=Black>expx</font> <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>+</font> int expx</pre>
<p>Кажется невероятным, но это и есть определение экспоненты. Так же мы можем определить и функции для синуса и косинуса:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$\frac{d}{dx} \sin{x}$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$\cos{x},$</span></td>
<td align="left"><span class="LaTeX">$\sin(0) = 0,$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$\frac{d}{dx} \cos{x}$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$- \sin{x},$</span></td>
<td align="left"><span class="LaTeX">$\cos(0) = 1$</span></td>
</tr>
</tbody>
</table>
<p>Что приводит нас к:</p>
<pre><font color=Black>sinx</font> <font color="#b2590f">=</font> int cosx
<font color=Black>cosx</font> <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color="#2149c1">-</font> int sinx</pre>
<p>И это работает! Вычисление этих функций возможно за счёт того, что вне зависимости от аргумента функция <code><font color=Black>int</font></code> вернёт ряд, у которого первый коэффициент равен нулю. Это значение подхватывается и используется на следующем шаге рекурсивных вычислений.</p>
<p>Через синус и косинус мы можем определить тангенс:</p>
<pre><font color=Black>tanx</font> <font color="#b2590f">=</font> sinx <font color=Black>/</font> cosx</pre>
<h2 id="водосборы"><a href="#TOC">Водосборы</a></h2>
<p>В этом примере мы рассмотрим одну интересную технику рекурсивных вычислений, которая называется <em>мемоизацией</em> (memoization). Она заключается в том, что мы запоминаем все значения, с которыми вызывалась функция и, если с данным значением функция уже вычислялась, просто используем значение из памяти, а если значение ещё не вычислялось, вычисляем его и сохраняем.</p>
<p>В ленивых языках программирования для мемоизации функций часто используется такой приём. Мы сохраняем все значения функции в некотором контейнере, а затем обращаемся к элементам. При этом значения сохраняются в контейнере и не перевычисляются. Это происходит за счёт ленивых вычислений. Что интересно вычисляются не все значения, а лишь те, которые нам действительно нужны, те которые мы извлекаем из контейнера хотя бы один раз.</p>
<p>Посмотрим на такой классический пример. Вычисление чисел Фибоначчи. Каждое последующее число ряда Фибоначчи равно сумме двух предыдущих. Наивное определение выглядит так:</p>
<pre><font color=Black>fib</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>fib</font> <font color="#0000ee">0</font> <font color="#b2590f">=</font> <font color="#0000ee">0</font>
<font color=Black>fib</font> <font color="#0000ee">1</font> <font color="#b2590f">=</font> <font color="#0000ee">1</font>
<font color=Black>fib</font> n <font color="#b2590f">=</font> fib <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>+</font> fib <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">2</font><font color=Black>)</font></pre>
<p>В этом определении число вычислений растёт экспоненциально. Для того чтобы вычислить <code><font color=Black>fib</font> n</code> нам нужно вычислить <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font></code> и <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">2</font><font color=Black>)</font></code>, для того чтобы вычислить каждое из них нам нужно вычислить ещё два числа, и так вычисления удваиваются на каждом шаге. Если мы вызовем в интерпретаторе <code><font color=Black>fib</font> <font color="#0000ee">40</font></code>, то вычислитель зависнет. Что интересно в этой функции вычисления пересекаются, они могут быть переиспользованы. Например для вычисления <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font></code> и <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">2</font><font color=Black>)</font></code> нужно вычислить <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">2</font><font color=Black>)</font></code> (снова), <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">3</font><font color=Black>)</font></code>, <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">3</font><font color=Black>)</font></code> (снова) и <code><font color=Black>fib</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">4</font><font color=Black>)</font></code>.</p>
<p>Если мы сохраним все значения функции в списке, каждый вызов функции будет вычислен лишь один раз:</p>
<pre><font color=Black>fib'</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>fib'</font> n <font color="#b2590f">=</font> fibs <font color=Black>!!</font> n
    <font color="#b2590f">where</font> fibs <font color="#b2590f">=</font> <font color="#0000ee">0</font> <font color="#b2590f">:</font> <font color="#0000ee">1</font> <font color="#b2590f">:</font> zipWith <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> fibs <font color=Black>(</font>tail fibs<font color=Black>)</font></pre>
<p>Попробуем вычислить для <code><font color="#0000ee">40</font></code>:</p>
<pre><font color=Black>*</font><font color=Green>Fib</font><font color=Black>&gt;</font> fib' <font color="#0000ee">40</font>
<font color="#0000ee">102334155</font>
<font color=Black>*</font><font color=Green>Fib</font><font color=Black>&gt;</font> fib' <font color="#0000ee">4040</font>
<font color="#0000ee">700852629</font></pre>
<p>Вычисления происходят мгновенно. Если задача состоит из множества подзадач, которые самоподобны и для вычисления последующих подзадач используются решения из предыдущих, стоит задуматься об использовании мемоизации. Такие задачи называются задачами <em>динамического программирования</em>. Вычисление чисел Фибоначчи яркий пример задачи динамического программирования.</p>
<p>Рассмотрим такую задачу. Дана прямоугольная “карта местности”, в каждой клетке целым числом указана высота точки. Необходимо разметить местность по следующим правилам:</p>
<ul>
<li><p>Из каждой клетки карты вода стекает не более чем в одном из четырёх возможных направлений (“север”, “юг”, “запад”, “восток”).</p></li>
<li><p>Если у клетки нет соседе с высотой меньше её собственной высоты, то эта клетка – водосток, и вода из неё никуда дальше не течёт.</p></li>
<li><p>Иначе вода из текущей клетки стекает на соседнюю клетку с минимальной высотой.</p></li>
<li><p>Если таких соседей несколько, то вода стекает по первому из возможных направлений из списка “на север”, “на запад”, “на восток”, “на юг”.</p></li>
</ul>
<p>Все клетки из которых вода стекает в один и тот же водосток принадлежат к одному бассейну водосбора. Необходимо отметить на карте все бассейны. Решение этой задачи встретилось мне в статье Дмитрия Астапова “Рекурсия+мемоизация = динамическое программирование”. Здесь оно и приводится с незначительными изменениями.</p>
<p>Карта местности представлена в виде двумерного массива, в каждой клетке которого отмечена высота точки, нам необходимо получить двумерный массив того же размера, который вместо высот содержит метки водостоков. Мы будем отмечать их буквами латинского алфавита в том порядке, в котором они встречаются при обходе карты сверху вниз, слева направо. Например:</p>
<pre><font color="#0000ee">1</font> <font color="#0000ee">2</font> <font color="#0000ee">3</font> <font color="#0000ee">4</font> <font color="#0000ee">5</font> <font color="#0000ee">6</font>       a a a b b b
<font color="#0000ee">7</font> <font color="#0000ee">8</font> <font color="#0000ee">9</font> <font color="#0000ee">2</font> <font color="#0000ee">4</font> <font color="#0000ee">5</font>       a a b b b b
<font color="#0000ee">3</font> <font color="#0000ee">5</font> <font color="#0000ee">3</font> <font color="#0000ee">3</font> <font color="#0000ee">6</font> <font color="#0000ee">7</font>   <font color="#b2590f">-&gt;</font>  c c d b b e 
<font color="#0000ee">6</font> <font color="#0000ee">4</font> <font color="#0000ee">5</font> <font color="#0000ee">5</font> <font color="#0000ee">3</font> <font color="#0000ee">1</font>       f g d b e e
<font color="#0000ee">2</font> <font color="#0000ee">2</font> <font color="#0000ee">4</font> <font color="#0000ee">5</font> <font color="#0000ee">3</font> <font color="#0000ee">7</font>       f g g h h e</pre>
<p>Для представления двумерного массива мы воспользуемся типом <code><font color=Green>Array</font></code> из стандартного модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font></code>. Тип <code><font color=Green>Array</font></code> имеет два параметра:</p>
<pre><font color=Black>darta</font> <font color=Green>Array</font> i a</pre>
<p>Первый указывает на индекс, а второй на содержание. Массивы уже встречались нам в главе о типе <code><font color=Green>ST</font></code>. Напомню, что подразумевается, что этот тип является экземпляром класса <code><font color=Green>Ix</font></code>, который описывает целочисленные индексы, вспомним его определение:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Ix</font> a <font color="#b2590f">where</font>
    range       <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
    index       <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
    inRange     <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
    rangeSize   <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font></pre>
<p>Первый аргумент у всех этих функций это пара, которая представляет верхнюю и нижнюю грань последовательности. Попробуйте догадаться, что делают методы этого класса по типам и именам.</p>
<p>Для двумерного массива индекс будет задаваться парой целых чисел:</p>
<pre><font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font>

<font color="#b2590f">type</font> <font color=Green>Coord</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font>
<font color="#b2590f">type</font> <font color=Green>HeightMap</font> <font color="#b2590f">=</font> <font color=Green>Array</font> <font color=Green>Coord</font> <font color=Green>Int</font>
<font color="#b2590f">type</font> <font color=Green>SinkMap</font>   <font color="#b2590f">=</font> <font color=Green>Array</font> <font color=Green>Coord</font> <font color=Green>Coord</font></pre>
<p>Значение типа <code><font color=Green>HeightMap</font></code> хранит карту высот, значение типа <code><font color=Green>SinkMap</font></code> хранит в каждой координате, ту точку, которая является водостоком для данной точки. Нам необходимо построить функцию:</p>
<pre><font color=Black>flow</font> <font color="#b2590f">::</font> <font color=Green>HeightMap</font> <font color="#b2590f">-&gt;</font> <font color=Green>SinkMap</font></pre>
<p>Мы будем решать эту задачу рекурсивно. Представим, что мы знаем водостоки для всех точек кроме данной. Для каждой точки мы можем узнать в какую сторону из неё стекает вода. При этом водосток для следующей точки такой же как и для текущей. Если же из данной точки вода никуда не течёт, то она сама является водостоком. Мы определим эту функцию через комбинатор неподвижной точки <code><font color=Black>fix</font></code>.:</p>
<pre><font color=Black>flow</font> <font color="#b2590f">::</font> <font color=Green>HeightMap</font> <font color="#b2590f">-&gt;</font> <font color=Green>SinkMap</font>
<font color=Black>flow</font> arr <font color="#b2590f">=</font> fix <font color=Black>$</font> <font color="#b2590f">\</font>result <font color="#b2590f">-&gt;</font> listArray <font color=Black>(</font>bounds arr<font color=Black>)</font> <font color=Black>$</font> 
    map <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> maybe x <font color=Black>(</font>result <font color=Black>!</font><font color=Black>)</font> <font color=Black>$</font> getSink arr x<font color=Black>)</font> <font color=Black>$</font> 
    range <font color=Black>$</font> bounds arr 

<font color=Black>getSink</font> <font color="#b2590f">::</font> <font color=Green>HeightMap</font> <font color="#b2590f">-&gt;</font> <font color=Green>Coord</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Coord</font></pre>
<p>Мы ищем решение в виде неподвижной точки функции, которая принимает карту стоков и возвращает карту стоков. Функция <code><font color=Black>getSink</font></code> по данной точке на карте вычисляет соседнюю точку, в которую стекает вода. Эта функция частично определена, поскольку для водостоков нет такой соседней точки, в которую бы утекала вода. Функция <code><font color=Black>listArray</font></code> конструирует значение типа <code><font color=Green>Array</font></code> из списка значений. Первым аргументом она принимает диапазон значений для индексов. Размеры массива совпадают с размерами карты высот, поэтому первым аргументом мы передаём <code><font color=Black>bounds</font> arr</code>.</p>
<p>Теперь разберёмся с тем как заполняются значения в список. Сначала мы создаём список координат исходной карты высот с помощью выражения:</p>
<pre><font color=Black>range</font> <font color=Black>$</font> bounds arr</pre>
<p>После этого мы по координатам точек находим водостоки, причём сразу для всех точек. Это происходит в лямбда-функции:</p>
<pre><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> maybe x <font color=Black>(</font>result <font color=Black>!</font><font color=Black>)</font> <font color=Black>$</font> getSink arr x</pre>
<p>Мы принимаем текущую координату и с помощью функции <code><font color=Black>getSink</font></code> находим соседнюю точку, в которую убегает вода. Если такой точки нет, то в следующем выражении мы вернём исходную точку, поскольку в этом случае она и будет водостоком, а если такая соседняя точка всё-таки есть мы спросим результат из будущего. Мы обратимся к результату <code><font color=Black>(</font>result <font color=Black>!</font><font color=Black>)</font></code>, посмотрим каким окажется водосток для соседней точки и вернём это значение. Поскольку за счёт ленивых вычислений значения результирующего массива вычисляются лишь один раз, после того как мы найдём водосток для данной точки этим результатом смогут воспользоваться все соседние точки. При этом порядок обращения к значениям из будущих вычислений не играет роли.</p>
<p>Осталось только определить функцию поиска ближайшего стока и функцию разметки.</p>
<pre><font color=Black>getSink</font> <font color="#b2590f">::</font> <font color=Green>HeightMap</font> <font color="#b2590f">-&gt;</font> <font color=Green>Coord</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Coord</font>
<font color=Black>getSink</font> arr <font color=Black>(</font>x<font color=Black>,</font> y<font color=Black>)</font> 
    <font color="#b2590f">|</font> null sinks <font color="#b2590f">=</font> <font color=Green>Nothing</font>
    <font color="#b2590f">|</font> otherwise  <font color="#b2590f">=</font> <font color=Green>Just</font> <font color=Black>$</font> snd <font color=Black>$</font> minimum <font color=Black>$</font> map <font color=Black>(</font><font color="#b2590f">\</font>i <font color="#b2590f">-&gt;</font> <font color=Black>(</font>arr<font color=Black>!</font>i<font color=Black>,</font> i<font color=Black>)</font><font color=Black>)</font> sinks
    <font color="#b2590f">where</font> sinks <font color="#b2590f">=</font> filter p <font color="#b2590f">[</font><font color=Black>(</font>x<font color=Black>+</font><font color="#0000ee">1</font><font color=Black>,</font> y<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font>x<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>,</font> y<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font>x<font color=Black>,</font> y<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font>x<font color=Black>,</font> y<font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color="#b2590f">]</font>
          p i   <font color="#b2590f">=</font> inRange <font color=Black>(</font>bounds arr<font color=Black>)</font> i <font color=Black>&amp;&amp;</font> arr <font color=Black>!</font> i <font color=Black>&lt;</font> arr <font color=Black>!</font> <font color=Black>(</font>x<font color=Black>,</font> y<font color=Black>)</font></pre>
<p>В функции разметки мы воспользуемся ассоциативным массивом из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font></code>. Функция <code><font color=Black>nub</font></code> из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code> убирает из списка повторяющиеся элементы. Затем мы составляем список пар из координат водостоков и меток и в самом конце размечаем исходный массив:</p>
<pre><font color=Black>label</font> <font color="#b2590f">::</font> <font color=Green>SinkMap</font> <font color="#b2590f">-&gt;</font> <font color=Green>LabelMap</font>
<font color=Black>label</font> a <font color="#b2590f">=</font> fmap <font color=Black>(</font>m <font color=Green>M</font><font color=Black>.!</font> <font color=Black>)</font> a 
    <font color="#b2590f">where</font> m <font color="#b2590f">=</font> <font color=Green>M</font><font color=Black>.</font>fromList <font color=Black>$</font> flip zip <font color="#b2590f">[</font><font color=Black>'a'</font> <font color="#b2590f">..</font> <font color="#b2590f">]</font> <font color=Black>$</font> nub <font color=Black>$</font> elems a</pre>
<h2 id="ленивее-некуда"><a href="#TOC">Ленивее некуда</a></h2>
<p>Мы выяснили, что значение может редуцироваться только при сопоставлении с образцом и в специальной функции <code><font color=Black>seq</font></code>. Функцию <code><font color=Black>seq</font></code> мы можем применять, а можем и не применять. Но кажется, что в декомпозиции мы не можем уйти от необходимости проведения хотя бы одной редукции. Оказывается можем, в Haskell для этого предусмотрены специальные <em>ленивые образцы</em> (lazy patterns). Они обозначаются знаком тильда:</p>
<pre><font color=Black>lazyHead</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>lazyHead</font> <font color="#b2590f">~</font><font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> x</pre>
<p>Перед скобками сопоставления с образцом пишется символ тильда. Этим мы говорим вычислителю: доверься мне, здесь точно такой образец, можешь даже не проверять дальше. Он и правда дальше не пойдёт. Например если мы напишем такое определение:</p>
<pre><font color=Black>lazySafeHead</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> a
<font color=Black>lazySafeHead</font> <font color="#b2590f">~</font><font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Just</font> x
<font color=Black>lazySafeHead</font> <font color=Green>[]</font>      <font color="#b2590f">=</font> <font color=Green>Nothing</font>   </pre>
<p>Если мы подставим в эту функцию пустой список мы получим ошибку времени выполнения, вычислитель доверился нам в первом уравнении, а мы его обманули. Сохраним в модуле <code><font color=Green>Strict</font></code> и проверим:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:!</font> ghc <font color="#2149c1">--make Strict</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Strict</font>           <font color=Black>(</font> <font color=Green>Strict</font><font color=Black>.</font>hs<font color=Black>,</font> <font color=Green>Strict</font><font color=Black>.</font>o <font color=Black>)</font>

<font color=Green>Strict</font><font color=Black>.</font>hs<font color="#b2590f">:</font><font color="#0000ee">67</font><font color="#b2590f">:</font><font color="#0000ee">0</font><font color="#b2590f">:</font>
    <font color=Green>Warning</font><font color="#b2590f">:</font> <font color=Green>Pattern</font> match<font color=Black>(</font>es<font color=Black>)</font> are overlapped
             <font color=Green>In</font> the definition <font color="#b2590f">of</font> <font color=Black>`</font>lazySafeHead'<font color="#b2590f">:</font> lazySafeHead <font color=Green>[]</font> <font color="#b2590f">=</font> <font color=Black>...</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Strict</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Strict</font><font color=Black>.</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> lazySafeHead <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font>
<font color=Green>Just</font> <font color="#0000ee">1</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> lazySafeHead <font color=Green>[]</font>
<font color=Green>Just</font> <font color=Black>***</font> <font color=Green>Exception</font><font color="#b2590f">:</font> <font color=Green>Strict</font><font color=Black>.</font>hs<font color="#b2590f">:</font><font color=Black>(</font><font color="#0000ee">67</font><font color=Black>,</font><font color="#0000ee">0</font><font color=Black>)</font><font color="#2149c1">-</font><font color=Black>(</font><font color="#0000ee">68</font><font color=Black>,</font><font color="#0000ee">29</font><font color=Black>)</font><font color="#b2590f">:</font> <font color=Green>Irrefutable</font> 
<font color=Black>pattern</font> failed for pattern <font color=Black>(</font>x <font color="#b2590f">:</font> xs<font color=Black>)</font></pre>
<p>При компиляции нам даже сообщили о том, что образцы в декомпозиции пересекаются. Но мы были упрямы и напоролись на ошибку, если мы поменяем образцы местами, то всё пройдёт гладко:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:!</font> ghc <font color="#2149c1">--make Strict</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Strict</font>           <font color=Black>(</font> <font color=Green>Strict</font><font color=Black>.</font>hs<font color=Black>,</font> <font color=Green>Strict</font><font color=Black>.</font>o <font color=Black>)</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Strict</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Strict</font><font color=Black>.</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> lazySafeHead <font color=Green>[]</font>
<font color=Green>Nothing</font></pre>
<p>Отметим, что сопоставление с образцом в <code><font color="#b2590f">let</font></code> и <code><font color="#b2590f">where</font></code> выражениях является ленивым. Функцию <code><font color=Black>lazyHead</font></code> мы могли бы написать и так:</p>
<pre><font color=Black>lazyHead</font> a <font color="#b2590f">=</font> x
    <font color="#b2590f">where</font> <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> a

<font color=Black>lazyHead</font> a <font color="#b2590f">=</font> 
    <font color="#b2590f">let</font> <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> a
    <font color="#b2590f">in</font>  x</pre>
<p>Посмотрим как используются ленивые образцы при построении потоков, или бесконечных списков. Мы будем представлять функции одного аргумента потоками значений с одинаковым шагом. Так мы будем представлять непрерывные функции дискретными сигналами. Считаем, что шаг дискретизации (или шаг между соседними точками) нам известен.</p>
<p><span class="LaTeX">$f : R \rightarrow R \ \Rightarrow \ f_n = f(n \tau),\quad n = 0,1,2, ...$</span></p>
<p>Где <span class="LaTeX">$\tau$</span> – шаг дискретизации, а <span class="LaTeX">$n$</span> пробегает все натуральные числа. Определим функцию решения дифференциальных уравнений вида:</p>
<p><span class="LaTeX">$\frac{dx}{dt} = f(t)$</span></p>
<p><span class="LaTeX">$x(0) = \hat{x}$</span></p>
<p>Символ <span class="LaTeX">$\hat{x}$</span> означает начальное значение функции <span class="LaTeX">$x$</span>. Перейдём к дискретным сигналам:</p>
<p><span class="LaTeX">$\frac{x_n - x_{n-1}}{\tau} = f_n, \quad x_0 = \hat{x}$</span></p>
<p>Где <span class="LaTeX">$\tau$</span> – шаг дискретизации, а <span class="LaTeX">$x$</span> и <span class="LaTeX">$f$</span> – это потоки чисел, индекс <code><font color=Black>n</font></code> пробегает от нуля до бесконечности по всем точкам функции, превращённой в дискретный сигнал. Такой метод приближения дифференциальных уравнений называют методом Эйлера. Теперь мы можем выразить следующий элемент сигнала через предыдущий.</p>
<p><span class="LaTeX">$x_n = x_{n-1} + \tau f_n, \quad x_0 = \hat{x}$</span></p>
<p>Закодируем это уравнение:</p>
<pre><font color="#2149c1">-- шаг дискретизации</font>
<font color=Black>dt</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> a
<font color=Black>dt</font> <font color="#b2590f">=</font> <font color="#0000ee">1e-3</font>

<font color="#2149c1">-- метод Эйлера</font>
<font color=Black>int</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>int</font> x0 <font color=Black>(</font>f<font color="#b2590f">:</font>fs<font color=Black>)</font> <font color="#b2590f">=</font> x0 <font color="#b2590f">:</font> int <font color=Black>(</font>x0 <font color=Black>+</font> dt <font color=Black>*</font> f<font color=Black>)</font> fs</pre>
<p>Смотрите в функции <code><font color=Black>int</font></code> мы принимаем начальное значение <code><font color=Black>x0</font></code> и поток всех значений функции правой части уравнения, поток значений функции <span class="LaTeX">$f(t)$</span>. Мы помещаем начальное значение в первый элемент результата, а остальные значения получаем рекурсивно.</p>
<p>Определим две вспомогательные функции:</p>
<pre><font color=Black>time</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>time</font> <font color="#b2590f">=</font> <font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font> dt <font color="#b2590f">..</font><font color="#b2590f">]</font>

<font color=Black>dist</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>dist</font> n a b <font color="#b2590f">=</font> <font color=Black>(</font> <font color=Black>/</font> fromIntegral n<font color=Black>)</font> <font color=Black>$</font> 
    foldl' <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#0000ee">0</font> <font color=Black>$</font> take n <font color=Black>$</font> map abs <font color=Black>$</font> zipWith <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font> a b</pre>
<p>Функция <code><font color=Black>time</font></code> пробегает все значения отсчётов шага дискретизации по времени. Это тождественная функция представленная в виде потока с шагом <code><font color=Black>dt</font></code>.</p>
<p>Функция проверки результата <code><font color=Black>dist</font></code> принимает два потока и по ним считает расстояние между ними. Эта функция говорит, что расстояние между двумя потоками в <code><font color=Black>n</font></code> первых точках равно сумме модулей разности между значениями потоков. Для того чтобы оценить среднее расхождение, мы делим в конце результат на число точек.</p>
<p>Также импортируем для удобства символьный синоним для <code><font color=Black>fmap</font></code> из модуля <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font></code>.</p>
<pre><font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font><font color=Black>(</font><font color=Black>(</font><font color=Black>&lt;$&gt;</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>...</font></pre>
<p>Проверим функцию <code><font color=Black>int</font></code>. Для этого сохраним все новые функции в модуле <code><font color=Green>Stream</font><font color=Black>.</font>hs</code>. Загрузим модуль в интерпретатор и вычислим производную какой-нибудь функции. Найдём решение для правой части константы и проверим, что у нас получилась тождественная функция:</p>
<pre><font color=Black>*</font><font color=Green>Stream</font><font color=Black>&gt;</font> dist <font color="#0000ee">1000</font> time <font color=Black>$</font> int <font color="#0000ee">0</font> <font color=Black>$</font> repeat <font color="#0000ee">1</font>
<font color="#0000ee">7.37188088351104e-17</font></pre>
<p>Функции практически совпадают, порядок ошибки составляет <span class="LaTeX">$10^{-16}$</span>. Так и должно быть для линейных функций. Посмотрим, что будет если в правой части уравнения стоит тождественная функция:</p>
<pre><font color=Black>*</font><font color=Green>Stream</font><font color=Black>&gt;</font> dist <font color="#0000ee">1000</font> <font color=Black>(</font><font color=Black>(</font><font color="#b2590f">\</font>t <font color="#b2590f">-&gt;</font> t<font color=Black>^</font><font color="#0000ee">2</font><font color=Black>/</font><font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>&lt;$&gt;</font> time<font color=Black>)</font> <font color=Black>$</font> int <font color="#0000ee">0</font> time
<font color="#0000ee">2.497500000001403e-4</font></pre>
<p>Решение этого уравнения равно функции <span class="LaTeX">$\frac{t^2}{2}$</span>. Здесь мы видим, что результаты уже не такие хорошие.</p>
<p>Есть функции, которые определяются рекурсивно в терминах дифференциальных уравнений, например экспонента будет решением такого уравнения:</p>
<p><span class="LaTeX">$\frac{dx}{dt} = x$</span> <span class="LaTeX">$x(t) = x(0) + \int_{0}^{t} x(\tau) d \tau$</span></p>
<p>Опишем это уравнение в Haskell:</p>
<pre><font color=Black>e</font> <font color="#b2590f">=</font> int <font color="#0000ee">1</font> e</pre>
<p>Наше описание копирует исходное математическое определение. Добавим это уравнение в модуль <code><font color=Green>Stream</font></code> и проверим результаты:</p>
<pre><font color=Black>*</font><font color=Green>Stream</font><font color=Black>&gt;</font> dist <font color="#0000ee">1000</font> <font color=Black>(</font>map exp time<font color=Black>)</font> e
<font color=Black>^</font><font color=Green>CInterrupted</font><font color=Black>.</font></pre>
<p>К сожалению вычисление зависло. Нажмём <code><font color=Black>ctrl</font><font color=Black>+</font>c</code> и разберёмся почему. Для этого распишем вычисление потока чисел <code><font color=Black>e</font></code>:</p>
<pre>        e                           <font color="#2149c1">-- раскроем e </font>
<font color="#b2590f">=&gt;</font>      int <font color="#0000ee">1</font> e                     <font color="#2149c1">-- раскроем int, во втором варгументе</font>
                                    <font color="#2149c1">-- int стоит декомпозиция, </font>
<font color="#b2590f">=&gt;</font>      int <font color="#0000ee">1</font> e<font color="#b2590f">@</font><font color=Black>(</font>f<font color="#b2590f">:</font>fs<font color=Black>)</font>              <font color="#2149c1">-- для того чтобы узнать какое уравнение </font>
                                    <font color="#2149c1">-- для int выбрать нам нужно раскрыть </font>
                                    <font color="#2149c1">-- второй аргумент, узнать корневой </font>
                                    <font color="#2149c1">-- конструктор, раскроем второй аргумент:</font>
<font color="#b2590f">=&gt;</font>      int <font color="#0000ee">1</font> <font color=Black>(</font>int <font color="#0000ee">1</font> e<font color=Black>)</font>
<font color="#b2590f">=&gt;</font>      int <font color="#0000ee">1</font> <font color=Black>(</font>int <font color="#0000ee">1</font>e<font color="#b2590f">@</font><font color=Black>(</font>f<font color="#b2590f">:</font>fs<font color=Black>)</font><font color=Black>)</font>       <font color="#2149c1">-- такая же ситуация</font>
<font color="#b2590f">=&gt;</font>      int <font color="#0000ee">1</font> <font color=Black>(</font>int <font color="#0000ee">1</font> <font color=Black>(</font>int <font color="#0000ee">1</font> e<font color=Black>)</font><font color=Black>)</font></pre>
<p>Проблема в том, что первый элемент решения мы знаем, мы передаём его первым аргументом и присоединяем к решению, но <em>справа</em> от знака равно. Но для того чтобы перейти в правую часть вычислителю нужно проверить все аргументы, в которых есть декомпозиция. И он начинает проверять, но слишком рано. Нам бы хотелось, чтобы он сначала присоединил к решению первый аргумент, а затем выполнял бы вычисления следующего элемента.</p>
<p>C помощью ленивых образцов мы можем отложить декомпозицию второго аргумента на потом:</p>
<pre><font color=Black>int</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>int</font> x0 <font color="#b2590f">~</font><font color=Black>(</font>f<font color="#b2590f">:</font>fs<font color=Black>)</font> <font color="#b2590f">=</font> x0 <font color="#b2590f">:</font> int <font color=Black>(</font>x0 <font color=Black>+</font> dt <font color=Black>*</font> f<font color=Black>)</font> fs</pre>
<p>Теперь мы видим:</p>
<pre><font color=Black>*</font><font color=Green>Stream</font><font color=Black>&gt;</font> dist <font color="#0000ee">1000</font> <font color=Black>(</font>map exp time<font color=Black>)</font> e
<font color="#0000ee">4.988984990735441e-4</font></pre>
<p>Вычисления происходят. С помощью взаимно-рекурсивных функций мы можем определить функции синус и косинус:</p>
<pre><font color=Black>sinx</font> <font color="#b2590f">=</font> int <font color="#0000ee">0</font> cosx
<font color=Black>cosx</font> <font color="#b2590f">=</font> int <font color="#0000ee">1</font> <font color=Black>(</font>negate <font color=Black>&lt;$&gt;</font> sinx<font color=Black>)</font></pre>
<p>Эти функции описывают точку, которая бегает по окружности. Вот математическое определение:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$\frac{dx}{dt}$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$y$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$\frac{dy}{dt}$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$- x$</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="LaTeX">$x(0)$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$0$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$y(0)$</span></td>
<td align="center"><span class="LaTeX">$=$</span></td>
<td align="left"><span class="LaTeX">$1$</span></td>
</tr>
</tbody>
</table>
<p>Проверим в интерпретаторе:</p>
<pre><font color=Black>*</font><font color=Green>Stream</font><font color=Black>&gt;</font> dist <font color="#0000ee">1000</font> <font color=Black>(</font>sin <font color=Black>&lt;$&gt;</font> time<font color=Black>)</font> sinx
<font color="#0000ee">1.5027460329809257e-4</font>
<font color=Black>*</font><font color=Green>Stream</font><font color=Black>&gt;</font> dist <font color="#0000ee">1000</font> <font color=Black>(</font>cos <font color=Black>&lt;$&gt;</font> time<font color=Black>)</font> cosx
<font color="#0000ee">1.9088156807382827e-4</font></pre>
<p>Так с помощью ленивых образцов нам удалось попасть в правую часть уравнения для функции <code><font color=Black>int</font></code>, не раскрывая до конца аргументы в левой части. С помощью этого мы могли ссылаться в сопоставлении с образцом на значение, которое ещё не было вычислено.</p>
<h2 id="краткое-содержание"><a href="#TOC">Краткое содержание</a></h2>
<p>Ленивые вычисления повышают модульность программ. Мы можем в одной части программы создать все возможные решения, а в другой выбрать лучшие по какому-либо признаку. Также мы посмотрели на интересную технику написания рекурсивных функций, которая называется мемоизацией. Мемоизация означает, что мы не вычисляем повторно значения некоторой функции, а сохраняем их и используем в дальнейших вычислениях. Мы узнали новую синтаксическую конструкцию. Оказывается мы можем не только бороться с ленью, но и поощрять её. Лень поощряется ленивыми образцами. Они отменяют приведение к слабой заголовочной нормальной форме при декомпозиции аргументов. Они пишутся как обычные образцы, но со знаком тильда:</p>
<pre><font color=Black>lazyHead</font> <font color="#b2590f">~</font><font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> x</pre>
<p>Мы говорим вычислителю: поверь мне, это значение может иметь только такой вид, потом посмотришь так ли это, когда значения тебе понадобятся. Поэтому ленивые образцы проходят сопоставление с образцом в любом случае.</p>
<p>Сопоставление с образцом в <code><font color="#b2590f">let</font></code> и <code><font color="#b2590f">where</font></code> выражениях является ленивым. Функцию <code><font color=Black>lazyHead</font></code> мы могли бы написать и так:</p>
<pre><font color=Black>lazyHead</font> a <font color="#b2590f">=</font> x
    <font color="#b2590f">where</font> <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> a

<font color=Black>lazyHead</font> a <font color="#b2590f">=</font> 
    <font color="#b2590f">let</font> <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> a
    <font color="#b2590f">in</font>  x</pre>
<h2 id="упражнения"><a href="#TOC">Упражнения</a></h2>
<p>Мы побывали на выставке ленивых программ. Присмотритесь ещё раз к решениям задач этой главы и подумайте какую роль сыграли ленивые вычисления в каждом из случаев, какие мотивы обыгрываются в этих примерах. Также подумайте каким было бы решение, если бы в Haskell использовалась стратегия вычисления по значению. Критически настроенные читатели могут с помощью профилирования проверить эффективность программ из этой главы.</p>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="10.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="12.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="10" style="list-style-type: decimal">
<li>Реализация Haskell в GHC
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="12" style="list-style-type: decimal">
<li>Структурная рекурсия
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
