<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./style.css" type="text/css" />
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#теория-категорий">Теория категорий</a><ul>
<li><a href="#категория">Категория</a></li>
<li><a href="#функтор">Функтор</a></li>
<li><a href="#естественное-преобразование">Естественное преобразование</a></li>
<li><a href="#монады">Монады</a><ul>
<li><a href="#категория-клейсли">Категория Клейсли</a></li>
</ul></li>
<li><a href="#дуальность">Дуальность</a></li>
<li><a href="#начальный-и-конечный-объекты">Начальный и конечный объекты</a><ul>
<li><a href="#начальный-объект">Начальный объект</a></li>
<li><a href="#конечный-объект">Конечный объект</a></li>
</ul></li>
<li><a href="#сумма-и-произведение">Сумма и произведение</a></li>
<li><a href="#экспонента">Экспонента</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="14.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="16.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<!-- Switch argument character to $ to escape |  -->



<h1 id="теория-категорий"><a href="#теория-категорий">Теория категорий</a></h1>
<p>Многие понятия в Haskell позаимствованы из теории категорий, например это функторы, монады. Теория категорий – это скорее язык, математический жаргон, она настолько общая, что кажется ей нет никакого применения. Возможно это и так, но в этом языке многие сущности, которые лишь казались родственными и было смутное интуитивное ощущение их близости, становятся тождественными.</p>
<p>Теория категорий занимается описанием функций. В лямбда-исчислении основной операцией была подстановка значения в функцию, а в теории категорий мы сосредоточимся на операции композиции. Мы будем соединять различные объекты так, чтобы структура объектов сохранялась. Структура объекта будет определяться свойствами, которые продолжают выполнятся после преобразования объекта.</p>
<h2 id="категория"><a href="#категория">Категория</a></h2>
<p>Мы будем говорить об объектах и связях между ними. Связи принято называть “стрелками” или “морфизмами”. Далее мы будем пользоваться термином стрелка. У стрелки есть начальный объект, его называют <em>доменом</em> (domain) и конечный объект, его называют <em>кодоменом</em> (codomain).</p>
<div class="figure">
<img src="../pic/15/arrow.png" />
</div>
<p>В этой записи стрелка <span class="math">\(f\)</span> соединяет объекты <span class="math">\(A\)</span> и <span class="math">\(B\)</span>, в тексте мы будем писать это так <span class="math">\(f:A \rightarrow B\)</span>, словно стрелка это функция, а объекты это типы. Мы будем обозначать объекты большими буквами <span class="math">\(A\)</span>, <span class="math">\(B\)</span>, <span class="math">\(C\)</span>, …, а стрелки – маленькими буквами <span class="math">\(f\)</span>, <span class="math">\(g\)</span>, <span class="math">\(h\)</span>, … Для того чтобы связи было интереснее изучать мы введём такое правило:</p>
<div class="figure">
<img src="../pic/15/composition.png" />
</div>
<p>Если конец стрелки <span class="math">\(f\)</span> указывает на начало стрелки <span class="math">\(g\)</span>, то должна быть такая стрелка <span class="math">\(f \:\mathbf{;}\:g\)</span>, которая обозначает <em>составную</em> стрелку. Вводится специальная операция “точка с запятой”, которая называется композицией стрелок: Это правило говорит о том, что связи распространяются по объектам. Теперь у нас есть не просто объекты и стрелки, а целая сеть объектов, связанных между собой. Тот факт, что связи действительно распространяются отражается свойством:</p>
<p><span class="math">\[f \:\mathbf{;}\:(g \:\mathbf{;}\:h) = (f \:\mathbf{;}\:g) \:\mathbf{;}\:h\]</span></p>
<p>Это свойство называют ассоциативностью. Оно говорит о том, что стрелки, которые образуют составную стрелку являются цепочкой и нам не важен порядок их группировки, важно лишь кто за кем идёт. Подразумевается, что стрелки <span class="math">\(f\)</span>, <span class="math">\(g\)</span> и <span class="math">\(h\)</span> имеют подходящие типы для композиции, что их можно соединять. Это свойство похоже на интуитивное понятие пути, как цепочки отрезков.</p>
<p>Связи между объектами можно трактовать как преобразования объектов. Стрелка <span class="math">\(f : A \rightarrow B\)</span> – это способ, с помощью которого мы можем перевести объект <span class="math">\(A\)</span> в объект <span class="math">\(B\)</span>. Композиция в этой аналогии приобретает естественную интерпретацию. Если у нас есть способ <span class="math">\(f : A \rightarrow B\)</span> преобразования объекта <span class="math">\(A\)</span> в объект <span class="math">\(B\)</span>, и способ <span class="math">\(g : B \rightarrow C\)</span> преобразования объекта <span class="math">\(B\)</span> в объект <span class="math">\(C\)</span>, то мы конечно можем, применив сначала <span class="math">\(f\)</span>, а затем <span class="math">\(g\)</span>, получить из объекта <span class="math">\(A\)</span> объект <span class="math">\(C\)</span>.</p>
<p>Когда мы думаем о стрелках как о преобразовании, то естественно предположить, что у нас есть преобразование, которое ничего не делает, как тождественная функция. В будем говорить, что для каждого объекта <span class="math">\(A\)</span> есть стрелка <span class="math">\(id_A\)</span>, которая начинается из этого объекта и заканчивается в нём же.</p>
<p><span class="math">\[id_A : A \rightarrow A\]</span></p>
<p>Тот факт, что стрелка <span class="math">\(id_A\)</span> ничего не делает отражается свойствами, которые должны выполняться для всех стрелок:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="math">\(id_A \:\mathbf{;}\:f\)</span></td>
<td align="center"><span class="math">\(=\)</span></td>
<td align="left"><span class="math">\(f\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(f \:\mathbf{;}\:id_A\)</span></td>
<td align="center"><span class="math">\(=\)</span></td>
<td align="left"><span class="math">\(f\)</span></td>
</tr>
</tbody>
</table>
<p>Если мы добавим к любой стрелке тождественную стрелку, то от этого ничего не изменится.</p>
<p>Всё готово для того чтобы дать формальное определение понятия  <em>категории</em> (category). Категория это:</p>
<ul>
<li><p>Набор <em>объектов</em> (object).</p></li>
<li><p>Набор <em>стрелок</em> (arrow) или <em>морфизмов</em> (morphism).</p></li>
<li><p>Каждая стрелка соединяет два объекта, но объекты могут совпадать. Так обозначают, что стрелка <span class="math">\(f\)</span> начинается в объекте <span class="math">\(A\)</span> и заканчивается в объекте <span class="math">\(B\)</span>:</p>
<p><span class="math">\[f : A \rightarrow B\]</span></p>
<p>При этом стрелка соединяет только два объекта:</p>
<p><span class="math">\[f : A \rightarrow B,\ f : A&#39; \rightarrow B&#39; \qquad \Rightarrow \qquad A=A&#39;,\ B=B&#39;\]</span></p></li>
<li><p>Определена операция композиции или соединения стрелок. Если конец одной стрелки совпадает с началом другой, то их можно соединить вместе:</p>
<p><span class="math">\[f:A \rightarrow B,\ g : B\rightarrow C \quad \Rightarrow \quad f \:\mathbf{;}\:g : A \rightarrow C\]</span></p></li>
<li><p>Для каждого объекта есть стрелка, которая начинается и заканчивается в этом объекте. Эту стрелку называют <em>тождественной</em> (identity):</p>
<p><span class="math">\[id_A : A \rightarrow A\]</span></p></li>
</ul>
<p>Должны выполняться аксиомы:</p>
<ul>
<li><p>Тождество <span class="math">\(id\)</span></p>
<p><span class="math">\[id \:\mathbf{;}\:f = f\]</span></p>
<p><span class="math">\[f \:\mathbf{;}\:id = f\]</span></p></li>
<li><p>Ассоциативность <span class="math">\(\:\mathbf{;}\:\)</span></p>
<p><span class="math">\[f \:\mathbf{;}\:(g \:\mathbf{;}\:h) = (f \:\mathbf{;}\:g) \:\mathbf{;}\:h\]</span></p></li>
</ul>
<p>Приведём примеры категорий.</p>
<ul>
<li><p>Одна точка с одной тождественной стрелкой образуют категорию.</p></li>
<li><p>В категории <strong>Set</strong> объектами являются все множества, а стрелками – функции. Стрелки соединяются с помощью композиции функций, тождественная стрелка, это тождественная функция.</p></li>
<li><p>В категории <strong>Hask</strong> объектами являются типы Haskell, а стрелками – функции, стрелки соединяются с помощью композиции функций, тождественная стрелка, это тождественная функция.</p></li>
<li><p>Ориентированный граф может определять категорию. Объекты – это вершины, а стрелки это связанные пути в графе. Соединение стрелок – это соединение путей, а тождественная стрелка, это путь в котором нет ни одного ребра.</p></li>
<li><p>Упорядоченное множество, в котором есть операция сравнения на больше либо равно задаёт категорию. Объекты – это объекты множества. А стрелки это пары объектов таких, что первый объект меньше второго. Первый объект в паре считается начальным, а второй конечным.</p>
<p><span class="math">\[(a, b) : a \rightarrow b  \qquad \text{если } a \leq b\]</span></p>
<p>Стрелки соединяются так:</p>
<p><span class="math">\[(a, b) \:\mathbf{;}\:(b, c) = (a, c)\]</span></p>
<p>Тождественная стрелка состоит из двух одинаковых объектов:</p>
<p><span class="math">\[id_a = (a, a)\]</span></p>
<p>Можно убедиться в том, что это действительно категория. Для этого необходимо проверить аксиомы ассоциативности и тождества. Важно проверить, что те стрелки, которые получаются в результате композиции, не нарушали бы основного свойства данной структуры, то есть тот факт, что второй элемент пары всегда больше либо равен первого элемента пары.</p></li>
</ul>
<p>Отметим, что бывают такие области, в которых стрелки или преобразования с одинаковыми именами могут соединять несколько разных объектов. Например в Haskell есть классы, поэтому функции с одними и теми же именами могут соединять разные объекты. Если все условия категории для объектов и стрелок выполнены, кроме этого, то такую систему называют <em>прекатегорией</em> (pre-category). Из любой прекатегории не сложно сделать категорию, если включить имена объектов в имя стрелки. Тогда у каждой стрелки будут только одна пара объектов, которые она соединяет.</p>
<h2 id="функтор"><a href="#функтор">Функтор</a></h2>
<p>Вспомним определение класса <code><font color=Green>Functor</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">where</font>
    fmap <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>f a <font color="#b2590f">-&gt;</font> f b<font color=Black>)</font></pre>
<p>В этом определении участвуют тип <code><font color=Black>f</font></code> и метод <code><font color=Black>fmap</font></code>. Можно сказать, что тип <code><font color=Black>f</font></code> переводит произвольные типы <code><font color=Black>a</font></code> в специальные типы <code><font color=Black>f</font> a</code>. В этом смысле тип <code><font color=Black>f</font></code> является функцией, которая определена на типах. Метод <code><font color=Black>fmap</font></code> переводит функции общего типа <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> b</code> в специальные функции <code><font color=Black>f</font> a <font color="#b2590f">-&gt;</font> f b</code>.</p>
<p>При этом должны выполняться свойства:</p>
<pre><font color=Black>fmap</font> id  <font color="#b2590f">=</font> id
<font color=Black>fmap</font> <font color=Black>(</font>f <font color=Black>.</font> g<font color=Black>)</font> <font color="#b2590f">=</font> fmap f <font color=Black>.</font> fmap g</pre>
<p>Теперь вспомним о категории <code><font color=Green>Hask</font></code>. В этой категории объектами являются типы, а стрелками функции. Функтор <code><font color=Black>f</font></code> отображает объекты и стрелки категории <code><font color=Green>Hask</font></code> в объекты и стрелки <code><font color=Black>f</font> <font color=Green>Hask</font></code>. При этом оказывается, что за счёт свойств функтора <code><font color=Black>f</font> <font color=Green>Hask</font></code> образует категорию.</p>
<ul>
<li><p>Объекты – это типы <code><font color=Black>f</font> a</code>.</p></li>
<li><p>Стрелки – это функции <code><font color=Black>fmap</font> f</code>.</p></li>
<li><p>Композиция стрелок это просто композиция функций.</p></li>
<li><p>Тождественная стрелка это <code><font color=Black>fmap</font> id</code>.</p></li>
</ul>
<p>Проверим аксиомы:</p>
<pre><font color=Black>fmap</font> f <font color=Black>.</font> fmap id <font color="#b2590f">=</font> fmap f <font color=Black>.</font> id <font color="#b2590f">=</font> fmap f
<font color=Black>fmap</font> id <font color=Black>.</font> fmap f <font color="#b2590f">=</font> id <font color=Black>.</font> fmap f <font color="#b2590f">=</font> fmap f

    fmap f <font color=Black>.</font> <font color=Black>(</font>fmap g <font color=Black>.</font> fmap h<font color=Black>)</font> 
<font color="#b2590f">=</font>   fmap f <font color=Black>.</font> fmap <font color=Black>(</font>g <font color=Black>.</font> h<font color=Black>)</font> 
<font color="#b2590f">=</font>   fmap <font color=Black>(</font>f <font color=Black>.</font> <font color=Black>(</font>g <font color=Black>.</font> h<font color=Black>)</font><font color=Black>)</font>
<font color="#b2590f">=</font>   fmap <font color=Black>(</font><font color=Black>(</font>f <font color=Black>.</font> g<font color=Black>)</font> <font color=Black>.</font> h<font color=Black>)</font>
<font color="#b2590f">=</font>   fmap <font color=Black>(</font>f <font color=Black>.</font> g<font color=Black>)</font> <font color=Black>.</font> fmap h
<font color="#b2590f">=</font>   <font color=Black>(</font>fmap f <font color=Black>.</font> fmap g<font color=Black>)</font> <font color=Black>.</font> fmap h</pre>
<p>Видно, что аксиомы выполнены, так функтор <code><font color=Black>f</font></code> порождает категорию <code><font color=Black>f</font> <font color=Green>Hask</font></code>. Интересно, что поскольку <code><font color=Green>Hask</font></code> содержит все типы, то она содержит и типы <code><font color=Black>f</font> <font color=Green>Hask</font></code>. Получается, что мы построили категорию внутри категории. Это можно пояснить на примере списков. Тип <code><font color=Green>[]</font></code> погружает любой тип в список, а функцию для любого типа можно превратить в функцию, которая работает на списках с помощью метода <code><font color=Black>fmap</font></code>. При этом с помощью класса <code><font color=Green>Functor</font></code> мы проецируем все типы и все функции в мир списков <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font></code>. Но сам этот мир списков содержится в категории <code><font color=Green>Hask</font></code>.</p>
<p>С помощью функторов мы строим внутри одной категории другую категорию, при этом внутренняя категория обладает некоторой структурой. Так если раньше у нас были только произвольные типы <code><font color=Black>a</font></code> и произвольные функции <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> b</code>, то теперь все объекты имеют тип <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font></code> и все функции имеют тип <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font></code>. Также и функтор <code><font color=Green>Maybe</font></code> переводит произвольное значение, в значение, которое обладает определённой структурой. В нём выделен дополнительный элемент <code><font color=Green>Nothing</font></code>, который обозначает отсутствие значения. Если по типу <code><font color=Black>val</font> <font color="#b2590f">::</font> a</code> мы ничего не можем сказать о содержании значения <code><font color=Black>val</font></code>, то по типу <code><font color=Black>val</font> <font color="#b2590f">::</font> <font color=Green>Maybe</font> a</code>, мы знаем один уровень конструкторов. Например мы уже можем проводить сопоставление с образцом.</p>
<p>Теперь давайте вернёмся к теории категорий и дадим формальное определение понятия. Пусть <span class="math">\(\mathcal{A}\)</span> и <span class="math">\(\mathcal{B}\)</span> – категории, тогда  <em>функтором</em> из <span class="math">\(\mathcal{A}\)</span> в <span class="math">\(\mathcal{B}\)</span> называют отображение <span class="math">\(F\)</span>, которое переводит объекты <span class="math">\(\mathcal{A}\)</span> в объекты <span class="math">\(\mathcal{B}\)</span> и стрелки <span class="math">\(\mathcal{A}\)</span> в стрелки <span class="math">\(\mathcal{B}\)</span>, так что выполнены следующие свойства:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="math">\(F f\)</span></td>
<td align="center"><span class="math">\(:\)</span></td>
<td align="left"><span class="math">\(FA \rightarrow _{\mathcal{B}} FB\)</span></td>
<td align="left">если <span class="math">\(f: A \rightarrow _{\mathcal{A}} B\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(F id_A\)</span></td>
<td align="center"><span class="math">\(=\)</span></td>
<td align="left"><span class="math">\(id_{FA}\)</span></td>
<td align="left">для любого объекта</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="center"></td>
<td align="left"></td>
<td align="left"><span class="math">\(A\)</span> из <span class="math">\(\mathcal{A}\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(F (f \:\mathbf{;}\:g)\)</span></td>
<td align="center"><span class="math">\(=\)</span></td>
<td align="left"><span class="math">\(Ff \:\mathbf{;}\:Fg\)</span></td>
<td align="left">если <span class="math">\((f \:\mathbf{;}\:g)\)</span></td>
</tr>
</tbody>
</table>
<p>Здесь запись <span class="math">\(\rightarrow _\mathcal{A}\)</span> и <span class="math">\(\rightarrow _\mathcal{B}\)</span> означает, что эти стрелки в разных категориях. После отображения стрелки <span class="math">\(f\)</span> из категории <span class="math">\(\mathcal{A}\)</span> мы получаем стрелку в категории <span class="math">\(\mathcal{B}\)</span>, это и отражено в типе <span class="math">\(Ff : FA \rightarrow _\mathcal{B}FB\)</span>. Первое свойство говорит о том, что после отображения стрелки соединяют те же объекты, что и до отображения. Второе свойства говорит о сохранении тождественных стрелок. А последнее свойство, говорит о том, что “пути” между объектами также сохраняются. Если мы находимся в категории <span class="math">\(\mathcal{A}\)</span> в объекте <span class="math">\(A\)</span> и перед нами есть путь состоящий из нескольких стрелок в объект <span class="math">\(B\)</span>, то неважно как мы пойдём в <span class="math">\(FB\)</span> либо мы пройдём этот путь в категории <span class="math">\(\mathcal{A}\)</span> и в самом конце переместимся в <span class="math">\(FB\)</span> или мы сначала переместимся в <span class="math">\(FA\)</span> и затем пройдём по образу пути в категории <span class="math">\(FB\)</span>. Так и так мы попадём в одно и то же место. Схематически это можно изобразить так:</p>
<div class="figure">
<img src="../pic/15/functor.png" />
</div>
<p>Стрелки сверху находятся в категории <span class="math">\(\mathcal{A}\)</span>, а стрелки снизу находятся в категории <span class="math">\(\mathcal{B}\)</span>. Функтор <span class="math">\(F : \mathcal{A}\rightarrow \mathcal{A}\)</span>, который переводит категорию <span class="math">\(\mathcal{A}\)</span> в себя называют  <em>эндофунктором</em> (endofunctor). Функторы отображают одни категории в другие сохраняя структуру первой категории. Мы словно говорим, что внутри второй категории есть структура подобная первой. Интересно, что последовательное применение функторов, также является функтором. Мы будем писать последовательное применение функторов <span class="math">\(F\)</span> и <span class="math">\(G\)</span> слитно, как <span class="math">\(FG\)</span>. Также можно определить и тождественный функтор, который ничего не делает с категорией, мы будем обозначать его как <span class="math">\(I_\mathcal{A}\)</span> или просто <span class="math">\(I\)</span>, если категория на которой он определён понятна из контекста. Это говорит о том, что мы можем построить категорию, в которой объектами будут другие категории, а стрелками будут функторы.</p>
<h2 id="естественное-преобразование"><a href="#естественное-преобразование">Естественное преобразование</a></h2>
<p>В программировании часто приходится переводить данные из одной структуры в другую. Каждая из структур хранит какие-то конкретные значения, но мы ничего с ними не делаем мы просто перекладываем содержимое из одного ящика в другой. Например в нашем ящике только один отсек, но вдруг нам пришло бесконечно много подарков, что поделать нам приходится сохранить первый попавшийся, отбросив остальные. Главное в этой аналогии это то, что мы ничего не меняем, а лишь перекладываем содержимое из одной структуры в другую.</p>
<p>В Haskell это можно описать так:</p>
<pre><font color=Black>onlyOne</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> a
<font color=Black>onlyOne</font> <font color=Green>[]</font>      <font color="#b2590f">=</font> <font color=Green>Nothing</font>
<font color=Black>onlyOne</font> <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>  <font color="#b2590f">=</font> <font color=Green>Just</font> a</pre>
<p>В этой функции мы перекладываем элементы из списка <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font></code> в частично определённое значение <code><font color=Green>Maybe</font></code>. Тоже самое происходит и в функции <code><font color=Black>concat</font></code>:</p>
<pre><font color=Black>concat</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<p>Элементы перекладываются из списка списков в один список. В теории категорий этот процесс называется естественным преобразованием. Структуры определяются функторами. Поэтому в определении будет участвовать два функтора. В функции <code><font color=Black>onlyOne</font></code> это были функторы <code><font color=Green>[]</font></code> и <code><font color=Green>Maybe</font></code>. При перекладывании элементов мы можем просто выбросить все элементы:</p>
<pre><font color=Black>burnThemALl</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>()</font>
<font color=Black>burnThemAll</font> <font color="#b2590f">=</font> const <font color=Green>()</font></pre>
<p>Можно сказать, что единичный тип также определяет функтор. Это константный функтор, он переводит любой тип в единственное значение <code><font color=Green>()</font></code>, а функцию в <code><font color=Black>id</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Empty</font> a <font color="#b2590f">=</font> <font color=Green>Empty</font>

<font color="#b2590f">instance</font> <font color=Green>Functor</font> <font color=Green>Empty</font> <font color="#b2590f">where</font>
    fmap <font color="#b2590f">=</font> const id</pre>
<p>Тогда тип функции <code><font color=Black>burnThemAll</font></code> будет параметризован и слева и справа от стрелки:</p>
<pre><font color=Black>burnThemAll</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Empty</font> a
<font color=Black>burnThemAll</font> <font color="#b2590f">=</font> const <font color=Green>Empty</font></pre>
<p>Пусть даны две категории <span class="math">\(\mathcal{A}\)</span> и <span class="math">\(\mathcal{B}\)</span> и два функтора <span class="math">\(F,G : \mathcal{A}\rightarrow \mathcal{B}\)</span>. <em>Преобразованием</em> (transformation) в <span class="math">\(\mathcal{B}\)</span> из <span class="math">\(F\)</span> в <span class="math">\(G\)</span> называют семейство стрелок <span class="math">\(\varepsilon\)</span>:</p>
<p><span class="math">\[\varepsilon_A : FA \rightarrow _\mathcal{B}GA 
        \qquad \text{для любого } A \text{ из } \mathcal{A}\]</span></p>
<p>Рассмотрим преобразование <code><font color=Black>onlyOne</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> a</code>. Категории <span class="math">\(\mathcal{A}\)</span> и <span class="math">\(\mathcal{B}\)</span> в данном случае совпадают~– это категория <code><font color=Green>Hask</font></code>. Функтор <span class="math">\(F\)</span> – это список, а функтор <span class="math">\(G\)</span> это <code><font color=Green>Maybe</font></code>. Преобразование <code><font color=Black>onlyOne</font></code> для каждого объекта <code><font color=Black>a</font></code> из <code><font color=Green>Hask</font></code> определяет стрелку</p>
<pre><font color=Black>onlyOne</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> a</pre>
<p>Так мы получаем семейство стрелок, параметризованное объектом из <code><font color=Green>Hask</font></code>:</p>
<pre><font color=Black>onlyOne</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Int</font>
<font color=Black>onlyOne</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Char</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Char</font>
<font color=Black>onlyOne</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Black>(</font><font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font><font color=Black>)</font>
<font color=Black>...</font>
<font color=Black>...</font></pre>
<p>Теперь давайте определим, что значит перекладывать из одной структуры в другую, не меняя содержания. Представим, что функтор – это контейнер. Мы можем менять его содержание с помощью метода <code><font color=Black>fmap</font></code>. Например мы можем прибавить единицу ко всем элементам списка <code><font color=Black>xs</font></code> с помощью выражения . Точно так же мы можем прибавить единицу к частично определённому значению. С точки зрения теории категорий суть понятия “останется неизменным при перекладывании” заключается в том, что если мы возьмём любую функцию к примеру прибавление единицы, то нам неважно когда её применять до функции <code><font color=Black>onlyOne</font></code> или после. И в том и в другом случае мы получим одинаковый ответ. Давайте убедимся в этом:</p>
<pre>    onlyOne <font color=Black>$</font> fmap <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color="#b2590f">=&gt;</font>  onlyOne <font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">6</font><font color="#b2590f">]</font>
<font color="#b2590f">=&gt;</font>  <font color=Green>Just</font> <font color="#0000ee">2</font>

    fmap <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>$</font> onlyOne <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color="#b2590f">=&gt;</font>  fmap <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>$</font> <font color=Green>Just</font> <font color="#0000ee">1</font>
<font color="#b2590f">=&gt;</font>  <font color=Green>Just</font> <font color="#0000ee">2</font></pre>
<p>Результаты сошлись, обратите внимание на то, что функции <code><font color=Black>fmap</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font></code> в двух вариантах являются разными функциями. Первая работает на списках, а вторая на частично определённых значениях. Суть в том, что если при перекладывании значение не изменилось, то нам не важно когда выполнять преобразование внутри функтора <code><font color=Green>[]</font></code> или внутри функтора <code><font color=Green>Maybe</font></code>. Теперь давайте выразим это на языке теории категорий.</p>
<p>Преобразование <span class="math">\(\varepsilon\)</span> в категории <span class="math">\(\mathcal{B}\)</span> из функтора <span class="math">\(F\)</span> в функтор <span class="math">\(G\)</span> называют  <em>естественным</em> (natural), если</p>
<p><span class="math">\[Ff \:\mathbf{;}\:\varepsilon_B \ =\ \varepsilon_A \:\mathbf{;}\:Gf 
    \qquad \text{для любого } f : A \rightarrow _\mathcal{A}B\]</span></p>
<p>Это свойство можно изобразить графически:</p>
<div class="figure">
<img src="../pic/15/natural.png" />
</div>
<p>По смыслу ясно, что если у нас есть три структуры данных (или три функтора), если мы просто переложили данные из первой во вторую, а затем переложили данные из второй в третью, ничего не меняя. То итоговое преобразование, которое составлено из последовательного применения перекладывания данных также не меняет данные. Это говорит о том, что композиция двух естественных преобразований также является естественным преобразованием. Также мы можем составить тождественное преобразование, для двух одинаковых функторов <span class="math">\(F : \mathcal{A}\rightarrow \mathcal{B}\)</span>, это будет семейство тождественных стрелок в . Получается, что для двух категорий <span class="math">\(\mathcal{A}\)</span> и <span class="math">\(\mathcal{B}\)</span> мы можем составить категорию <span class="math">\(Ftr(\mathcal{A},\mathcal{B})\)</span>, в которой объектами будут функторы из <span class="math">\(\mathcal{A}\)</span> в <span class="math">\(\mathcal{B}\)</span>, а стрелками будут естественные преобразования. Поскольку естественные преобразования являются стрелками, которые соединяют функторы, мы будем обозначать их как обычные стрелки. Так запись <span class="math">\(\eta : F \rightarrow G\)</span> обозначает преобразование <span class="math">\(\eta\)</span>, которое переводит функтор <span class="math">\(F\)</span> в функтор <span class="math">\(G\)</span>.</p>
<p>Интересно, что изначально создатели теории категорий Саундедерс Маклейн и Сэмюэль Эйленберг придумали понятие естественного преобразования, а затем, чтобы дать ему обоснование было придумано понятие функтора, и наконец для того чтобы дать обоснование функторам были придуманы категории. Категории содержат объекты и стрелки, для стрелок есть операция композиции. Также для каждого объекта есть тождественная стрелка. Функторы являются стрелками в категории, в которой объектами являются другие категории. А естественные преобразования являются стрелками в категории, в которой объектами являются функторы. Получается такая иерархия структур.</p>
<h2 id="монады"><a href="#монады">Монады</a></h2>
<p> <em>Монадой</em> называют эндофунктор <span class="math">\(T:\mathcal{A}\rightarrow \mathcal{A}\)</span>, для которого определены два естественных преобразования <span class="math">\(\eta : I \rightarrow T\)</span> и <span class="math">\(\mu : TT \rightarrow T\)</span> и выполнены два свойства:</p>
<ul>
<li><p><span class="math">\(T \eta_A \:\mathbf{;}\:\mu_{A} \ =\ id_{TA}\)</span></p></li>
<li><p><span class="math">\(T \mu_A \:\mathbf{;}\:\mu_{TA} = \mu_{TTA} \:\mathbf{;}\:\mu_A\)</span></p></li>
</ul>
<p>Преобразование <span class="math">\(\eta\)</span> – это функция <code><font color=Black>return</font></code>, а преобразование <span class="math">\(\mu\)</span> – это функция <code><font color=Black>join</font></code>. В теории категорий в классе <code><font color=Green>Monad</font></code> другие методы. Перепишем эти свойства в виде функций Haskell:</p>
<pre><font color=Black>join</font> <font color=Black>.</font> fmap return   <font color="#b2590f">=</font> id
<font color=Black>join</font> <font color=Black>.</font> fmap join     <font color="#b2590f">=</font> join <font color=Black>.</font> join</pre>
<p>Порядок следования аргументов изменился, потому что мы пользуемся обычной композицией (через точку). Выражение <span class="math">\(T \eta_A\)</span> означает применение функтора <span class="math">\(T\)</span> к стрелке <span class="math">\(\eta_A\)</span>. Ведь преобразование это семейство стрелок, которые параметризованы объектами категории. На языке Haskell это означает применить <code><font color=Black>fmap</font></code> к полиморфной функции (функции с параметром).</p>
<p>Также эти свойства можно изобразить графически:</p>
<p><img src="../pic/15/monad1.png" /> <img src="../pic/15/monad2.png" /></p>
<h3 id="категория-клейсли"><a href="#категория-клейсли">Категория Клейсли</a></h3>
<p>Если у нас есть монада <span class="math">\(T\)</span>, определённая в категории <span class="math">\(\mathcal{A}\)</span>, то мы можем построить в этой категории категорию специальных стрелок вида <span class="math">\(A \rightarrow TB\)</span>. Эту категорию называют категорией Клейсли.</p>
<ul>
<li><p>Объекты категории Клейсли <span class="math">\(\mathcal{A}_T\)</span> – это объекты исходной категории <span class="math">\(\mathcal{A}\)</span>.</p></li>
<li><p>Стрелки в <span class="math">\(\mathcal{A}_T\)</span> это стрелки из <span class="math">\(\mathcal{A}\)</span> вида <span class="math">\(A \rightarrow TB\)</span>, мы будем обозначать их <span class="math">\(A \rightarrow _T B\)</span></p></li>
<li><p>Композиция стрелок <span class="math">\(f : A \rightarrow _T B\)</span> и <span class="math">\(g : B \rightarrow _T C\)</span> определена с помощью естественных преобразований монады <span class="math">\(T\)</span>:</p>
<p><span class="math">\[f \:\mathbf{;_{T}}\:g = f \:\mathbf{;}\:Tg \:\mathbf{;}\:\mu\]</span></p>
<p>Значок <span class="math">\(\:\mathbf{;_{T}}\:\)</span> указывает на то, что слева от равно композиция в <span class="math">\(\mathcal{A}_T\)</span>. Справа от знака равно используется композиция в исходной категории <span class="math">\(\mathcal{A}\)</span>.</p></li>
<li><p>Тождественная стрелка – это естественное преобразование <span class="math">\(\eta\)</span>.</p></li>
</ul>
<p>Можно показать, что категория Клейсли действительно является категорией и свойства операций композиции и тождества выполнены.</p>
<h2 id="дуальность"><a href="#дуальность">Дуальность</a></h2>
<p>Интересно, что если в категории <span class="math">\(\mathcal{A}\)</span> перевернуть все стрелки, то снова получится категория. Попробуйте нарисовать граф со стрелками, и затем мысленно переверните направление всех стрелок. Все пути исходного графа перейдут в перевёрнутые пути нового графа. При этом пути будут проходить через те же точки. Сохранятся композиции стрелок, только все они будут перевёрнуты. Такую категорию обозначают <span class="math">\(\mathcal{A}^{op}\)</span>. Но оказывается, что переворачивать мы можем не только категории но и свойства категорий, или утверждения о категориях, эту операцию называют <em>дуализацией</em>. Определим её:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="math">\(dual\ A\)</span></td>
<td align="center"><span class="math">\(\quad = \quad\)</span></td>
<td align="left"><span class="math">\(A\)</span></td>
<td align="left"><span class="math">\(\qquad\)</span></td>
<td align="left">если <span class="math">\(A\)</span> является объектом</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(dual\ x\)</span></td>
<td align="center"><span class="math">\(\quad = \quad\)</span></td>
<td align="left"><span class="math">\(x\)</span></td>
<td align="left"></td>
<td align="left">если <span class="math">\(x\)</span> обозначает стрелку</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(dual\ (f : A \rightarrow B)\)</span></td>
<td align="center"><span class="math">\(\quad = \quad\)</span></td>
<td align="left"><span class="math">\(dual\ f : B \rightarrow A\)</span></td>
<td align="left"></td>
<td align="left"><span class="math">\(A\)</span> и <span class="math">\(B\)</span> поменялись местами</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(dual\ (f \:\mathbf{;}\:g)\)</span></td>
<td align="center"><span class="math">\(\quad = \quad\)</span></td>
<td align="left"><span class="math">\(dual\ g \:\mathbf{;}\:dual\ f\)</span></td>
<td align="left"></td>
<td align="left"><span class="math">\(f\)</span> и <span class="math">\(g\)</span> поменялись местами</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(dual\ (id_A)\)</span></td>
<td align="center"><span class="math">\(\quad = \quad\)</span></td>
<td align="left"><span class="math">\(id_A\)</span></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Есть такое свойство, если и в исходной категории <span class="math">\(\mathcal{A}\)</span> выполняется какое-то утверждение, то в перевёрнутой категории <span class="math">\(\mathcal{A}^{op}\)</span> выполняется перевёрнутое (дуальное) свойство. Часто в теории категорий из одних понятий получают другие дуализацией. При этом мы можем не проверять свойства для нового понятия, они будут выполняться автоматически. К дуальным понятиям обычно добавляют приставку “ко”. Приведём пример, получим понятие комонады.</p>
<p>Для начала вспомним определение монады. Монада – это эндофунктор (функтор, у которого совпадают начало и конец или домен и кодомен) <span class="math">\(T : \mathcal{A}\rightarrow \mathcal{A}\)</span> и два естественных преобразования <span class="math">\(\eta : I \rightarrow T\)</span> и <span class="math">\(\mu : TT \rightarrow T\)</span>, такие что выполняются свойства:</p>
<ul>
<li><p><span class="math">\(T \eta \:\mathbf{;}\:\mu = id\)</span></p></li>
<li><p><span class="math">\(T \mu \:\mathbf{;}\:\mu = \mu \:\mathbf{;}\:\mu\)</span></p></li>
</ul>
<p>Дуализируем это определение. Комонада – это эндофунктор <span class="math">\(T : \mathcal{A}\rightarrow \mathcal{A}\)</span> и два естественных преобразования <span class="math">\(\eta : T \rightarrow I\)</span> и <span class="math">\(\mu : TT \rightarrow T\)</span>, такие что выполняются свойства</p>
<ul>
<li><p><span class="math">\(\mu \:\mathbf{;}\:T \eta = id\)</span></p></li>
<li><p><span class="math">\(\mu \:\mathbf{;}\:T \mu = \mu \:\mathbf{;}\:\mu\)</span></p></li>
</ul>
<p>Мы просто переворачиваем домены и кодомены в стрелках и меняем порядок в композиции. Проверьте сошлись ли типы. Попробуйте нарисовать графическую схему свойств комонады и сравните со схемой для монады.</p>
<p>Можно также определить и категорию коКлейсли. В категории коКлейсли все стрелки имеют вид <span class="math">\(TA \rightarrow B\)</span>. Теперь дуализируем композицию из категории Клейсли:</p>
<p><span class="math">\[f \:\mathbf{;_{T}}\:g = f \:\mathbf{;}\:Tg \:\mathbf{;}\:\mu\]</span></p>
<p>Теперь получим композицию в категории коКлейсли:</p>
<p><span class="math">\[g \:\mathbf{;_{T}}\:f = \mu \:\mathbf{;}\:Tg \:\mathbf{;}\:f\]</span></p>
<p>Мы перевернули цепочки композиций слева и справа от знака равно. Проверьте сошлись ли типы. Не забывайте что в этом определении <span class="math">\(\eta\)</span> и <span class="math">\(\mu\)</span> естественные преобразования для комонады. Нам не нужно проверять является ли категория коКлейсли действительно категорией. Нам не нужно опять проверять свойства стрелки тождества и ассоциативности композиции, если мы уже проверили их для монады. Следовательно перевёрнутое утверждение будет выполняться в перевёрнутой категории коКлейсли. В этом основное преимущество определения через дуализацию.</p>
<p>Этим приёмом мы можем воспользоваться и в Haskell, дуализируем класс <code><font color=Green>Monad</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Monad</font> m <font color="#b2590f">where</font>
    return  <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font>   <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b</pre>
<p>Перевернём все стрелки:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Comonad</font> c <font color="#b2590f">where</font>
    coreturn    <font color="#b2590f">::</font> c a <font color="#b2590f">-&gt;</font> a
    cobind      <font color="#b2590f">::</font> c b <font color="#b2590f">-&gt;</font> <font color=Black>(</font>c b <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> c a</pre>
<h2 id="начальный-и-конечный-объекты"><a href="#начальный-и-конечный-объекты">Начальный и конечный объекты</a></h2>
<h3 id="начальный-объект"><a href="#начальный-объект">Начальный объект</a></h3>
<p>Представим, что в нашей категории есть такой объект <span class="math">\(0\)</span>, который соединён со всеми объектами. Причём стрелка начинается из этого объекта и для каждого объекта может быть только одна стрелка которая соединят данный объект с <span class="math">\(0\)</span>. Графически эту ситуацию можно изобразить так:</p>
<div class="figure">
<img src="../pic/15/init1.png" />
</div>
<p> Такой объект называют <em>начальным</em> (initial object). Его принято обозначать нулём, словно это начало отсчёта. Для любого объекта <span class="math">\(A\)</span> из категории <span class="math">\(\mathcal{A}\)</span> с начальным объектом <span class="math">\(0\)</span> существует и только одна стрелка . Можно сказать, что начальный объект определяет функцию, которая переводит объекты <span class="math">\(A\)</span> в стрелки <span class="math">\(f : 0 \rightarrow A\)</span>. Эту функцию обозначают специальными скобками <span class="math">\((\hspace{-1.8pt}|\,\cdot\,|\hspace{-1.8pt})\)</span>, она называется   <em>катаморфизмом</em> (catamorphism).</p>
<p><span class="math">\[(\hspace{-1.8pt}|\,A\,|\hspace{-1.8pt}) = f : 0 \rightarrow A\]</span></p>
<p>У начального объекта есть несколько важных свойств. Они очень часто встречаются в разных вариациях, в понятиях, которые определяются через понятие начального объекта:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="math">\((\hspace{-1.8pt}|\,0\,|\hspace{-1.8pt}) = id_0\)</span></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><span class="math">\(\qquad\)</span></td>
<td align="left"><span class="math">\(\text{тождество}\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(f, g : 0 \rightarrow A\)</span></td>
<td align="left"><span class="math">\(\Rightarrow \)</span></td>
<td align="left"><span class="math">\(f = g\)</span></td>
<td align="left"></td>
<td align="left"><span class="math">\(\text{уникальность}\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(f: A \rightarrow B\)</span></td>
<td align="left"><span class="math">\(\Rightarrow \)</span></td>
<td align="left"><span class="math">\((\hspace{-1.8pt}|\,A\,|\hspace{-1.8pt}) \:\mathbf{;}\:f = (\hspace{-1.8pt}|\,B\,|\hspace{-1.8pt})\)</span></td>
<td align="left"></td>
<td align="left"><span class="math">\(\text{слияние (fusion)}\)</span></td>
</tr>
</tbody>
</table>
<p>Эти свойства следуют из определения начального объекта. Свойство тождества говорит о том, что стрелка ведущая из начального объекта в начальный является тождественной стрелкой. В самом деле по определению начального объекта для каждого объекта может быть только одна стрелка, которая начинается в <span class="math">\(0\)</span> и заканчивается в этом объекте. Стрелка <span class="math">\((\hspace{-1.8pt}|\,0\,|\hspace{-1.8pt})\)</span> начинается в <span class="math">\(0\)</span> и заканчивается в <span class="math">\(0\)</span>, но у нас уже есть одна такая стрелка, по определению категории для каждого объекта определена тождественная стрелка, значит эта стрелка является единственной.</p>
<p>Второе свойство следует из единственности стрелки, ведущей из начального объекта в данный. Третье свойство лучше изобразить графически:</p>
<div class="figure">
<img src="../pic/15/init2.png" />
</div>
<p>Поскольку стрелки <span class="math">\((\hspace{-1.8pt}|\,A\,|\hspace{-1.8pt})\)</span> и <span class="math">\(f\)</span> можно соединить, то должна быть определена стрелка <span class="math">\((\hspace{-1.8pt}|\,A\,|\hspace{-1.8pt}) \:\mathbf{;}\:f : 0 \rightarrow B\)</span>, но поскольку в категории с начальным объектом из начального объекта <span class="math">\(0\)</span> в объект <span class="math">\(B\)</span> может вести лишь одна стрелка, то стрелка <span class="math">\((\hspace{-1.8pt}|\,A\,|\hspace{-1.8pt}) \:\mathbf{;}\:f\)</span> должна совпадать с <span class="math">\((\hspace{-1.8pt}|\,B\,|\hspace{-1.8pt})\)</span>.</p>
<h3 id="конечный-объект"><a href="#конечный-объект">Конечный объект</a></h3>
<p>Дуализируем понятие начального объекта. Пусть в категории <span class="math">\(\mathcal{A}\)</span> есть объект <span class="math">\(1\)</span>, такой что для любого объекта <span class="math">\(A\)</span> существует и только одна стрелка, которая начинается из этого объекта и заканчивается в объекте <span class="math">\(1\)</span>. Такой объект называют  <em>конечным</em> (terminal object):</p>
<div class="figure">
<img src="../pic/15/final1.png" />
</div>
<p>Конечный объект определяет в категории функцию, которая ставит в соответствие объектам стрелки, которые начинаются из данного объекта и заканчиваются в конечном объекте. Такую функцию называют   <em>анаморфизмом</em> (anamorphism), и обозначают специальными скобками <span class="math">\([\hspace{-2.4pt}(\,\cdot\,)\hspace{-2.4pt}]\)</span>, которые похожи на перевёрнутые скобки для катаморфизма:</p>
<p><span class="math">\[[\hspace{-2.4pt}(\,A\,)\hspace{-2.4pt}] = f : A \rightarrow 1\]</span></p>
<p>Можно дуализировать и свойства:</p>
<table>
<tbody>
<tr class="odd">
<td align="left"><span class="math">\([\hspace{-2.4pt}(\,1\,)\hspace{-2.4pt}] = id_1\)</span></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"><span class="math">\(\qquad\)</span></td>
<td align="left">тождество</td>
</tr>
<tr class="even">
<td align="left"><span class="math">\(f, g : A \rightarrow 1\)</span></td>
<td align="left"><span class="math">\(\Rightarrow \)</span></td>
<td align="left"><span class="math">\(f = g\)</span></td>
<td align="left"></td>
<td align="left">уникальность</td>
</tr>
<tr class="odd">
<td align="left"><span class="math">\(f: A \rightarrow B\)</span></td>
<td align="left"><span class="math">\(\Rightarrow \)</span></td>
<td align="left"><span class="math">\(f \:\mathbf{;}\:[\hspace{-2.4pt}(\,B\,)\hspace{-2.4pt}]  = [\hspace{-2.4pt}(\,A\,)\hspace{-2.4pt}]\)</span></td>
<td align="left"></td>
<td align="left">слияние (fusion)</td>
</tr>
</tbody>
</table>
<p>Приведём иллюстрацию для свойства слияния:</p>
<div class="figure">
<img src="../pic/15/final2.png" />
</div>
<h2 id="сумма-и-произведение"><a href="#сумма-и-произведение">Сумма и произведение</a></h2>
<p>Давным-давно, когда мы ещё говорили о типах, мы говорили, что типы конструируются с помощью двух базовых операций: суммы и произведения. Сумма говорит о том, что значение может быть либо одним значением либо другим. А произведение обозначает сразу несколько значений. В Haskell есть два типа, которые представляют собой сумму и произведение в общем случае. Тип для суммы это <code><font color=Green>Either</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Either</font> a b <font color="#b2590f">=</font> <font color=Green>Left</font> a <font color="#b2590f">|</font> <font color=Green>Right</font> b</pre>
<p>Произведение в самом общем виде представлено кортежами:</p>
<pre><font color="#b2590f">data</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font></pre>
<p>В теории категорий сумма и произведение определяются как начальный и конечный объекты в специальных категориях. Теория категорий изучает объекты по тому как они взаимодействуют с остальными объектами. Взаимодействие обозначается с помощью стрелок. Специальные свойства стрелок определяют объект.</p>
<p>Например представим, что мы не можем заглядывать внутрь суммы типов, как бы мы могли взаимодействовать с объектом, который представляет собой сумму двух типов <span class="math">\(A+B\)</span>? Нам необходимо уметь создавать объект типа <span class="math">\(A+B\)</span> из объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span> извлекать их из суммы. Создание объектов происходит с помощью двух специальных конструкторов:</p>
<p><span class="math">\[inl : A \rightarrow A+B\]</span></p>
<p><span class="math">\[inr : B \rightarrow A+B\]</span></p>
<p>Также нам хочется уметь как-то извлекать значения. По смыслу внутри суммы <span class="math">\(A+B\)</span> хранится либо объект <span class="math">\(A\)</span> либо объект <span class="math">\(B\)</span> и мы не можем заранее знать какой из них, поскольку внутреннее содержание <span class="math">\(A+B\)</span> от нас скрыто, но мы знаем, что это только <span class="math">\(A\)</span> или <span class="math">\(B\)</span>. Это говорит о том, что если у нас есть две стрелки <span class="math">\(A \rightarrow C\)</span> и <span class="math">\(B \rightarrow C\)</span>, то мы как-то можем построить <span class="math">\(A+B \rightarrow C\)</span>. У нас есть операция:</p>
<p><span class="math">\[out(f,g) : A+B \rightarrow C \qquad f : A \rightarrow C,\ g : B \rightarrow C\]</span></p>
<p>При этом для того, чтобы стрелки <span class="math">\(inl\)</span>, <span class="math">\(inr\)</span> и <span class="math">\(out\)</span> были согласованы необходимо, чтобы выполнялись свойства:</p>
<p><span class="math">\[inl \:\mathbf{;}\:out(f,g)\ =\ f\]</span></p>
<p><span class="math">\[inr \:\mathbf{;}\:out(f,g)\ =\ g\]</span></p>
<p>Для любых функций <span class="math">\(f\)</span> и <span class="math">\(g\)</span>. Графически это свойство можно изобразить так:</p>
<div class="figure">
<img src="../pic/15/sum1.png" />
</div>
<p>Итак суммой двух объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span> называется объект <span class="math">\(A+B\)</span> и две стрелки <span class="math">\(inl : A \rightarrow A+B\)</span> и <span class="math">\(inr : B \rightarrow A+B\)</span> такие, что для любых двух стрелок <span class="math">\(f : A \rightarrow C\)</span> и <span class="math">\(g : B \rightarrow C\)</span> определена одна и только одна стрелка <span class="math">\(h : A+B \rightarrow C\)</span> такая, что выполнены свойства:</p>
<p><span class="math">\[inl \:\mathbf{;}\:h = f\]</span> <span class="math">\[inr \:\mathbf{;}\:h = g\]</span></p>
<p>В этом определении объект <span class="math">\(A+B\)</span> вместе со стрелками <span class="math">\(inl\)</span> и <span class="math">\(inr\)</span>, определяет функцию, которая по некоторому объекту <span class="math">\(C\)</span> и двум стрелкам <span class="math">\(f\)</span> и <span class="math">\(g\)</span> строит стрелку <span class="math">\(h\)</span>, которая ведёт <em>из</em> объекта <span class="math">\(A+B\)</span> в объект <span class="math">\(C\)</span>. Этот процесс определения стрелки по объекту напоминает определение начального элемента. Построим специальную категорию, в которой объект <span class="math">\(A+B\)</span> будет начальным. Тогда функция <span class="math">\(out\)</span> будет катаморфизмом.</p>
<p>Функция <span class="math">\(out\)</span> принимает две стрелки и возвращает третью. Посмотрим на типы:</p>
<p><span class="math">\[f : A \rightarrow C  \qquad\qquad inl : A \rightarrow A+B\]</span></p>
<p><span class="math">\[g : B \rightarrow C  \qquad\qquad inr : B \rightarrow A+B\]</span></p>
<p>Каждая из пар стрелок в столбцах указывают на один и тот же объект, а начинаются они из двух разных объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span>. Определим категорию, в которой объектами являются пары стрелок <span class="math">\((a_1, a_2)\)</span>, которые начинаются из объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span> и заканчиваются в некотором общем объекте <span class="math">\(D\)</span>. Эту категорию ещё называют клином. Стрелками в этой категории будут такие стрелки <span class="math">\(f : (d_1, d_2) \rightarrow (e_1, e_2)\)</span>, что стрелки в следующей диаграмме коммутируют (не важно по какому пути идти из двух разных точек).</p>
<div class="figure">
<img src="../pic/15/sum2.png" />
</div>
<p>Композиция стрелок – это обычная композиция в исходной категории, в которой определены объекты <span class="math">\(A\)</span> и <span class="math">\(B\)</span>, а тождественная стрелка для каждого объекта, это тождественная стрелка для того объекта, в котором сходятся обе стрелки. Можно проверить, что это действительно категория.</p>
<p>Если в этой категории есть начальный объект, то мы будем называть его суммой объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span>. Две стрелки, которые содержит этот объект мы будем называть <span class="math">\(inl\)</span> и <span class="math">\(inr\)</span>, а общий объект в котором эти стрелки сходятся будем называть <span class="math">\(A+B\)</span>. Теперь если мы выпишем определение для начального объекта, но вместо произвольных стрелок и объектов подставим наш конкретный случай, то мы получим как раз исходное определение суммы.</p>
<p>Начальный объект <span class="math">\((inl : A \rightarrow A+B,\ inr : B \rightarrow A+B)\)</span> ставит в соответствие любому объекту <span class="math">\((f : A \rightarrow C,\ g : B \rightarrow C)\)</span> стрелку <span class="math">\(h : A+B \rightarrow C\)</span> такую, что выполняются свойства:</p>
<div class="figure">
<img src="../pic/15/sum3.png" />
</div>
<p>А как на счёт произведения? Оказывается, что произведение является дуальным понятием по отношению к сумме. Его иногда называют косуммой, или сумму называют копроизведением. Дуализируем категорию, которую мы строили для суммы.</p>
<p>У нас есть категория <span class="math">\(\mathcal{A}\)</span> и в ней выделено два объекта <span class="math">\(A\)</span> и <span class="math">\(B\)</span>. Объектами новой категории будут пары стрелок <span class="math">\((a_1,a_2)\)</span>, которые <em>начинаются</em> в общем объекте <span class="math">\(C\)</span> а заканчиваются в объектах <span class="math">\(A\)</span> и <span class="math">\(B\)</span>. Стрелками в этой категории будут стрелки исходной категории <span class="math">\(h : (e_1,e_2) \rightarrow (d_1,d_2)\)</span> такие что следующая диаграмма коммутирует:</p>
<div class="figure">
<img src="../pic/15/prod1.png" />
</div>
<p>Композиция и тождественные стрелки позаимствованы из исходной категории <span class="math">\(\mathcal{A}\)</span>. Если в этой категории существует <em>конечный</em> объект. То мы будем называть его произведением объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span>. Две стрелки этого объекта обозначаются как <span class="math">\((exl,exr)\)</span>, а общий объект из которого они начинаются мы назовём <span class="math">\(A\times B\)</span>. Теперь распишем определение конечного объекта для нашей категории пар стрелок с общим началом.</p>
<p>Конечный объект <span class="math">\((exl : A \times B \rightarrow A, \ exr : A \times B \rightarrow B)\)</span> ставит в соответствие любому объекту категории <span class="math">\((f : C \rightarrow A,\ g : C \rightarrow B)\)</span> стрелку <span class="math">\(h : C \rightarrow A \times B\)</span>. При этом выполняются свойства:</p>
<div class="figure">
<img src="../pic/15/prod2.png" />
</div>
<p>Итак мы определили сумму, а затем на автомате, перевернув все утверждения, получили определение произведения. Но что это такое? Соответствует ли оно интуитивному понятию произведения?</p>
<p>Так же как и в случае суммы в теории категорий мы определяем понятие, через то как мы можем с ним взаимодействовать. Посмотрим, что нам досталось от абстрактного определения. У нас есть обозначение произведения типов <span class="math">\(A \times B\)</span>. Две стрелки <span class="math">\(exl\)</span> и <span class="math">\(exr\)</span>. Также у нас есть способ получить по двум функциям <span class="math">\(f : C \rightarrow A\)</span> и <span class="math">\(g : C \rightarrow B\)</span> стрелку <span class="math">\(h : C \rightarrow A \times B\)</span>. Для начала посмотрим на типы стрелок конечного объекта:</p>
<p><span class="math">\[exl : A \times B \rightarrow A\]</span></p>
<p><span class="math">\[exr : A \times B \rightarrow B\]</span></p>
<p>По типам видно, что эти стрелки разбивают пару на составляющие. По смыслу произведения мы точно знаем, что у нас есть в <span class="math">\(A\times B\)</span> и объект <span class="math">\(A\)</span> и объект <span class="math">\(B\)</span>. Эти стрелки позволяют нам извлекать компоненты пары. Теперь посмотрим на анаморфизм:</p>
<p><span class="math">\[[\hspace{-2.4pt}(\,f,g\,)\hspace{-2.4pt}] : C \rightarrow A \times B \qquad f : C \rightarrow A,\ g : C \rightarrow B\]</span></p>
<p>Эта функция позволяет строить пару по двум функциям и начальному значению. Но, поскольку здесь мы ничего не вычисляем, а лишь связываем объекты, мы можем по паре стрелок, которые начинаются из общего источника связать источник с парой конечных точек <span class="math">\(A \times B\)</span>.</p>
<p>При этом выполняются свойства:</p>
<p><span class="math">\[[\hspace{-2.4pt}(\,f,g\,)\hspace{-2.4pt}] \:\mathbf{;}\:exl = f\]</span></p>
<p><span class="math">\[[\hspace{-2.4pt}(\,f,g\,)\hspace{-2.4pt}] \:\mathbf{;}\:exr = g\]</span></p>
<p>Эти свойства говорят о том, что функции построения пары и извлечения элементов из пары согласованы. Если мы положим значение в первый элемент пары и тут же извлечём его, то это тоже само если бы мы не использовали пару совсем. То же самое и со вторым элементом.</p>
<h2 id="экспонента"><a href="#экспонента">Экспонента</a></h2>
<p>Если представить, что стрелки это функции, то может показаться, что все наши функции являются функциями одного аргумента. Ведь у стрелки есть только один источник. Как быть если мы хотим определить функцию нескольких аргументов, что она связывает? Если в нашей категории определено произведение объектов, то мы можем представить функцию двух аргументов, как стрелку, которая начинается из произведения:</p>
<p><span class="math">\[(+) : Num \times Num \rightarrow Num\]</span></p>
<p>Но в лямбда-исчислении нам были доступны более гибкие функции, функции могли принимать на вход функции и возвращать функции. Как с этим обстоят дела в теории категорий? Если перевести определение функций высшего порядка на язык теории категорий, то мы получим стрелки, которые могут связывать другие стрелки. Категория с функциями высшего порядка может содержать свои стрелки в качестве объектов. Стрелки как объекты обозначаются с помощью степени, так запись <span class="math">\(B^A\)</span> означает стрелку <span class="math">\(A \rightarrow B\)</span>. При этом нам необходимо уметь интерпретировать стрелку, мы хотим уметь подставлять значения. Если у нас есть объект <span class="math">\(B^A\)</span>, то должна быть стрелка</p>
<p><span class="math">\[eval : B^A \times A \rightarrow B\]</span></p>
<p>На языке функций можно сказать, что стрелка <span class="math">\(eval\)</span> принимает функцию высшего порядка <span class="math">\(A \rightarrow B\)</span> и значение типа <span class="math">\(A\)</span>, а возвращает значение типа <span class="math">\(B\)</span>. Объект <span class="math">\(B^A\)</span> называют экспонентой. Теперь дадим формальное определение.</p>
<p>Пусть в категории <span class="math">\(\mathcal{A}\)</span> определено произведение.  <em>Экспонента</em> – это объект <span class="math">\(B^A\)</span> вместе со стрелкой <span class="math">\(eval : B^A \times A \rightarrow B\)</span> такой, что для любой стрелки <span class="math">\(f : C \times A \rightarrow B\)</span> определена стрелка <span class="math">\(curry(f):C \rightarrow B^A\)</span> при этом следующая диаграмма коммутирует:</p>
<div class="figure">
<img src="../pic/15/exponent1.png" />
</div>
<p>Давайте разберёмся, что это всё означает. По смыслу стрелка <span class="math">\(curry(f)\)</span> это каррированная функция двух аргументов. Вспомните о функции <code><font color=Black>curry</font></code> из Haskell. Диаграмма говорит о том, что если мы каррированием функции двух аргументов получим функцию высшего порядка <span class="math">\(C \rightarrow B^A\)</span>, а затем с помощью функции <span class="math">\(eval\)</span> получим значение, то это всё равно, что подставить два значения в исходную функцию. Запись <span class="math">\((curry(f), id)\)</span> означает параллельное применение двух стрелок внутри пары:</p>
<p><span class="math">\[(f, g) : A \times A&#39; \rightarrow B \times B&#39; 
            , \qquad f : A\rightarrow B , \ g : A&#39; \rightarrow B&#39;\]</span></p>
<p>Так применив стрелки <span class="math">\(curry(f) : C \rightarrow B^A\)</span> и <span class="math">\(id : A \rightarrow A\)</span> к паре <span class="math">\(C \times A\)</span>, мы получим пару <span class="math">\(B^A \times A\)</span>. Применение здесь условное мы подразумеваем применение в функциональной аналогии, в теории категорий происходит связывание пар объектов с помощью стрелки <span class="math">\((f, g)\)</span>.</p>
<p>Интересно, что и экспоненту можно получить как конечный объект в специальной категории. Пусть есть категория <span class="math">\(\mathcal{A}\)</span> и в ней определено произведение объектов <span class="math">\(A\)</span> и <span class="math">\(B\)</span>. Построим категорию, в которой объектами являются стрелки вида:</p>
<p><span class="math">\[C \times A \rightarrow B\]</span></p>
<p>где <span class="math">\(C\)</span> – это произвольный объект исходной категории. Стрелкой между объектами <span class="math">\(c : C \times A \rightarrow B\)</span> и <span class="math">\(d : D \times A \rightarrow B\)</span> в этой категории будет стрелка <span class="math">\(f : C \rightarrow D\)</span> из исходной категории, такая, что следующая диаграмма коммутирует:</p>
<div class="figure">
<img src="../pic/15/exponent2.png" />
</div>
<p>Если в этой категории существует конечный объект, то он является экспонентой. А функция <span class="math">\(curry\)</span> является анаморфизмом для экспоненты.</p>
<h2 id="краткое-содержание"><a href="#краткое-содержание">Краткое содержание</a></h2>
<p>Теория категорий изучает понятия через то как эти понятия взаимодействуют друг с другом. Мы забываем о том, как эти понятия реализованы, а смотрим лишь на свойства связей.</p>
<p>Мы узнали что такое категория. Категория это структура с объектами и стрелками. Стрелки связывают объекты. Причём связи могут соединятся. Также считается, что объект всегда связан сам с собой. Мы узнали, что есть такие категории, в которых сами категории являются объектами, а стрелки в таких категориях мы назвали функторами. Также мы узнали, что сами функторы могут стать объектами в некоторой категории, тогда стрелки в этой категории мы будем называть естественными преобразованиями.</p>
<p>Мы узнали что такое начальный и конечный объект и как с помощью этих понятий можно определить сумму и произведение типов. Также мы узнали как в теории категорий описываются функции высших порядков.</p>
<h2 id="упражнения"><a href="#упражнения">Упражнения</a></h2>
<ul>
<li><p>Проверьте аксиомы категории (ассоциативность и тождество) для категории функторов и категории естественных преобразований.</p></li>
<li><p>Изоморфизмом называют такие стрелки <span class="math">\(f:A \rightarrow B\)</span> и <span class="math">\(g : B \rightarrow A\)</span>, для которых выполнено свойство:</p>
<p><span class="math">\[f \:\mathbf{;}\:g = id_A\]</span> <span class="math">\[g \:\mathbf{;}\:f = id_B\]</span></p>
<p>Объекты <span class="math">\(A\)</span> и <span class="math">\(B\)</span> называют изоморфными, если они связаны изоморфизмом, это обозначают так: <span class="math">\(A \cong B\)</span>. Докажите, что все начальные и конечные элементы изоморфны.</p></li>
<li><p>Поскольку сумма и произведение типов являются начальным и конечным объектами в специальных категориях для них также выполняются свойства тождества, уникальности и слияния. Выпишите эти свойства для суммы и произведения.</p></li>
<li><p>Подумайте как можно определить экземпляр класса <code><font color=Green>Comonad</font></code> для потоков:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Stream</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> <font color=Green>Stream</font> a</pre>
<p>Можно ли придумать экземпляр для класса <code><font color=Green>Monad</font></code>?</p></li>
<li><p>Дуальную категорию для категории <span class="math">\(\mathcal{A}\)</span> обозначают <span class="math">\(\mathcal{A}^{op}\)</span>. Если <span class="math">\(F\)</span> является функтором в категории <span class="math">\(\mathcal{A}^{op}\)</span>, то в исходной категории его называют <em>контравариантным</em> функтором. Выпишите определение функтора в <span class="math">\(\mathcal{A}^{op}\)</span>, а затем с помощью дуализации получите свойства контравариантного функтора в исходной категории <span class="math">\(\mathcal{A}\)</span>.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="14.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="16.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="14" style="list-style-type: decimal">
<li>Лямбда-исчисление
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="16" style="list-style-type: decimal">
<li>Категориальные типы
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
