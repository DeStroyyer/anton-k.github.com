<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./style.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#дополнительные-возможности">Дополнительные возможности</a><ul>
<li><a href="#пуд-сахара">Пуд сахара</a><ul>
<li><a href="#сахар-для-списков">Сахар для списков</a></li>
<li><a href="#сахар-для-монад-do-нотация">Сахар для монад, do-нотация</a></li>
</ul></li>
<li><a href="#расширения">Расширения</a><ul>
<li><a href="#обобщённые-алгебраические-типы-данных">Обобщённые алгебраические типы данных</a></li>
<li><a href="#семейства-типов">Семейства типов</a></li>
<li><a href="#классы-с-несколькими-типами">Классы с несколькими типами</a></li>
<li><a href="#экземпляры-классов-для-синонимов">Экземпляры классов для синонимов</a></li>
<li><a href="#функциональные-зависимости">Функциональные зависимости</a></li>
<li><a href="#ограничение-мономорфизма">Ограничение мономорфизма</a></li>
<li><a href="#полиморфизм-высших-порядков">Полиморфизм высших порядков</a></li>
<li><a href="#лексически-связанные-типы">Лексически связанные типы</a></li>
<li><a href="#и-другие-удобства-и-украшения">И другие удобства и украшения</a></li>
</ul></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="16.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="18.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="дополнительные-возможности"><a href="#дополнительные-возможности">Дополнительные возможности</a></h1>
<p>В этой главе мы рассмотрим некоторые дополнительные возможности языка и расширения, которые часто используются в серьёзных программах. Можно писать программы и без них, но с ними гораздо легче и увлекательней.</p>
<h2 id="пуд-сахара"><a href="#пуд-сахара">Пуд сахара</a></h2>
<p>В этом разделе мы рассмотрим специальный синтаксический сахар, который позволяет более кратко записывать операции для некоторых структур.</p>
<h3 id="сахар-для-списков"><a href="#сахар-для-списков">Сахар для списков</a></h3>
<h4 id="перечисления"><a href="#перечисления">Перечисления</a></h4>
<p>Для класса <code><font color=Green>Enum</font></code> определён специальный синтаксис составления последовательностей перечисляемых значений. Так, например, мы можем составить список целых чисел от нуля до десяти:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color="#0000ee">0</font> <font color="#b2590f">..</font> <font color="#0000ee">10</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">9</font><font color=Black>,</font><font color="#0000ee">10</font><font color="#b2590f">]</font></pre>
<p>А так мы можем составить бесконечную последовательность положительных чисел:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> take <font color="#0000ee">20</font> <font color=Black>$</font> <font color="#b2590f">[</font><font color="#0000ee">0</font> <font color="#b2590f">..</font> <font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">9</font><font color=Black>,</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">11</font><font color=Black>,</font><font color="#0000ee">12</font><font color=Black>,</font><font color="#0000ee">13</font><font color=Black>,</font><font color="#0000ee">14</font><font color=Black>,</font><font color="#0000ee">15</font><font color=Black>,</font><font color="#0000ee">16</font><font color=Black>,</font><font color="#0000ee">17</font><font color=Black>,</font><font color="#0000ee">18</font><font color=Black>,</font><font color="#0000ee">19</font><font color="#b2590f">]</font></pre>
<p>Мы можем составлять последовательности с определённым шагом. Так можно выделить все чётные положительные числа:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> take <font color="#0000ee">20</font> <font color=Black>$</font> <font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">2</font> <font color="#b2590f">..</font> <font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">12</font><font color=Black>,</font><font color="#0000ee">14</font><font color=Black>,</font><font color="#0000ee">16</font><font color=Black>,</font><font color="#0000ee">18</font><font color=Black>,</font><font color="#0000ee">20</font><font color=Black>,</font><font color="#0000ee">22</font><font color=Black>,</font><font color="#0000ee">24</font><font color=Black>,</font><font color="#0000ee">26</font><font color=Black>,</font><font color="#0000ee">28</font><font color=Black>,</font><font color="#0000ee">30</font><font color=Black>,</font><font color="#0000ee">32</font><font color=Black>,</font><font color="#0000ee">34</font><font color=Black>,</font><font color="#0000ee">36</font><font color=Black>,</font><font color="#0000ee">38</font><font color="#b2590f">]</font></pre>
<p>А так мы можем составить убывающую последовательность чисел:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color="#0000ee">10</font><font color=Black>,</font> <font color="#0000ee">9</font> <font color="#b2590f">..</font> <font color="#0000ee">0</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">9</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">0</font><font color="#b2590f">]</font></pre>
<p>Что интересно, в списке могут находиться не только числа, но и любые значения из класса <code><font color=Green>Enum</font></code>. Например, определим тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Day</font>    <font color="#b2590f">=</font> <font color=Green>Monday</font> <font color="#b2590f">|</font> <font color=Green>Tuesday</font> <font color="#b2590f">|</font> <font color=Green>Wednesday</font> <font color="#b2590f">|</font> <font color=Green>Thursday</font>
            <font color="#b2590f">|</font> <font color=Green>Friday</font> <font color="#b2590f">|</font> <font color=Green>Saturday</font> <font color="#b2590f">|</font> <font color=Green>Sunday</font>
            <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Enum</font><font color=Black>)</font></pre>
<p>Теперь мы можем написать:</p>
<pre><font color=Black>*</font><font color=Green>Week</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color=Green>Friday</font> <font color="#b2590f">..</font> <font color=Green>Sunday</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color=Green>Friday</font><font color=Black>,</font><font color=Green>Saturday</font><font color=Black>,</font><font color=Green>Sunday</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Week</font><font color=Black>&gt;</font> <font color="#b2590f">[</font> <font color=Green>Monday</font> <font color="#b2590f">..</font> <font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color=Green>Monday</font><font color=Black>,</font><font color=Green>Tuesday</font><font color=Black>,</font><font color=Green>Wednesday</font><font color=Black>,</font><font color=Green>Thursday</font><font color=Black>,</font><font color=Green>Friday</font><font color=Black>,</font><font color=Green>Saturday</font><font color=Black>,</font><font color=Green>Sunday</font><font color="#b2590f">]</font></pre>
<p>Также шаг последовательности может быть и дробным:</p>
<pre><font color=Black>*</font><font color=Green>Week</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">0.5</font> <font color="#b2590f">..</font> <font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">0.0</font><font color=Black>,</font><font color="#0000ee">0.5</font><font color=Black>,</font><font color="#0000ee">1.0</font><font color=Black>,</font><font color="#0000ee">1.5</font><font color=Black>,</font><font color="#0000ee">2.0</font><font color=Black>,</font><font color="#0000ee">2.5</font><font color=Black>,</font><font color="#0000ee">3.0</font><font color=Black>,</font><font color="#0000ee">3.5</font><font color=Black>,</font><font color="#0000ee">4.0</font><font color="#b2590f">]</font></pre>
<h4 id="генераторы-списков"><a href="#генераторы-списков">Генераторы списков</a></h4>
<p> <em>Генераторы списков</em> (list comprehensions) объединяют в себе функции преобразования и фильтрации списков. Они записываются так:</p>
<pre><font color="#b2590f">[</font> f x <font color="#b2590f">|</font> x <font color="#b2590f">&lt;-</font> list<font color=Black>,</font> p x<font color="#b2590f">]</font></pre>
<p>В этой записи мы фильтруем список <code><font color=Black>list</font></code> предикатом <code><font color=Black>p</font></code> и преобразуем результат функцией <code><font color=Black>f</font></code>. Например, возведём в квадрат все чётные элементы списка:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">[</font>x<font color=Black>*</font>x <font color="#b2590f">|</font> x <font color="#b2590f">&lt;-</font> <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">10</font><font color="#b2590f">]</font><font color=Black>,</font> even x<font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">16</font><font color=Black>,</font><font color="#0000ee">36</font><font color=Black>,</font><font color="#0000ee">64</font><font color=Black>,</font><font color="#0000ee">100</font><font color="#b2590f">]</font></pre>
<p>Предикатов может быть несколько. Так, например, мы можем оставить лишь положительные чётные числа:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">[</font>x <font color="#b2590f">|</font> x <font color="#b2590f">&lt;-</font> <font color="#b2590f">[</font><font color="#2149c1">-</font><font color="#0000ee">10</font> <font color="#b2590f">..</font> <font color="#0000ee">10</font><font color="#b2590f">]</font><font color=Black>,</font> even x<font color=Black>,</font> x <font color=Black>&gt;=</font> <font color="#0000ee">0</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">10</font><font color="#b2590f">]</font></pre>
<p>Также элементы могут браться из нескольких списков, посмотрим на все возможные комбинации букв из пары слов:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">[</font> <font color="#b2590f">[</font>x<font color=Black>,</font>y<font color="#b2590f">]</font> <font color="#b2590f">|</font> x <font color="#b2590f">&lt;-</font> <font color=Black>"Hello"</font><font color=Black>,</font> y <font color="#b2590f">&lt;-</font> <font color=Black>"World"</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color=Black>"HW"</font><font color=Black>,</font><font color=Black>"Ho"</font><font color=Black>,</font><font color=Black>"Hr"</font><font color=Black>,</font><font color=Black>"Hl"</font><font color=Black>,</font><font color=Black>"Hd"</font><font color=Black>,</font><font color=Black>"eW"</font><font color=Black>,</font><font color=Black>"eo"</font><font color=Black>,</font><font color=Black>"er"</font><font color=Black>,</font><font color=Black>"el"</font><font color=Black>,</font>
 <font color=Black>"ed"</font><font color=Black>,</font><font color=Black>"lW"</font><font color=Black>,</font><font color=Black>"lo"</font><font color=Black>,</font><font color=Black>"lr"</font><font color=Black>,</font><font color=Black>"ll"</font><font color=Black>,</font><font color=Black>"ld"</font><font color=Black>,</font><font color=Black>"lW"</font><font color=Black>,</font><font color=Black>"lo"</font><font color=Black>,</font><font color=Black>"lr"</font><font color=Black>,</font>
 <font color=Black>"ll"</font><font color=Black>,</font><font color=Black>"ld"</font><font color=Black>,</font><font color=Black>"oW"</font><font color=Black>,</font><font color=Black>"oo"</font><font color=Black>,</font><font color=Black>"or"</font><font color=Black>,</font><font color=Black>"ol"</font><font color=Black>,</font><font color=Black>"od"</font><font color="#b2590f">]</font></pre>
<h3 id="сахар-для-монад-do-нотация"><a href="#сахар-для-монад-do-нотация">Сахар для монад, do-нотация</a></h3>
<p>Монады используются столь часто, что для них придумали специальный синтаксис, который облегчает подстановку специальных значений в функции нескольких переменных. Монады позволяют комбинировать специальные функции вида</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> m b</pre>
<p>Если бы эти функции выглядели как обычные функции:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> b</pre>
<p>их можно было бы свободно комбинировать с другими функциями. А так нам постоянно приходится пользоваться методами класса <code><font color=Green>Monad</font></code>. Очень часто функции с побочными эффектами имеют вид:</p>
<pre><font color=Black>a1</font> <font color="#b2590f">-&gt;</font> a2 <font color="#b2590f">-&gt;</font> a3 <font color="#b2590f">-&gt;</font> <font color=Black>...</font> <font color="#b2590f">-&gt;</font> an <font color="#b2590f">-&gt;</font> m b</pre>
<p>А теперь представьте, что вам нужно подставить специальное значение третьим аргументом такой функции и затем передать ещё в одну такую же функцию. Для облегчения участи программистов было придумано специальное окружение  <code><font color="#b2590f">do</font></code>, в котором специальные функции комбинируются так, словно они являются обычными. Для этого используется обратная стрелка. Посмотрим, как определяется функция <code><font color=Black>sequence</font></code> в окружении <code><font color="#b2590f">do</font></code>:</p>
<pre><font color=Black>sequence</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>m a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> m <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>sequence</font> <font color=Green>[]</font>         <font color="#b2590f">=</font> return <font color=Green>[]</font>
<font color=Black>sequence</font> <font color=Black>(</font>mx<font color="#b2590f">:</font>mxs<font color=Black>)</font>   <font color="#b2590f">=</font> <font color="#b2590f">do</font>
    x  <font color="#b2590f">&lt;-</font> mx
    xs <font color="#b2590f">&lt;-</font> sequence mxs
    return <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font></pre>
<p>Во втором уравнении сначала мы говорим вычислителю словом <code><font color="#b2590f">do</font></code> о том, что выражения записаны в мире монады <code><font color=Black>m</font></code>. Запись с перевёрнутой стрелкой <code><font color=Black>x</font> <font color="#b2590f">&lt;-</font> mx</code> означает, что мы далее в <code><font color="#b2590f">do</font></code>-блоке можем пользоваться значением <code><font color=Black>x</font></code> так, словно оно имеет тип просто <code><font color=Black>a</font></code>, но не <code><font color=Black>m</font> a</code>. Смотрите, в этом определении мы сначала извлекаем первый элемент списка, затем извлекаем хвост списка, приведённый к типу <code><font color=Black>m</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></code>, и в самом конце мы соединяем голову и хвост и оборачиваем результат в специальное значение.</p>
<p>Например, мы можем построить функцию, которая дважды читает строку со стандартного ввода и затем возвращает объединение двух строк:</p>
<pre><font color=Black>getLine2</font> <font color="#b2590f">::</font> <font color=Green>IO</font> <font color=Green>String</font>
<font color=Black>getLine2</font> <font color="#b2590f">=</font> <font color="#b2590f">do</font>
    a <font color="#b2590f">&lt;-</font> getLine
    b <font color="#b2590f">&lt;-</font> getLine
    return <font color=Black>(</font>a <font color=Black>++</font> b<font color=Black>)</font></pre>
<p>В <code><font color="#b2590f">do</font></code>-нотации можно вводить локальные переменные с помощью слова :</p>
<pre><font color=Black>t</font> <font color="#b2590f">=</font> <font color="#b2590f">do</font>
    b <font color="#b2590f">&lt;-</font> f a
    c <font color="#b2590f">&lt;-</font> g b
    <font color="#b2590f">let</font> x <font color="#b2590f">=</font> c <font color=Black>+</font> b
        y <font color="#b2590f">=</font> x <font color=Black>+</font> c
    return y</pre>
<p>Посмотрим, как <code><font color="#b2590f">do</font></code>-нотация переводится в выражение, составленное с помощью методов класса <code><font color=Green>Monad</font></code>:</p>
<pre><font color="#b2590f">do</font>
    a <font color="#b2590f">&lt;-</font> ma     <font color="#b2590f">=&gt;</font>   ma <font color=Black>&gt;&gt;=</font> <font color=Black>(</font><font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> exp<font color=Black>)</font>
    exp
<font color="#b2590f">do</font>
    exp1        <font color="#b2590f">=&gt;</font>   exp1 <font color=Black>&gt;&gt;</font> exp2
    exp2    
<font color="#b2590f">do</font>
    <font color="#b2590f">let</font> x <font color="#b2590f">=</font> fx  <font color="#b2590f">=&gt;</font>   <font color="#b2590f">let</font> x <font color="#b2590f">=</font> fx
        y <font color="#b2590f">=</font> fy           y <font color="#b2590f">=</font> fy
    exp              <font color="#b2590f">in</font>  exp</pre>
<p>Переведём с помощью этих правил определение для второго уравнения из функции <code><font color=Black>sequence</font></code></p>
<pre><font color=Black>sequence</font> <font color=Black>(</font>mx<font color="#b2590f">:</font>mxs<font color=Black>)</font> <font color="#b2590f">=</font> <font color="#b2590f">do</font>
    x   <font color="#b2590f">&lt;-</font> mx                  mx <font color=Black>&gt;&gt;=</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> <font color="#b2590f">do</font>  
    xs  <font color="#b2590f">&lt;-</font> sequence mxs   <font color="#b2590f">=&gt;</font>              xs <font color="#b2590f">&lt;-</font> sequence mxs    <font color="#b2590f">=&gt;</font>    
    return <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font>                         return <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font><font color=Black>)</font>

<font color="#b2590f">=&gt;</font>     mx <font color=Black>&gt;&gt;=</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> sequence mxs <font color=Black>&gt;&gt;=</font> <font color=Black>(</font><font color="#b2590f">\</font>xs <font color="#b2590f">-&gt;</font> return <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font><font color=Black>)</font><font color=Black>)</font></pre>
<h4 id="do-или-applicative"><a href="#do-или-applicative">do или Applicative?</a></h4>
<p>С появлением класса <code><font color=Green>Applicative</font></code> во многих случаях <code><font color="#b2590f">do</font></code>-нотация теряет свою ценность. Так, например, любой <code><font color="#b2590f">do</font></code>-блок вида:</p>
<pre><font color=Black>f</font> mx my <font color="#b2590f">=</font> <font color="#b2590f">do</font>
    x <font color="#b2590f">&lt;-</font> mx 
    y <font color="#b2590f">&lt;-</font> my
    return <font color=Black>(</font>op x y<font color=Black>)</font></pre>
<p>можно записать гораздо короче:</p>
<pre><font color=Black>f</font> <font color="#b2590f">=</font> liftA2 op </pre>
<p>Например, напишем функцию, которая объединяет два файла в один:</p>
<pre><font color=Black>appendFiles</font> <font color="#b2590f">::</font> <font color=Green>FilePath</font> <font color="#b2590f">-&gt;</font> <font color=Green>FilePath</font> <font color="#b2590f">-&gt;</font> <font color=Green>FilePath</font> <font color="#b2590f">-&gt;</font> <font color=Green>IO</font> <font color=Green>()</font></pre>
<p>С помощью <code><font color="#b2590f">do</font></code>-нотации:</p>
<pre><font color=Black>appendFiles</font> file1 file2 resFile <font color="#b2590f">=</font> <font color="#b2590f">do</font>
	a <font color="#b2590f">&lt;-</font> readFile file1
	b <font color="#b2590f">&lt;-</font> readFile file2
	writeFile resFile <font color=Black>(</font>a <font color=Black>++</font> b<font color=Black>)</font>	</pre>
<p>А теперь с помощью класса <code><font color=Green>Applicative</font></code>:</p>
<pre><font color=Black>appendFiles</font> file1 file2 resFile <font color="#b2590f">=</font> writeFile resFile <font color=Black>=&lt;&lt;</font> 
	liftA2 <font color=Black>(</font><font color=Black>++</font><font color=Black>)</font> <font color=Black>(</font>readFile file1<font color=Black>)</font> <font color=Black>(</font>readFile file2<font color=Black>)</font></pre>
<h2 id="расширения"><a href="#расширения">Расширения</a></h2>
<p>Расширение появляется в ответ на проблему, с которой трудно или невозможно справиться в рамках стандарта Haskell. Мы рассмотрим несколько наиболее часто используемых расширений. Расширения подключаются с помощью специального комментария. Он помещается в начале модуля. Расширение действует только в текущем модуле.</p>
<pre><font color="#2149c1">{-# LANGUAGE  ExtentionName1, ExtentionName2, ExtentionName3 #-}</font></pre>
<p>Обратите внимание на символ решётки, обрамляющего комментарии. Слово <code><font color=Green>LANGUAGE</font></code> говорит компилятору о том, что мы хотим воспользоваться расширениями с именами <code><font color=Green>ExtentionName1</font></code>, <code><font color=Green>ExtentionName2</font></code>, <code><font color=Green>ExtentionName3</font></code>. Такой комментарий называется <em>прагмой</em> (pragma). Часто компилятор ghc в случае ошибки предлагает нам подключить расширение, в котором ошибка уже не будет ошибкой, а возможностью языка. Он говорит: возможно, вы имели в виду расширение <code><font color=Green>XXX</font></code>. Например, попробуйте загрузить в интерпретатор модуль:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Test</font> <font color="#b2590f">where</font>

<font color="#b2590f">class</font> <font color=Green>Multi</font> a b <font color="#b2590f">where</font></pre>
<p>В этом случае мы увидим ошибку:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Test</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Test</font>             <font color=Black>(</font> <font color=Green>Test</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>

<font color=Green>Test</font><font color=Black>.</font>hs<font color="#b2590f">:</font><font color="#0000ee">3</font><font color="#b2590f">:</font><font color="#0000ee">0</font><font color="#b2590f">:</font>
    <font color=Green>Too</font> many parameters for <font color="#b2590f">class</font> <font color=Black>`</font><font color=Green>Multi'</font>
    <font color=Black>(</font><font color=Green>Use</font> <font color="#2149c1">-</font><font color=Green>XMultiParamTypeClasses</font> to allow multi<font color="#2149c1">-</font>parameter classes<font color=Black>)</font>
    <font color=Green>In</font> the <font color="#b2590f">class</font> declaration for <font color=Black>`</font><font color=Green>Multi'</font>
<font color=Green>Failed</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> none<font color=Black>.</font></pre>
<p>Компилятор сообщает нам о том, что у нас слишком много параметров в классе <code><font color=Green>Multi</font></code>. В рамках стандарта Haskell можно создавать лишь классы с одним параметром. Но за сообщением мы видим подсказку: если мы воспользуемся расширением <code><font color="#2149c1">-</font><font color=Green>XMultiParamTypeClasses</font></code>, то всё будет хорошо. В этом сообщении имя расширения закодировано в виде флага. Мы можем запустить ghc или ghci с этим флагом и тогда расширение будет активировано, и модуль загрузится. Попробуем:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>q
<font color=Green>Leaving</font> <font color=Green>GHCi</font><font color=Black>.</font>
<font color=Black>$</font> ghci <font color="#2149c1">-</font><font color=Green>XMultiParamTypeClasses</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Test</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Test</font>             <font color=Black>(</font> <font color=Green>Test</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Test</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Test</font><font color=Black>&gt;</font> </pre>
<p>Модуль загрузился! У нас есть и другая возможность подключить модуль с помощью прагмы <code><font color=Green>LANGUAGE</font></code>. Имя расширения записано во флаге после символов <code><font color="#2149c1">-</font><font color=Green>X</font></code>. Добавим в модуль <code><font color=Green>Test</font></code> расширение с именем <code><font color=Green>MultiParamTypeClasses</font></code>:</p>
<pre><font color="#2149c1">{-# LANGUAGE MultiParamTypeClasses #-}</font>
<font color="#b2590f">module</font> <font color=Green>Test</font> <font color="#b2590f">where</font>

<font color="#b2590f">class</font> <font color=Green>Multi</font> a b <font color="#b2590f">where</font></pre>
<p>Теперь загрузим ghci в обычном режиме:</p>
<pre><font color=Black>*</font><font color=Green>Test</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>q
<font color=Green>Leaving</font> <font color=Green>GHCi</font><font color=Black>.</font>
<font color=Black>$</font> ghci
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Test</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Test</font>             <font color=Black>(</font> <font color=Green>Test</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Test</font><font color=Black>.</font></pre>
<h3 id="обобщённые-алгебраические-типы-данных"><a href="#обобщённые-алгебраические-типы-данных">Обобщённые алгебраические типы данных</a></h3>
<p>Предположим, что мы хотим написать компилятор небольшого языка. Наш язык содержит числа и логические значения. Мы можем складывать числа и умножать. Для логических значений определена конструкция <code><font color="#b2590f">if</font><font color="#2149c1">-</font><font color="#b2590f">then</font><font color="#2149c1">-</font><font color="#b2590f">else</font></code>. Определим тип синтаксического дерева для этого языка:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Exp</font> <font color="#b2590f">=</font> <font color=Green>ValTrue</font>
         <font color="#b2590f">|</font> <font color=Green>ValFalse</font>
         <font color="#b2590f">|</font> <font color=Green>If</font> <font color=Green>Exp</font> <font color=Green>Exp</font> <font color=Green>Exp</font>
         <font color="#b2590f">|</font> <font color=Green>Val</font> <font color=Green>Int</font>
         <font color="#b2590f">|</font> <font color=Green>Add</font> <font color=Green>Exp</font> <font color=Green>Exp</font>
         <font color="#b2590f">|</font> <font color=Green>Mul</font> <font color=Green>Exp</font> <font color=Green>Exp</font>
         <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>)</font></pre>
<p>В этом определении кроется одна проблема. Наш тип позволяет нам строить бессмысленные выражения вроде <code><font color=Green>Add</font> <font color=Green>ValTrue</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">2</font><font color=Black>)</font></code> или <code><font color=Green>If</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Green>ValTrue</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">22</font><font color=Black>)</font></code>. Наш тип <code><font color=Green>Exp</font></code> включает в себя все хорошие выражения и много плохих. Эта проблема проявится особенно ярко, если мы попытаемся определить функцию <code><font color=Black>eval</font></code>, которая вычисляет значения для нашего языка. Получается, что тип этой функции:</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Either</font> <font color=Green>Int</font> <font color=Green>Bool</font></pre>
<p> Для решения этой проблемы были придуманы <em>обобщённые алгебраические типы данных</em> (generalised algebraic data types, GADTs). Они подключаются расширением <code><font color=Green>GADTs</font></code>. Помните, когда-то мы говорили, что типы можно представить в виде классов. Например, определение для списка</p>
<pre><font color="#b2590f">data</font> <font color=Green>List</font> a <font color="#b2590f">=</font> <font color=Green>Nil</font> <font color="#b2590f">|</font> <font color=Green>Cons</font> a <font color=Black>(</font><font color=Green>List</font> a<font color=Black>)</font></pre>
<p>можно мысленно переписать так:</p>
<pre><font color="#b2590f">data</font> <font color=Green>List</font> a <font color="#b2590f">where</font>
    <font color=Green>Nil</font>  <font color="#b2590f">::</font> <font color=Green>List</font> a
    <font color=Green>Cons</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>List</font> a <font color="#b2590f">-&gt;</font> <font color=Green>List</font> a</pre>
<p>Так вот в GADT определения записываются именно в таком виде. Обобщение заключается в том, что теперь на месте произвольного параметра <code><font color=Black>a</font></code> мы можем писать конкретные типы. Определим тип <code><font color=Green>Exp</font></code></p>
<pre><font color="#2149c1">{-# LANGUAGE GADTs #-}</font>

<font color="#b2590f">data</font> <font color=Green>Exp</font> a <font color="#b2590f">where</font>
    <font color=Green>ValTrue</font>     <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color=Green>Bool</font>
    <font color=Green>ValFalse</font>    <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color=Green>Bool</font>
    <font color=Green>If</font>          <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> a
    <font color=Green>Val</font>         <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> <font color=Green>Int</font>
    <font color=Green>Add</font>         <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> <font color=Green>Int</font>
    <font color=Green>Mul</font>         <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> <font color=Green>Int</font></pre>
<p>Теперь у нашего типа <code><font color=Green>Exp</font></code> появился параметр, через который мы кодируем дополнительные ограничения на типы операций. Теперь мы не сможем составить выражение <code><font color=Green>Add</font> <font color=Green>ValTrue</font> <font color=Green>ValFalse</font></code>, потому что оно не пройдёт проверку типов.</p>
<p>Определим функцию <code><font color=Black>eval</font></code>:</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>eval</font> x <font color="#b2590f">=</font> <font color="#b2590f">case</font> x <font color="#b2590f">of</font>
    <font color=Green>ValTrue</font>     <font color="#b2590f">-&gt;</font> <font color=Green>True</font>
    <font color=Green>ValFalse</font>    <font color="#b2590f">-&gt;</font> <font color=Green>False</font>
    <font color=Green>If</font> p t e    <font color="#b2590f">-&gt;</font> <font color="#b2590f">if</font> eval p <font color="#b2590f">then</font> eval t <font color="#b2590f">else</font> eval e
    <font color=Green>Val</font> n       <font color="#b2590f">-&gt;</font> n
    <font color=Green>Add</font> a b     <font color="#b2590f">-&gt;</font> eval a <font color=Black>+</font> eval b
    <font color=Green>Mul</font> a b     <font color="#b2590f">-&gt;</font> eval a <font color=Black>*</font> eval b</pre>
<p>Если <code><font color=Black>eval</font></code> получит логическое значение, то будет возвращено значение типа <code><font color=Green>Bool</font></code>, а на значение типа <code><font color=Green>Exp</font> <font color=Green>Int</font></code> будет возвращено целое число. Давайте убедимся в этом:</p>
<pre><font color=Black>*</font><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Exp</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Exp</font>              <font color=Black>(</font> <font color=Green>Exp</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Exp</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> notE x <font color="#b2590f">=</font> <font color=Green>If</font> x <font color=Green>ValFalse</font> <font color=Green>ValTrue</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> squareE x <font color="#b2590f">=</font> <font color=Green>Mul</font> x x
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> 
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> eval <font color=Black>$</font> squareE <font color=Black>$</font> <font color=Green>If</font> <font color=Black>(</font>notE <font color=Green>ValTrue</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color="#0000ee">4</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> eval <font color=Black>$</font> notE <font color=Green>ValTrue</font>
<font color=Green>False</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> eval <font color=Black>$</font> notE <font color=Black>$</font> <font color=Green>Add</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">2</font><font color=Black>)</font>

<font color=Black>&lt;</font>interactive<font color=Black>&gt;:</font><font color="#0000ee">1</font><font color="#b2590f">:</font><font color="#0000ee">14</font><font color="#b2590f">:</font>
    <font color=Green>Couldn't</font> match expected <font color="#b2590f">type</font> <font color=Black>`</font><font color=Green>Bool'</font> against inferred <font color="#b2590f">type</font> <font color=Black>`</font><font color=Green>Int'</font>
    <font color=Green>Expected</font> <font color="#b2590f">type</font><font color="#b2590f">:</font> <font color=Green>Exp</font> <font color=Green>Bool</font>
      <font color=Green>Actual</font> <font color="#b2590f">type</font><font color="#b2590f">:</font> <font color=Green>Exp</font> <font color=Green>Int</font>
    <font color=Green>In</font> the return <font color="#b2590f">type</font> <font color="#b2590f">of</font> a call <font color="#b2590f">of</font> <font color=Black>`</font><font color=Green>Add'</font>
    <font color=Green>In</font> the second argument <font color="#b2590f">of</font> <font color=Black>`</font><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font><font color=Black>'</font><font color=Black>,</font> namely <font color=Black>`</font><font color=Green>Add</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Val</font> <font color="#0000ee">2</font><font color=Black>)</font><font color=Black>'</font></pre>
<p>Сначала мы определили две вспомогательные функции. Затем вычислили несколько значений. Haskell очень часто применяется для построения компиляторов. Мы рассмотрели очень простой язык, но в более сложном случае суть останется прежней. Дополнительный параметр позволяет нам закодировать в параметре тип функций нашего языка. Спрашивается: зачем нам дублировать вычисления в функции <code><font color=Black>eval</font></code>? Зачем нам сначала кодировать выражение конструкторами, чтобы только потом получить то, что мы могли вычислить и напрямую.</p>
<p>При таком подходе у нас есть полный контроль за деревом выражения: мы можем проводить дополнительную оптимизацию выражений, если нам известны некоторые закономерности. Ещё функция <code><font color=Black>eval</font></code> может вычислять совсем другие значения. Например, она может по виду выражения составлять код на другом языке. Возможно, этот язык гораздо мощнее Haskell по вычислительным способностям, но беднее в плане выразительности, гибкости синтаксиса. Тогда мы будем в функции <code><font color=Black>eval</font></code> проецировать разные конструкции Haskell в конструкции другого языка. Такие программы называются <em>предметно-ориентированными языками программирования</em> (domain specific languages). Мы кодируем в типе <code><font color=Green>Exp</font></code> некоторую область и затем надстраиваем над типом <code><font color=Green>Exp</font></code> разные полезные функции. На самом последнем этапе функция <code><font color=Black>eval</font></code> переводит всё дерево выражения в значение или код другого языка.</p>
<p>Отметим, что не так давно было предложено другое решение этой задачи. Мы можем закодировать типы функций в классе:</p>
<pre><font color="#b2590f">class</font> <font color=Green>E</font> exp <font color="#b2590f">where</font>
    true    <font color="#b2590f">::</font> exp <font color=Green>Bool</font>
    false   <font color="#b2590f">::</font> exp <font color=Green>Bool</font>
    iff     <font color="#b2590f">::</font> exp <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> exp a <font color="#b2590f">-&gt;</font> exp a <font color="#b2590f">-&gt;</font> exp a
    val     <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font>
    add     <font color="#b2590f">::</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font>
    mul     <font color="#b2590f">::</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font>    </pre>
<p>Преимуществом такого подхода является модульность. Мы можем спокойно разделить выражение на две составляющие части:</p>
<pre><font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Log</font> exp<font color=Black>,</font> <font color=Green>Arith</font> exp<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>E</font> exp

<font color="#b2590f">class</font> <font color=Green>Log</font> exp <font color="#b2590f">where</font>
    true    <font color="#b2590f">::</font> exp <font color=Green>Bool</font>
    false   <font color="#b2590f">::</font> exp <font color=Green>Bool</font>
    iff     <font color="#b2590f">::</font> exp <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> exp a <font color="#b2590f">-&gt;</font> exp a <font color="#b2590f">-&gt;</font> exp a

<font color="#b2590f">class</font> <font color=Green>Arith</font> exp <font color="#b2590f">where</font>
    val     <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font>
    add     <font color="#b2590f">::</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font>
    mul     <font color="#b2590f">::</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font></pre>
<p>Интерпретация дерева выражения в этом подходе заключается в создании экземпляра класса. Например, создадим класс-вычислитель <code><font color=Green>Eval</font></code>:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Eval</font> a <font color="#b2590f">=</font> <font color=Green>Eval</font> <font color=Black>{</font> runEval <font color="#b2590f">::</font> a <font color=Black>}</font>

<font color="#b2590f">instance</font> <font color=Green>Log</font> <font color=Green>Eval</font> <font color="#b2590f">where</font>
    true    <font color="#b2590f">=</font> <font color=Green>Eval</font> <font color=Green>True</font>
    false   <font color="#b2590f">=</font> <font color=Green>Eval</font> <font color=Green>False</font>
    iff p t e <font color="#b2590f">=</font> <font color="#b2590f">if</font> runEval p <font color="#b2590f">then</font> t <font color="#b2590f">else</font> e

<font color="#b2590f">instance</font> <font color=Green>Arith</font> <font color=Green>Eval</font> <font color="#b2590f">where</font>
    val     <font color="#b2590f">=</font> <font color=Green>Eval</font>
    add a b <font color="#b2590f">=</font> <font color=Green>Eval</font> <font color=Black>$</font> runEval a <font color=Black>+</font> runEval b
    mul a b <font color="#b2590f">=</font> <font color=Green>Eval</font> <font color=Black>$</font> runEval a <font color=Black>*</font> runEval b

<font color="#b2590f">instance</font> <font color=Green>E</font> <font color=Green>Eval</font></pre>
<p>Теперь проведём такую же сессию вычисления значений, но давайте теперь сначала определим их в тексте программы:</p>
<pre><font color=Black>notE</font> <font color="#b2590f">::</font> <font color=Green>Log</font> exp <font color="#b2590f">=&gt;</font> exp <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Bool</font>
<font color=Black>notE</font> x <font color="#b2590f">=</font> iff x  false true

<font color=Black>squareE</font> <font color="#b2590f">::</font> <font color=Green>Arith</font> exp <font color="#b2590f">=&gt;</font> exp <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> exp <font color=Green>Int</font>
<font color=Black>squareE</font> x <font color="#b2590f">=</font> mul x x

<font color=Black>e1</font> <font color="#b2590f">::</font> <font color=Green>E</font> exp <font color="#b2590f">=&gt;</font> exp <font color=Green>Int</font>
<font color=Black>e1</font> <font color="#b2590f">=</font> squareE <font color=Black>$</font> iff <font color=Black>(</font>notE true<font color=Black>)</font> <font color=Black>(</font>val <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>(</font>val <font color="#0000ee">2</font><font color=Black>)</font>

<font color=Black>e2</font> <font color="#b2590f">::</font> <font color=Green>E</font> exp <font color="#b2590f">=&gt;</font> exp <font color=Green>Bool</font>
<font color=Black>e2</font> <font color="#b2590f">=</font> notE true</pre>
<p>Загрузим в интерпретатор:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>r
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Exp</font>              <font color=Black>(</font> <font color=Green>Exp</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Exp</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> runEval e1
<font color="#0000ee">4</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> runEval e2
<font color=Green>False</font></pre>
<p>Получились такие же результаты, и в этом случае нам не нужно подключать никаких расширений. Теперь создадим тип-принтер, он будет распечатывать выражение:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Print</font> a <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>{</font> runPrint <font color="#b2590f">::</font> <font color=Green>String</font> <font color=Black>}</font>

<font color="#b2590f">instance</font> <font color=Green>Log</font> <font color=Green>Print</font> <font color="#b2590f">where</font>
    true    <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>"True"</font> 
    false   <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>"False"</font>
    iff p t e <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>$</font> <font color=Black>"if ("</font> <font color=Black>++</font> runPrint p <font color=Black>++</font> <font color=Black>") {"</font> 
            <font color=Black>++</font> runPrint t <font color=Black>++</font> <font color=Black>"}"</font>
            <font color=Black>++</font> <font color=Black>"{"</font> <font color=Black>++</font> runPrint e <font color=Black>++</font> <font color=Black>"}"</font>

<font color="#b2590f">instance</font> <font color=Green>Arith</font> <font color=Green>Print</font> <font color="#b2590f">where</font>
    val n   <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>$</font> show n
    add a b <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>$</font> <font color=Black>"("</font> <font color=Black>++</font> runPrint a <font color=Black>++</font> <font color=Black>")+("</font> <font color=Black>++</font> runPrint b <font color=Black>++</font> <font color=Black>")"</font>
    mul a b <font color="#b2590f">=</font> <font color=Green>Print</font> <font color=Black>$</font> <font color=Black>"("</font> <font color=Black>++</font> runPrint a <font color=Black>++</font> <font color=Black>")*("</font> <font color=Black>++</font> runPrint b <font color=Black>++</font> <font color=Black>")"</font>
    
<font color="#b2590f">instance</font> <font color=Green>E</font> <font color=Green>Print</font>    </pre>
<p>Теперь распечатаем предыдущие выражения:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>r
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Exp</font>              <font color=Black>(</font> <font color=Green>Exp</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Exp</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> runPrint e1
<font color=Black>"(if (if (True) {False}{True}) {1}{2})*(if (if (True) {False}{True}) {1}{2})"</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> runPrint e2
<font color=Black>"if (True) {False}{True}"</font></pre>
<p>При таком подходе нам не пришлось ничего менять в выражениях: мы просто заменили тип выражения, и оно автоматически подстроилось под нужный результат. Подробнее об этом подходе можно почитать на сайте <a href="http://okmij.org/ftp/tagless-final/course/course.html">http://okmij.org/ftp/tagless-final/course/course.html</a> или в статье Жака Каре (Jacques Carette), Олега Киселёва (Oleg Kiselyov) и Чунг-Че Шена (Chung-chieh Shan) <em>Finally Tagless, Partially Evaluated</em>.</p>
<h3 id="семейства-типов"><a href="#семейства-типов">Семейства типов</a></h3>
<p>  Семейства типов позволяют выражать зависимости типов. Например, представим, что класс определяет не только методы, но и типы. Причём новые типы зависят от конкретного экземпляра класса. Посмотрим, например, на определение линейного пространства из библиотеки <code><font color=Black>vector</font><font color="#2149c1">-</font>space</code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>AdditiveGroup</font> v <font color="#b2590f">where</font>
    zeroV   <font color="#b2590f">::</font> v
    <font color=Black>(</font><font color=Black>^+^</font><font color=Black>)</font>   <font color="#b2590f">::</font> v <font color="#b2590f">-&gt;</font> v <font color="#b2590f">-&gt;</font> v
    negateV <font color="#b2590f">::</font> v <font color="#b2590f">-&gt;</font> v

<font color="#b2590f">class</font> <font color=Green>AdditiveGroup</font> v <font color="#b2590f">=&gt;</font> <font color=Green>VectorSpace</font> v <font color="#b2590f">where</font>
    <font color="#b2590f">type</font> <font color=Green>Scalar</font> v   <font color="#b2590f">::</font> <font color=Black>*</font>
    <font color=Black>(</font><font color=Black>*^</font><font color=Black>)</font>            <font color="#b2590f">::</font> <font color=Green>Scalar</font> v <font color="#b2590f">-&gt;</font> v <font color="#b2590f">-&gt;</font> v</pre>
<p>Линейное пространство – это математическая структура, объектами которой являются вектора и скаляры. Для векторов определена операция сложения, а для скаляров – операции сложения и умножения. Кроме того, определена операция умножения вектора на скаляр. При этом должны выполнятся определённые свойства. Мы не будем подробно на них останавливаться, но вкратце заметим, что эти свойства говорят о том, что мы действительно пользуемся операциями сложения и умножения. В классе <code><font color=Green>VectorSpace</font></code> мы видим новую конструкцию – объявление типа. Мы говорим, что есть производный тип, который следует из <code><font color=Black>v</font></code>. Далее через двойное двоеточие мы указываем его вид. В данном случае это простой тип без параметров.</p>
<p>Вид  (kind) – это тип типа. Простой тип без параметра обозначается звёздочкой. Тип с параметром обозначается как функция <code><font color=Black>*</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font></code>. Если бы тип принимал два параметра, то он обозначался бы <code><font color=Black>*</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font></code>. Также параметры могут быть не простыми типами, а типами с параметрами, например, тип, который обозначает композицию типов:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>O</font> f g a <font color="#b2590f">=</font> <font color=Green>O</font> <font color=Black>{</font> unO <font color="#b2590f">::</font> f <font color=Black>(</font>g a<font color=Black>)</font> <font color=Black>}</font></pre>
<p>имеет вид <code><font color=Black>(</font><font color=Black>*</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Black>*</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font> <font color="#b2590f">-&gt;</font> <font color=Black>*</font></code>.</p>
<p>Определим класс векторов на двумерной сетке и сделаем его экземпляром класса <code><font color=Green>VectorSpace</font></code>. Для начала создадим новый модуль с активным расширением <code><font color=Green>TypeFamilies</font></code> и запишем в него классы для линейного пространства</p>
<pre><font color="#2149c1">{-# Language TypeFamilies #-}</font>
<font color="#b2590f">module</font> <font color=Green>Point2D</font> <font color="#b2590f">where</font>

<font color="#b2590f">class</font> <font color=Green>AdditiveGroup</font> v <font color="#b2590f">where</font>
<font color=Black>...</font></pre>
<p>Теперь определим новый тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>V2</font> <font color="#b2590f">=</font> <font color=Green>V2</font> <font color=Green>Int</font> <font color=Green>Int</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font></pre>
<p>Сделаем его экземпляром класса <code><font color=Green>AdditiveGroup</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>AdditiveGroup</font> <font color=Green>V2</font> <font color="#b2590f">where</font>
    zeroV       <font color="#b2590f">=</font> <font color=Green>V2</font> <font color="#0000ee">0</font> <font color="#0000ee">0</font>
    <font color=Black>(</font><font color=Green>V2</font> x y<font color=Black>)</font>  <font color=Black>^+^</font> <font color=Black>(</font><font color=Green>V2</font> x' y'<font color=Black>)</font>  <font color="#b2590f">=</font> <font color=Green>V2</font> <font color=Black>(</font>x<font color=Black>+</font>x'<font color=Black>)</font> <font color=Black>(</font>y<font color=Black>+</font>y'<font color=Black>)</font>
    negateV <font color=Black>(</font><font color=Green>V2</font> x y<font color=Black>)</font>   <font color="#b2590f">=</font> <font color=Green>V2</font> <font color=Black>(</font><font color="#2149c1">-</font>x<font color=Black>)</font> <font color=Black>(</font><font color="#2149c1">-</font>y<font color=Black>)</font></pre>
<p>Мы складываем и вычитаем значения в каждом из элементов кортежа. Нейтральным элементом относительно сложения будет кортеж, состоящий из двух нулей. Теперь определим экземпляр для класса <code><font color=Green>VectorSpace</font></code>. Поскольку кортеж состоит из двух целых чисел, скаляр также будет целым числом:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>VectorSpace</font> <font color=Green>V2</font> <font color="#b2590f">where</font>
    <font color="#b2590f">type</font> <font color=Green>Scalar</font> <font color=Green>V2</font> <font color="#b2590f">=</font> <font color=Green>Int</font>
    s <font color=Black>*^</font> <font color=Black>(</font><font color=Green>V2</font> x y<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>V2</font> <font color=Black>(</font>s<font color=Black>*</font>x<font color=Black>)</font> <font color=Black>(</font>s<font color=Black>*</font>y<font color=Black>)</font></pre>
<p>Попробуем вычислить что-нибудь в интерпретаторе:</p>
<pre><font color=Black>*</font><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Point2D</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Point2D</font>          <font color=Black>(</font> <font color=Green>Point2D</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Point2D</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Point2D</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> v <font color="#b2590f">=</font>  <font color=Green>V2</font> <font color="#0000ee">1</font> <font color="#0000ee">2</font>
<font color=Black>*</font><font color=Green>Point2D</font><font color=Black>&gt;</font> v <font color=Black>^+^</font> v
<font color=Green>V2</font> <font color="#0000ee">2</font> <font color="#0000ee">4</font>
<font color=Black>*</font><font color=Green>Point2D</font><font color=Black>&gt;</font> <font color="#0000ee">3</font> <font color=Black>*^</font> v <font color=Black>^+^</font> v
<font color=Green>V2</font> <font color="#0000ee">4</font> <font color="#0000ee">8</font>
<font color=Black>*</font><font color=Green>Point2D</font><font color=Black>&gt;</font> negateV <font color=Black>$</font> <font color="#0000ee">3</font> <font color=Black>*^</font> v <font color=Black>^+^</font> v
<font color=Green>V2</font> <font color=Black>(</font><font color="#2149c1">-</font><font color="#0000ee">4</font><font color=Black>)</font> <font color=Black>(</font><font color="#2149c1">-</font><font color="#0000ee">8</font><font color=Black>)</font></pre>
<p>Семейства типов дают возможность организовывать вычисления на типах. Посмотрим на такой классический пример. Реализуем в типах числа Пеано. Нам понадобятся два типа: один для обозначения нуля, а другой для обозначения следующего элемента:</p>
<pre><font color="#2149c1">{-# Language TypeFamilies, EmptyDataDecls #-}</font>
<font color="#b2590f">module</font> <font color=Green>Nat</font> <font color="#b2590f">where</font>

<font color="#b2590f">data</font> <font color=Green>Zero</font>
<font color="#b2590f">data</font> <font color=Green>Succ</font> a</pre>
<p>Значения этих типов нам не понадобятся, поэтому мы воспользуемся расширением <code><font color=Green>EmptyDataDecls</font></code>, которое позволяет определять типы без значений. Значениями будут комбинации типов. Мы определим операции сложения и умножения для чисел. Для начала определим сложение:</p>
<pre><font color="#b2590f">type</font> family <font color=Green>Add</font> a b <font color="#b2590f">::</font> <font color=Black>*</font>

<font color="#b2590f">type</font> <font color="#b2590f">instance</font> <font color=Green>Add</font> a <font color=Green>Zero</font>        <font color="#b2590f">=</font> a
<font color="#b2590f">type</font> <font color="#b2590f">instance</font> <font color=Green>Add</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font>    <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Add</font> a b<font color=Black>)</font></pre>
<p>Первой строчкой мы определили семейство типов <code><font color=Green>Add</font></code>, у которого два параметра. Определение семейства типов начинается с ключевой фразы  <code><font color="#b2590f">type</font> family</code>. За двоеточием мы указали тип семейства. В данном случае это простой тип без параметра. Далее следуют зависимости типов для семейства <code><font color=Green>Add</font></code>. Зависимости типов начинаются с ключевой фразы  <code><font color="#b2590f">type</font> <font color="#b2590f">instance</font></code>. В аргументах мы словно пользуемся сопоставлением с образцом, но на этот раз на типах. Первое уравнение</p>
<pre><font color="#b2590f">type</font> <font color="#b2590f">instance</font> <font color=Green>Add</font> a <font color=Green>Zero</font>        <font color="#b2590f">=</font> a</pre>
<p>говорит о том, что если второй аргумент имеет тип ноль, то мы вернём первый аргумент. Совсем как в обычном функциональном определении сложения для натуральных чисел Пеано. Во втором уравнении мы составляем рекурсивное уравнение:</p>
<pre><font color="#b2590f">type</font> <font color="#b2590f">instance</font> <font color=Green>Add</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font>    <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Add</font> a b<font color=Black>)</font></pre>
<p>Точно также мы можем определить и умножение:</p>
<pre><font color="#b2590f">type</font> family <font color=Green>Mul</font> a b <font color="#b2590f">::</font> <font color=Black>*</font>

<font color="#b2590f">type</font> <font color="#b2590f">instance</font> <font color=Green>Mul</font> a <font color=Green>Zero</font>        <font color="#b2590f">=</font> <font color=Green>Zero</font>
<font color="#b2590f">type</font> <font color="#b2590f">instance</font> <font color=Green>Mul</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font>    <font color="#b2590f">=</font> <font color=Green>Add</font> a <font color=Black>(</font><font color=Green>Mul</font> a b<font color=Black>)</font></pre>
<p>При этом нам придётся подключить ещё одно расширение <code><font color=Green>UndecidableInstances</font></code>, поскольку во втором уравнении мы подставили одно семейство типов в другое. Этот флаг часто используется в сочетании с расширением <code><font color=Green>TypeFamilies</font></code>. Семейства типов фактически позволяют нам определять функции на типах. Это ведёт к тому, что алгоритм вывода типов становится неопределённым. Если типы правильные, то компилятор сможет это установить, но если они окажутся неправильными, то может возникнуть такая ситуация, что компилятор зациклится и будет бесконечно долго искать соответствие одного типа другому. Теперь проверим результаты. Для этого мы создадим специальный класс, который будет переводить значения-типы в обычные целочисленные значения:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Nat</font> a <font color="#b2590f">where</font>
    toInt <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>

<font color="#b2590f">instance</font> <font color=Green>Nat</font> <font color=Green>Zero</font> <font color="#b2590f">where</font>
    toInt <font color="#b2590f">_</font> <font color="#b2590f">=</font> <font color="#0000ee">0</font>

<font color="#b2590f">instance</font> <font color=Green>Nat</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Nat</font> <font color=Black>(</font><font color=Green>Succ</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    toInt x <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>+</font> toInt <font color=Black>(</font>proxy x<font color=Black>)</font>
        
<font color=Black>proxy</font> <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> a
<font color=Black>proxy</font> <font color="#b2590f">=</font> undefined</pre>
<p>Мы определили для каждого значения-типа экземпляр класса <code><font color=Green>Nat</font></code>, в котором мы можем переводить типы в числа. Функция <code><font color=Black>proxy</font></code> позволяет нам извлечь значение из типа-конструктора <code><font color=Green>Succ</font></code>: так мы поясняем компилятору тип значения. При этом мы нигде не пользуемся значениями типов <code><font color=Green>Zero</font></code> и <code><font color=Green>Succ</font></code>, ведь у этих типов нет значений.</p>
<p>Теперь посмотрим, что у нас получилось:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Nat</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> undefined <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Mul</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> toInt x
<font color="#0000ee">6</font></pre>
<p>Видно, что с помощью класса <code><font color=Green>Nat</font></code> мы можем извлечь значение, закодированное в типе. Зачем нам эти странные типы-значения? Мы можем использовать их в двух случаях. Мы можем кодировать значения в типе или проводить более тонкую проверку типов.</p>
<p>Помните, когда-то мы определяли функции для численного интегрирования. Там точность метода была жёстко задана в тексте программы:</p>
<pre>
<font color=Black>dt</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> a
<font color=Black>dt</font> <font color="#b2590f">=</font> <font color="#0000ee">1e-3</font>

<font color="#2149c1">-- метод Эйлера</font>
<font color=Black>int</font> <font color="#b2590f">::</font> <font color=Green>Fractional</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>int</font> x0 <font color="#b2590f">~</font><font color=Black>(</font>f<font color="#b2590f">:</font>fs<font color=Black>)</font> <font color="#b2590f">=</font> x0 <font color="#b2590f">:</font> int <font color=Black>(</font>x0 <font color=Black>+</font> dt <font color=Black>*</font> f<font color=Black>)</font> fs</pre>
<p>В этом примере мы можем создать специальный тип потоков, у которых шаг дискретизации будет закодирован в типе.</p>
<pre><font color="#b2590f">data</font> <font color=Green>Stream</font> n a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> <font color=Green>Stream</font> n a</pre>
<p>Параметр <code><font color=Black>n</font></code> кодирует точность. Теперь мы можем извлекать точность из типа:</p>
<pre><font color=Black>dt</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Nat</font> n<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Stream</font> n a <font color="#b2590f">-&gt;</font> a
<font color=Black>dt</font> xs <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>/</font> <font color=Black>(</font>fromIntegral <font color=Black>$</font> toInt <font color=Black>$</font> proxy xs<font color=Black>)</font>
    <font color="#b2590f">where</font> proxy <font color="#b2590f">::</font> <font color=Green>Stream</font> n a <font color="#b2590f">-&gt;</font> n
          proxy <font color="#b2590f">=</font> undefined

<font color=Black>int</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Nat</font> n<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> n a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> n a
<font color=Black>int</font> x0 <font color="#b2590f">~</font><font color=Black>(</font>f<font color="#b2590f">:&amp;</font>fs<font color=Black>)</font> <font color="#b2590f">=</font> x0 <font color="#b2590f">:&amp;</font> int <font color=Black>(</font>x0 <font color=Black>+</font> dt fs <font color=Black>*</font> f<font color=Black>)</font> fs</pre>
<p>Теперь посмотрим, как мы можем сделать проверку типов более тщательной. Представим, что у нас есть тип матриц. Известно, что сложение определено только для матриц одинаковой размерности, а для умножения матриц число столбцов одной матрицы должно совпадать с числом строк другой матрицы. Мы можем отразить все эти зависимости в целочисленных типах:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Mat</font> n m a <font color="#b2590f">=</font> <font color=Black>...</font>

<font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>AdditiveGroup</font> <font color=Black>(</font><font color=Green>Mat</font> n m a<font color=Black>)</font> <font color="#b2590f">where</font>
    a <font color=Black>^+^</font> b     <font color="#b2590f">=</font> <font color=Black>...</font>
    zeroV       <font color="#b2590f">=</font> <font color=Black>...</font>
    negateV a   <font color="#b2590f">=</font> <font color=Black>...</font>

<font color=Black>mul</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Mat</font> n m a <font color="#b2590f">-&gt;</font> <font color=Green>Mat</font> m k a <font color="#b2590f">-&gt;</font> <font color=Green>Mat</font> n k a</pre>
<p>При таких определениях мы не сможем сложить матрицы разных размеров. Причём ошибка будет вычислена до выполнения программы. Это освобождает от проверки границ внутри алгоритма умножения матриц. Если алгоритм запустился, то мы знаем, что размеры аргументов соответствуют.</p>
<p>Скоро в ghc появится поддержка чисел на уровне типов. Это будет специальное расширение <code><font color=Green>TypeLevelNats</font></code>, при включении которого можно будет пользоваться численными литералами в типах, также будут определены операции-семейства типов на численных типах с привычными именами <code><font color=Black>+</font></code>, <code><font color=Black>*</font></code>.</p>
<h3 id="классы-с-несколькими-типами"><a href="#классы-с-несколькими-типами">Классы с несколькими типами</a></h3>
<p>Рассмотрим несколько полезных расширений, относящихся к определению классов и экземпляров классов. Расширение <code><font color=Green>MultiParamTypeClasses</font></code> позволяет объявлять классы с несколькими аргументами. Например, взгляните на такой класс:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Iso</font> a b <font color="#b2590f">where</font>
    to      <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> b
    from    <font color="#b2590f">::</font> b <font color="#b2590f">-&gt;</font> a</pre>
<p>Так мы можем определить изоморфизм между типами <code><font color=Black>a</font></code> и <code><font color=Black>b</font></code></p>
<h3 id="экземпляры-классов-для-синонимов"><a href="#экземпляры-классов-для-синонимов">Экземпляры классов для синонимов</a></h3>
<p>Расширение <code><font color=Green>TypeSynonymInstances</font></code> позволяет определять экземпляры для синонимов типов. Мы уже пользовались этим расширением, когда определяли рекурсивные типы через тип <code><font color=Green>Fix</font></code>: там нам нужно было определить экземпляр <code><font color=Green>Num</font></code> для синонима <code><font color=Green>Nat</font></code>:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Nat</font> <font color="#b2590f">=</font> <font color=Green>Fix</font> <font color=Green>N</font>

<font color="#b2590f">instance</font> <font color=Green>Num</font> <font color=Green>Nat</font> <font color="#b2590f">where</font></pre>
<p>В рамках стандарта все суперклассы должны быть простыми. Все они имеют вид <code><font color=Green>T</font> a</code>. Если мы хотим использовать суперклассы с составными типами, нам придётся подключить расширение <code><font color=Green>FlexibleContexts</font></code>. Этим расширением мы пользовались, когда определяли экземпляр <code><font color=Green>Show</font></code> для <code><font color=Green>Fix</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Show</font> <font color=Black>(</font>f <font color=Black>(</font><font color=Green>Fix</font> f<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Show</font> <font color=Black>(</font><font color=Green>Fix</font> f<font color=Black>)</font> <font color="#b2590f">where</font>
    show x <font color="#b2590f">=</font> <font color=Black>"("</font> <font color=Black>++</font> show <font color=Black>(</font>unFix x<font color=Black>)</font> <font color=Black>++</font> <font color=Black>")"</font></pre>
<h3 id="функциональные-зависимости"><a href="#функциональные-зависимости">Функциональные зависимости</a></h3>
<p>Класс можно представить как множество типов, для которых определены данные операции. С появлением расширения <code><font color=Green>MultiParamTypeClasses</font></code> мы можем определять операции класса для нескольких типов. Так наше множество классов превращается в отношение. Наш класс связывает несколько типов между собой. Если из одной компоненты отношения однозначно следует другая, такое отношение принято называть функцией. Например, обычную функцию одного аргумента можно представить как множество пар <code><font color=Black>(</font>x<font color=Black>,</font> f x<font color=Black>)</font></code>. Для того чтобы множество таких пар было функцией, необходимо, чтобы выполнялось свойство:</p>
<pre><font color="#b2590f">forall</font> x<font color=Black>,</font> y<font color=Black>.</font>  x <font color=Black>==</font> y <font color="#b2590f">=&gt;</font> f x <font color=Black>==</font> f y </pre>
<p>Для одинаковых входов мы получаем одинаковые выходы. С функциональными зависимостями мы можем ввести такое ограничение на классы с несколькими аргументами. Рассмотрим практический пример. Библиотека <code><font color=Green>Boolean</font></code> определяет обобщённые логические значения,</p>
<pre><font color="#b2590f">class</font> <font color=Green>Boolean</font> b <font color="#b2590f">where</font>
    true<font color=Black>,</font> false <font color="#b2590f">::</font> b
    notB        <font color="#b2590f">::</font> b <font color="#b2590f">-&gt;</font> b
    <font color=Black>(</font><font color=Black>&amp;&amp;*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>||*</font><font color=Black>)</font> <font color="#b2590f">::</font> b <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> b</pre>
<p>Логические значения определены в терминах простейших операций, теперь мы можем обобщить связку <code><font color="#b2590f">if</font><font color="#2149c1">-</font><font color="#b2590f">then</font><font color="#2149c1">-</font><font color="#b2590f">else</font></code> и классы <code><font color=Green>Eq</font></code> и <code><font color=Green>Ord</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Boolean</font> bool <font color="#b2590f">=&gt;</font> <font color=Green>IfB</font> bool a <font color="#b2590f">|</font> a <font color="#b2590f">-&gt;</font> bool <font color="#b2590f">where</font>
    ifB <font color="#b2590f">::</font> bool <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a

<font color="#b2590f">class</font> <font color=Green>Boolean</font> bool <font color="#b2590f">=&gt;</font> <font color=Green>EqB</font> bool a <font color="#b2590f">|</font> a <font color="#b2590f">-&gt;</font> bool <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>==*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>/=*</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> bool

<font color="#b2590f">class</font> <font color=Green>Boolean</font> bool <font color="#b2590f">=&gt;</font> <font color=Green>OrdB</font> bool a <font color="#b2590f">|</font> a <font color="#b2590f">-&gt;</font> bool <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;=*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&lt;=*</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> bool</pre>
<p>Каждый из классов определён на двух типах. Один из них играет роль обычных логических значений, а второй тип – это такой же параметр, как и в обычных классах из модуля <code><font color=Green>Prelude</font></code>. В этих определениях нам встретилась новая конструкция: за переменными класса через разделитель “или” следует что-то похожее на тип функции. В этом типе мы говорим, что из типа <code><font color=Black>a</font></code> следует тип <code><font color=Black>bool</font></code>, или тип <code><font color=Black>a</font></code> однозначно определяет тип <code><font color=Black>bool</font></code>. Эта информация помогает компилятору выводить типы. Если он встретит в тексте выражение <code><font color=Black>v</font> <font color="#b2590f">=</font> a <font color=Black>&lt;*</font> b</code> и тип одного из аргументов <code><font color=Black>a</font></code> или <code><font color=Black>b</font></code> известен, то тип <code><font color=Black>v</font></code> будет определён по зависимости.</p>
<p>Зачем нам может понадобиться такая система классов? Например, с ней мы можем определить экземпляр <code><font color=Green>Boolean</font></code> для предикатов или функций вида <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font></code> и затем определить три остальных класса для функций вида <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> b</code>. Мы сравниваем не отдельные логические значения, а функции, которые возвращают логические значения. Так в выражении <code><font color=Black>ifB</font> c t e</code> функция <code><font color=Black>c</font></code> играет роль “маски”: если на данном значении функция <code><font color=Black>c</font></code> вернёт истину, то мы воспользуемся значением функции <code><font color=Black>t</font></code>, иначе возьмём результат из функции <code><font color=Black>e</font></code>. Например, так мы можем определить функцию модуля:</p>
<pre><font color=Black>*</font><font color=Green>Boolean</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> absolute <font color="#b2590f">=</font> ifB <font color=Black>(</font><font color=Black>&gt;</font><font color="#0000ee">0</font><font color=Black>)</font> id negate
<font color=Black>*</font><font color=Green>Boolean</font><font color=Black>&gt;</font> map absolute <font color="#b2590f">[</font><font color="#2149c1">-</font><font color="#0000ee">10</font> <font color="#b2590f">..</font> <font color="#0000ee">10</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">9</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">9</font><font color=Black>,</font><font color="#0000ee">10</font><font color="#b2590f">]</font></pre>
<p>Мы можем указать несколько зависимостей (через запятую) или зависимость от нескольких типов (через пробел, слева от стрелки):</p>
<pre><font color="#b2590f">class</font> <font color=Green>C</font> a b c <font color="#b2590f">|</font> a <font color="#b2590f">-&gt;</font> b<font color=Black>,</font> b c <font color="#b2590f">-&gt;</font> a <font color="#b2590f">where</font>
    <font color=Black>...</font></pre>
<p>Отметим, что многие функциональные зависимости можно выразить через семейства типов. Пример из библиотеки <code><font color=Green>Boolean</font></code> можно было бы записать так:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Boolean</font> a <font color="#b2590f">where</font>
    true<font color=Black>,</font> false     <font color="#b2590f">::</font> a
    <font color=Black>(</font><font color=Black>&amp;&amp;*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>||*</font><font color=Black>)</font>    <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a

<font color="#b2590f">class</font> <font color=Green>Boolean</font> <font color=Black>(</font><font color=Green>B</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>IfB</font> a <font color="#b2590f">where</font>
    <font color="#b2590f">type</font> <font color=Green>B</font> a <font color="#b2590f">::</font> <font color=Black>*</font>
    ifB <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>B</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a

<font color="#b2590f">class</font> <font color=Green>IfB</font> a <font color="#b2590f">=&gt;</font> <font color=Green>EqB</font> a <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>==*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>/=*</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>B</font> a
               
<font color="#b2590f">class</font> <font color=Green>IfB</font> a <font color="#b2590f">=&gt;</font> <font color=Green>OrdB</font> a <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;=*</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&lt;=*</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>B</font> a</pre>
<p>Исторически первыми в Haskell появились функциональные зависимости. Поэтому некоторые пакеты на <code><font color=Green>Hackage</font></code> определены в разных вариантах. Семейства типов используются более охотно.</p>
<h3 id="ограничение-мономорфизма"><a href="#ограничение-мономорфизма">Ограничение мономорфизма</a></h3>
<p>В Haskell мы можем не писать типы функций - они будут выведены компилятором автоматически. Но написание типов функций считается признаком хорошего стиля, поскольку по типам можно догадаться, чем функция занимается. Но есть в правиле вывода типов одно исключение. Если мы напишем</p>
<pre><font color=Black>f</font> <font color="#b2590f">=</font> show</pre>
<p>то компилятор сообщит нам об ошибке. Это выражение приводит к ошибке, которая вызвана ограничением мономорфизма. Мы говорили о нём в главе о типах. Часто в сильно обобщённых библиотеках, с большими зависимостями в типах, выписывать типы крайне неудобно. Например, в библиотеке создания парсеров <code><font color=Green>Parsec</font></code> с этим ограничением приходится писать огромные объявления типов для крохотных выражений. Что-то вроде:</p>
<pre><font color=Black>fun</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Stream</font> s m t<font color=Black>,</font> <font color=Green>Show</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>ParsecT</font> s u m a <font color="#b2590f">-&gt;</font> <font color=Green>ParsecT</font> s u m <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>fun</font> <font color="#b2590f">=</font> g <font color=Black>.</font> h <font color=Black>(</font>q x<font color=Black>)</font> y</pre>
<p>И так для любого выражения. В этом случае лучше просто выключить ограничение, добавив в начало файла:</p>
<pre><font color="#2149c1">{-# Language NoMonomorphismRestriction #-}</font></pre>
<h3 id="полиморфизм-высших-порядков"><a href="#полиморфизм-высших-порядков">Полиморфизм высших порядков</a></h3>
<p>Когда мы говорили об <code><font color=Green>ST</font></code> нам встретилась функция с необычным типом:</p>
<pre><font color=Black>runST</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color="#b2590f">forall</font> s<font color=Black>.</font> <font color=Green>ST</font> s a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>Слово <code><font color="#b2590f">forall</font></code> обозначает для любых. Любой полиморфный тип в Haskell подразумевает, что он определён для любых типов. Например, когда мы пишем:</p>
<pre><font color=Black>reverse</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>map</font>     <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font></pre>
<p>На самом деле мы пишем:</p>
<pre><font color=Black>reverse</font> <font color="#b2590f">::</font> <font color="#b2590f">forall</font> a<font color=Black>.</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>map</font>     <font color="#b2590f">::</font> <font color="#b2590f">forall</font> a b<font color=Black>.</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font></pre>
<p>По названию слова <code><font color="#b2590f">forall</font></code> может показаться, что оно несёт в себе много свободы. Оно говорит о том, что функция определена для любых типов. Но если присмотреться, то эта свобода оказывается жёстким ограничением. “Для любых” означает, что мы не можем делать никаких предположений о внутренней природе значения. Мы не можем разбирать такие значения на составляющие части. Мы можем только подставлять их в новые полиморфные функции (как в <code><font color=Black>map</font></code>), отбрасывать (как <code><font color=Black>const</font></code>) или перекладывать из одного места в другое (как в <code><font color=Black>swap</font></code> или <code><font color=Black>reverse</font></code>). Мы можем немного смягчить ограничение, если укажем в контексте функции какие классы определены для значений данного типа.</p>
<p>Все стандартные полиморфные типы имеют вид:</p>
<pre><font color=Black>fun</font> <font color="#b2590f">::</font> <font color="#b2590f">forall</font> a b <font color="#b2590f">..</font> z<font color=Black>.</font> <font color=Green>Expr</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>,</font> <font color=Black>...</font><font color=Black>,</font> z<font color=Black>)</font></pre>
<p>Причём <code><font color=Green>Expr</font></code> не содержит <code><font color="#b2590f">forall</font></code>, а только стрелки и применение новых типов к параметрам. Такой тип называют полиморфным типом первого порядка (rank). Если <code><font color="#b2590f">forall</font></code> стоит справа от стрелки, то его можно вынести из выражения, например, следующие выражения эквивалентны:</p>
<pre><font color=Black>fun</font> <font color="#b2590f">::</font> <font color="#b2590f">forall</font> a<font color=Black>.</font>   a <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">forall</font> b<font color=Black>.</font> b <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>
<font color=Black>fun</font> <font color="#b2590f">::</font> <font color="#b2590f">forall</font> a b<font color=Black>.</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> b<font color=Black>)</font></pre>
<p>Так мы можем привести нестандартный тип к стандартному. Если же <code><font color="#b2590f">forall</font></code> встречается слева от стрелки, как в функции <code><font color=Black>runST</font></code>, то его уже нельзя вынести. Это приводит к повышению порядка полиморфизма. Порядок полиморфизма определяется как самый максимум среди всех подвыражений, что стоят слева от стрелки плюс один. Так в типе</p>
<pre><font color=Black>runST</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color="#b2590f">forall</font> s<font color=Black>.</font> <font color=Green>ST</font> s a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>слева от стрелки стоит тип первого порядка, прибавив единицу, получим порядок для всего выражения. Если вдруг нам захочется воспользоваться такими типами, мы можем включить одно из расширений:</p>
<pre><font color="#2149c1">{-# Language Rank2Types #-}</font>
<font color="#2149c1">{-# Language RankNTypes #-}</font></pre>
<p>В случае рангов произвольного порядка алгоритм вывода типов может не завершиться. В этом случае нам придётся помогать компилятору, расставляя типы сложных функций вручную.</p>
<h3 id="лексически-связанные-типы"><a href="#лексически-связанные-типы">Лексически связанные типы</a></h3>
<p>Мы уже привыкли к тому, что когда мы пишем</p>
<pre><font color=Black>swap</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> a<font color=Black>)</font></pre>
<p>компилятор понимает, что <code><font color=Black>a</font></code> и <code><font color=Black>b</font></code> указывают на один и тот же тип слева и справа от стрелки. При этом типы <code><font color=Black>a</font></code> и <code><font color=Black>b</font></code> не обязательно разные. Иногда нам хочется расширить действие контекста функции и распространить его на всё тело функции. Например, ранее в этой главе, когда мы имитировали числа через типы, для того чтобы извлечь число из типа, мы пользовались трюком с функцией <code><font color=Black>proxy</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Nat</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Nat</font> <font color=Black>(</font><font color=Green>Succ</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    toInt x <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>+</font> toInt <font color=Black>(</font>proxy x<font color=Black>)</font>
        
<font color=Black>proxy</font> <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> a
<font color=Black>proxy</font> <font color="#b2590f">=</font> undefined</pre>
<p>Единственное назначение функции <code><font color=Black>proxy</font></code> – это передача информации о типе. Было бы гораздо удобнее написать:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Nat</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Nat</font> <font color=Black>(</font><font color=Green>Succ</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    toInt x <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>+</font> toInt <font color=Black>(</font>undefined <font color="#b2590f">::</font> a<font color=Black>)</font></pre>
<p>Проблема в том, что по умолчанию любой полиморфный тип в Haskell имеет первый ранг – компилятор читает нашу запись как <code><font color=Black>(</font>x <font color="#b2590f">::</font> <font color="#b2590f">forall</font> a<font color=Black>.</font> a<font color=Black>)</font></code>, и получается, что мы говорим: <code><font color=Black>x</font></code> имеет любой тип, какой захочешь! Не очень полезная информация. Компилятор заблудился и спрашивает у нас: “куда пойти?” А мы ему: “да куда захочешь”. Как раз для таких случаев существует расширение <code><font color=Green>ScopedTypeVariables</font></code>. Оно связывает тип, объявленный в заголовке класса/функции с типами, которые встречаются в теле функции.<br />В случае функций есть одно отличие от случая с классами. Если мы хотим расширить действие переменной из объявления типа функции, необходимо упомянуть её в слове <code><font color="#b2590f">forall</font></code> в стандартном положении (как для типа первого порядка). У нас был ещё один пример с <code><font color=Black>proxy</font></code>:</p>
<pre><font color=Black>dt</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Nat</font> n<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Stream</font> n a <font color="#b2590f">-&gt;</font> a
<font color=Black>dt</font> xs <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>/</font> <font color=Black>(</font>fromIntegral <font color=Black>$</font> toInt <font color=Black>$</font> proxy xs<font color=Black>)</font>
    <font color="#b2590f">where</font> proxy <font color="#b2590f">::</font> <font color=Green>Stream</font> n a <font color="#b2590f">-&gt;</font> n
          proxy <font color="#b2590f">=</font> undefined</pre>
<p>В этом случае мы пишем:</p>
<pre><font color="#2149c1">{-# Language ScopedTypeVariables #-}</font>
<font color=Black>...</font>

<font color=Black>dt</font> <font color="#b2590f">::</font> <font color="#b2590f">forall</font> n<font color=Black>.</font> <font color=Black>(</font><font color=Green>Nat</font> n<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Stream</font> n a <font color="#b2590f">-&gt;</font> a
<font color=Black>dt</font> xs <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>/</font> <font color=Black>(</font>fromIntegral <font color=Black>$</font> toInt <font color=Black>(</font>undefined <font color="#b2590f">::</font> n<font color=Black>)</font><font color=Black>)</font></pre>
<p>Обратите внимание на появление <code><font color="#b2590f">forall</font></code> в определении типа. Попробуйте скомпилировать пример без него или переместите его в другое место. Во многих случаях применения этого расширения можно избежать с помощью стандартной функции <code><font color=Black>asTypeOf</font></code>, посмотрим на определение из <code><font color=Green>Prelude</font></code>:</p>
<pre><font color=Black>asTypeOf</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>asTypeOf</font> x y <font color="#b2590f">=</font> x</pre>
<p>Фактически это функция <code><font color=Black>const</font></code>, оба типа которой одинаковы. Она часто используется в инфиксной форме для фиксации типа первого аргумента:</p>
<pre><font color=Black>q</font> <font color="#b2590f">=</font> f <font color=Black>$</font> x <font color=Black>`asTypeOf`</font> var</pre>
<p>Получается очень наглядно, словно это предложение обычного языка.</p>
<h3 id="и-другие-удобства-и-украшения"><a href="#и-другие-удобства-и-украшения">И другие удобства и украшения</a></h3>
<p>Стоит упомянуть несколько расширений. Они лёгкие для понимания – в основном служат украшению записи или для сокращения рутинного кода.</p>
<p>Директива <code><font color="#b2590f">deriving</font></code> может использоваться только с несколькими стандартными классами, но если мы определили тип-обёртку через <code><font color="#b2590f">newtype</font></code> или просто синоним, то мы можем очень просто определить новый тип экземпляром любого класса, который доступен завёрнутому типу. Как раз для этого существует расширение <code><font color=Green>GeneralizedNewtypeDeriving</font></code>:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>MyDouble</font> <font color="#b2590f">=</font> <font color=Green>MyDouble</font> <font color=Green>Double</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>,</font> <font color=Green>Enum</font><font color=Black>,</font> <font color=Green>Ord</font><font color=Black>,</font> <font color=Green>Num</font><font color=Black>,</font> <font color=Green>Fractional</font><font color=Black>,</font> <font color=Green>Floating</font><font color=Black>)</font></pre>
<p>Мы говорили о том, что обычные числа в Haskell перегружены, но иногда возникает необходимость в перегруженных строках. Как раз для этого существует расширение <code><font color=Green>OverloadedStrings</font></code>. При этом за обычной записью строк может скрываться любой тип из класса:</p>
<pre><font color="#b2590f">class</font> <font color=Green>IsString</font> a <font color="#b2590f">where</font>
    fromString <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>Расширение <code><font color=Green>TypeOperators</font></code> позволяет определять инфиксные имена не только для конструкторов данных, но и для самих типов, синонимов типов и даже классов:</p>
<pre><font color="#b2590f">data</font> a <font color="#b2590f">:+:</font> b <font color="#b2590f">=</font> <font color=Green>Left</font> a <font color="#b2590f">|</font> <font color=Green>Right</font> b</pre>
<h2 id="краткое-содержание"><a href="#краткое-содержание">Краткое содержание</a></h2>
<p>В этой главе мы затронули малую часть возможностей, которые предоставляются системой ghc. Haskell является полигоном для испытания самых разнообразных идей. Это экспериментальный язык. Но в практических целях в 1998 году был зафиксирован стандарт языка, который обычно называют <code><font color=Green>Haskell98</font></code>. Любое расширение подключается с помощью специальной прагмы <code><font color=Green>Language</font></code>. Новый стандарт <code><font color=Green>Haskell</font> <font color=Green>Prime</font></code> включит в себя наиболее устоявшиеся расширения. Также мы рассмотрели несколько полезных классов и синтаксических конструкций, которые, возможно, облегчают написание программ.</p>
<h2 id="упражнения"><a href="#упражнения">Упражнения</a></h2>
<p>Это была справочная глава, присмотритесь к рассмотренным возможностям и подумайте, какие нужны вам, а какие нет. Возможно, вы вовсе не будете ими пользоваться, но некоторые из них могут встретиться вам в чужом коде или в библиотеках.</p>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="16.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="18.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="16" style="list-style-type: decimal">
<li>Категориальные типы
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="18" style="list-style-type: decimal">
<li>Средства разработки
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
