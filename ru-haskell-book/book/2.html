<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#первая-программа">Первая программа</a><ul>
<li><a href="#интерпретатор">Интерпретатор</a></li>
<li><a href="#у-вей">У-вей</a></li>
<li><a href="#логические-значения">Логические значения</a></li>
<li><a href="#класс-show.-строки-и-символы">Класс Show. Строки и символы</a><ul>
<li><a href="#строки-и-символы">Строки и символы</a></li>
<li><a href="#пример-отображение-дат-и-времени">Пример: Отображение дат и времени</a></li>
</ul></li>
<li><a href="#автоматический-вывод-экземпляров-классов-типов">Автоматический вывод экземпляров классов типов</a></li>
<li><a href="#арифметика">Арифметика</a><ul>
<li><a href="#класс-eq.-сравнение-на-равенство">Класс Eq. Сравнение на равенство</a></li>
<li><a href="#класс-num.-сложение-и-умножение">Класс Num. Сложение и умножение</a><ul>
<li><a href="#сложение">Сложение</a></li>
<li><a href="#вычитание">Вычитание</a></li>
<li><a href="#умножение">Умножение</a></li>
<li><a href="#операции-abs-и-signum">Операции abs и signum</a></li>
<li><a href="#перегрузка-чисел">Перегрузка чисел</a></li>
</ul></li>
<li><a href="#класс-fractional.-деление">Класс Fractional. Деление</a></li>
<li><a href="#стандартные-числа">Стандартные числа</a><ul>
<li><a href="#целые-числа">Целые числа</a></li>
<li><a href="#действительные-числа">Действительные числа</a></li>
<li><a href="#преобразование-численных-типов">Преобразование численных типов</a></li>
</ul></li>
</ul></li>
<li><a href="#документация">Документация</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a><ul>
<li><a href="#типы">Типы</a></li>
<li><a href="#классы">Классы</a></li>
<li><a href="#особенности-синтаксиса">Особенности синтаксиса</a></li>
</ul></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="1.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="3.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="первая-программа"><a href="#TOC">Первая программа</a></h1>
<p>Я вот говорю-говорю, а вдруг я вас обманываю, и ничего этого нет. В этой главе мы перейдём к программированию и запустим нашу первую программу в Haskell. Будет много примеров, на которых мы закрепим наши знания.</p>
<h2 id="интерпретатор"><a href="#TOC">Интерпретатор</a></h2>
<p>Для запуска кода мы будем пользоваться приложением GHC (Glorious Glasgow Haskell Compiler) наиболее развитой системой интерпретации Haskell программ. В GHC есть компилятор <code><font color=Black>ghc</font></code> и интерпретатор <code><font color=Black>ghci</font></code>. Пока мы будем пользоваться лишь интерпретатором. Если вы не знаете как установить <code><font color=Black>ghc</font></code> загляните в приложение. Также нам понадобится текстовый редактор с подсветкой синтаксиса. Подсветка синтаксиса для Haskell по умолчанию есть в редакторах Vim, Emacs, gedit, yi. Есть IDE для Haskell Leksah. Мы будем писать модули в файлах и загружать их в интерпретатор. Если вы не знаете продвинутых текстовых редакторов вроде Vim или Emacs, лучше всего будет начать с gedit.</p>
<p>Интерпретатор позволяет загружать модуль с определениями и набирать значения в командной строке. Мы набираем значение, а интерпретатор редуцирует его и показывает нам ответ. Интерпретатор запускается командой <code><font color=Black>ghci</font></code> в терминале. Определения из модуля могут быть загружены в интерпретатор двумя способами, либо при запуске интерпретатора командой <code><font color=Black>ghci</font> <font color=Green>ИмяМодуля</font><font color=Black>.</font>hs</code> либо в самом интерпретаторе командой <code><font color="#b2590f">:</font>l <font color=Green>ИмяМодуля</font><font color=Black>.</font>hs</code>.</p>
<p>Рассмотрим некоторые полезные команды интерпретатора:</p>
<dl>
<dt><code><font color="#b2590f">:?</font></code></dt>
<dd><p>Выводит на экран список доступных команд</p>
</dd>
<dt><code><font color="#b2590f">:</font>t <font color=Green>Expression</font></code></dt>
<dd><p>Возвращает тип выражения.</p>
</dd>
<dt><code><font color="#b2590f">:</font>set <font color=Black>+</font>t</code></dt>
<dd><p>После выполнения команды интерпретатор будет выводить на экран не только результат вычисления выражения, но и его тип.</p>
</dd>
<dt><code><font color="#b2590f">:</font>set <font color=Black>+</font>s</code></dt>
<dd><p>После выполнения команды интерпретатор будет выводить на экран не только результат вычисления выражения, но и статистику вычислений.</p>
</dd>
<dt><code><font color="#b2590f">:</font>l <font color=Green>ИмяМодуля</font></code></dt>
<dd><p>Загружает модуль в интерпретатор.</p>
</dd>
<dt><code><font color="#b2590f">:</font>cd <font color=Green>Директория</font></code></dt>
<dd><p>Перейти в данную директорию.</p>
</dd>
<dt><code><font color="#b2590f">:</font>r</code></dt>
<dd><p>Перезагружает, последний загруженный модуль. Этой командой можно пользоваться после внесения в модуль изменений.</p>
</dd>
<dt><code><font color="#b2590f">:</font>q</code></dt>
<dd><p>Выход из интерпретатора.</p>
</dd>
</dl>
<h2 id="у-вей"><a href="#TOC">У-вей</a></h2>
<p>Согласно даосам основной принцип жизни заключается в недеянии (у-вей). Всё происходит естественно и словно само собой. Давайте создадим модуль который ничего не делает. Создадим пустой модуль и загрузим его в интерпретатор.</p>
<pre><font color="#b2590f">module</font> <font color=Green>Empty</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Green>()</font></pre>
<p>Зачем мы написали <code><font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Green>()</font></code>? Этой фразой мы говорим, что не хотим ничего импортировать из модуля <code><font color=Green>Prelude</font></code>. По умолчанию в любой модуль загружается модуль <code><font color=Green>Prelude</font></code>, который содержит много полезных определений. К примеру там определяется тип <code><font color=Green>Bool</font></code>, списки и функции для них, символы, классы типов для сравнения на равенство и печати значений и много, много других определений. В первых главах я хочу сделать акцент на самом языке Haskell, а не на производных выражениях, поэтому пока мы будем в явном виде загружать из модуля <code><font color=Green>Prelude</font></code> лишь самые необходимые определения.</p>
<p>Сохраним модуль в файле <code><font color=Green>Empty</font><font color=Black>.</font>hs</code>, сделаем директорию модуля текущей и запустим интерпретатор командой <code><font color=Black>ghci</font> <font color=Green>Empty</font></code> (имя расширения можно не писать). Также можно просто запустить интерпретатор командой <code><font color=Black>ghci</font></code>, переключиться на директорию командой <code><font color="#b2590f">:</font>cd</code> и загрузить модуль командой <code><font color="#b2590f">:</font>l <font color=Green>Empty</font></code>.</p>
<pre>$ ghci
GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> :cd ~/haskell-notes/code/ch-2/
Prelude> :l Empty.hs 
[1 of 1] Compiling Empty            ( Empty.hs, interpreted )
Ok, modules loaded: Empty.
*Empty> </pre>
<p>Слева от знака приглашения к вводу <code><font color=Black>&gt;</font></code> отображаются загруженные в интерпретатор модули. По умолчанию загружается модуль <code><font color=Green>Prelude</font></code>. После выполнения команды <code><font color="#b2590f">:</font>l</code> мы видим, что <code><font color=Green>Prelude</font></code> сменилось на <code><font color=Green>Empty</font></code>.</p>
<p>Теперь давайте потренируемся перезагружать модули. Давайте изменим наш модуль, сделаем его не таким пустым, убрав последние две скобки от модуля <code><font color=Green>Prelude</font></code> в директиве <code><font color="#b2590f">import</font></code>. Теперь сохраним изменения и выполним команду <code><font color="#b2590f">:</font>r</code>.</p>
<pre><font color=Black>*</font><font color=Green>Empty</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>r
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Empty</font>            <font color=Black>(</font> <font color=Green>Empty</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Empty</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Empty</font><font color=Black>&gt;</font></pre>
<p>Завершим сессию интерпретатора командой <code><font color="#b2590f">:</font>q</code>.</p>
<pre><font color=Black>*</font><font color=Green>Empty</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>q
<font color=Green>Leaving</font> <font color=Green>GHCi</font><font color=Black>.</font></pre>
<p>Внешние модули должны находится в текущей директории. Давайте потренируемся с подключением определений из внешних модулей. Создадим модуль близнец модуля <code><font color=Green>Empty</font><font color=Black>.</font>hs</code>:</p>
<pre><font color="#b2590f">module</font> <font color=Green>EmptyEmpty</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Green>()</font></pre>
<p>И сохраним его в той же директории, что и модуль <code><font color=Green>Empty</font></code>, теперь мы можем включить все определения из модуля <code><font color=Green>EmptyEmpty</font></code>:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Empty</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>EmptyEmpty</font></pre>
<p>Когда у нас будет много модулей мы можем разместить их по директориям. Создадим в одной директории с модулем <code><font color=Green>Empty</font></code> директорию <code><font color=Green>Sub</font></code>, а в неё поместим копию модуля <code><font color=Green>Empty</font></code>. Существует одна тонкость: поскольку модуль находится в поддиректории, для того чтобы он стал виден из текущей директории, необходимо дописать через точку имя директории в которой он находится:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Sub</font><font color=Black>.</font><font color=Green>Empty</font> <font color="#b2590f">where</font></pre>
<p>Теперь мы можем загрузить этот модуль из исходного:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Empty</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>EmptyEmpty</font>
<font color="#b2590f">import</font> <font color=Green>Sub</font><font color=Black>.</font><font color=Green>Empty</font></pre>
<p>Обратите внимание на то, что мы приписываем к модулю в поддиректории <code><font color=Green>Sub</font></code> имя поддиректории. Если бы он был заложен в ещё одной директории, то мы написали бы через точку имя и этой поддиректории:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Empty</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Sub1</font><font color=Black>.</font><font color=Green>Sub2</font><font color=Black>.</font><font color=Green>Sub3</font><font color=Black>.</font><font color=Green>Sub4</font><font color=Black>.</font><font color=Green>Empty</font></pre>
<h2 id="логические-значения"><a href="#TOC">Логические значения</a></h2>
<p>Пустой модуль это хорошо, но слишком скучно. Давайте перепишем объявленные в этой главе определения в модуль, загрузим его в интерпретатор и понабираем значения.</p>
<p>Начнём с логических операций. Давайте не будем переопределять <code><font color=Green>Bool</font></code>, <code><font color=Green>Show</font></code> и <code><font color=Green>Eq</font></code>, а просто возьмём их из <code><font color=Green>Prelude</font></code>:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Logic</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Black>(</font><font color=Green>Bool</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Show</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Две точки в скобках означают “все конструкторы” (в случае типа) и “все методы” (в случае класса типа). Строчку</p>
<pre><font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Black>(</font><font color=Green>Bool</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Show</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Следует читать так: Импортируй из модуля <code><font color=Green>Prelude</font></code> тип <code><font color=Green>Bool</font></code> и все его конструкторы и классы <code><font color=Green>Show</font></code> и <code><font color=Green>Eq</font></code> со всеми их методами. Если бы мы захотели импортировать только конструктор <code><font color=Green>True</font></code>, мы бы написали <code><font color=Green>Bool</font><font color=Black>(</font><font color=Green>True</font><font color=Black>)</font></code>, а если бы мы захотели импортировать лишь имя типа, мы бы написали просто <code><font color=Green>Bool</font></code> без скобок.</p>
<p>Сначала выпишем в модуль наши синонимы:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Logic</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Black>(</font><font color=Green>Bool</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Show</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>)</font>
  
<font color=Black>true</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> 
<font color=Black>true</font> <font color="#b2590f">=</font> <font color=Green>True</font>

<font color=Black>false</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Black>false</font> <font color="#b2590f">=</font> <font color=Green>False</font>

<font color=Black>not</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>not</font> <font color=Green>True</font>  <font color="#b2590f">=</font> <font color=Green>False</font>
<font color=Black>not</font> <font color=Green>False</font> <font color="#b2590f">=</font> <font color=Green>True</font>

<font color=Black>and</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>and</font> <font color=Green>False</font>  <font color="#b2590f">_</font>  <font color="#b2590f">=</font> <font color=Green>False</font>
<font color=Black>and</font> <font color=Green>True</font>   x  <font color="#b2590f">=</font> x

<font color=Black>or</font>  <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>or</font> <font color=Green>True</font>   <font color="#b2590f">_</font> <font color="#b2590f">=</font> <font color=Green>True</font>
<font color=Black>or</font> <font color=Green>False</font>  x <font color="#b2590f">=</font> x

<font color=Black>xor</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>xor</font> a b <font color="#b2590f">=</font> or <font color=Black>(</font>and <font color=Black>(</font>not a<font color=Black>)</font> b<font color=Black>)</font> <font color=Black>(</font>and a <font color=Black>(</font>not b<font color=Black>)</font><font color=Black>)</font>

<font color=Black>ifThenElse</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>ifThenElse</font> <font color=Green>True</font>   t  <font color="#b2590f">_</font> <font color="#b2590f">=</font> t
<font color=Black>ifThenElse</font> <font color=Green>False</font>  <font color="#b2590f">_</font>  e <font color="#b2590f">=</font> e</pre>
<p>Теперь сохраним модуль и загрузим его в интерпретатор. Для наглядности мы установим флаг <code><font color=Black>+</font>t</code>, при этом будет возвращено не только значение, но и его тип. Понабираем разные комбинации значений:</p>
<pre><font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Logic</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Logic</font>            <font color=Black>(</font> <font color=Green>Logic</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Logic</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>set <font color=Black>+</font>t
<font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> not <font color=Black>(</font>and true <font color=Green>False</font><font color=Black>)</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> or <font color=Black>(</font>and true true<font color=Black>)</font> <font color=Black>(</font>or <font color=Green>False</font> <font color=Green>False</font><font color=Black>)</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> xor <font color=Black>(</font>not <font color=Green>True</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>False</font><font color=Black>)</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> ifThenElse <font color=Black>(</font>or true false<font color=Black>)</font> <font color=Green>True</font> <font color=Green>False</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font></pre>
<p>Разумеется в Haskell уже определены логические операции, здесь мы просто тренировались. Они называются <code><font color=Black>not</font></code>, <code><font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font></code>, <code><font color=Black>||</font></code>. Операция <code><font color=Black>xor</font></code> это то же самое, что и <code><font color=Black>(</font><font color=Black>/=</font><font color=Black>)</font></code>. Для <code><font color=Green>Bool</font></code> определён экземпляр класса <code><font color=Green>Eq</font></code>. Также в Haskell есть конструкция ветвления она пишется так:</p>
<pre><font color=Black>x</font> <font color="#b2590f">=</font> <font color="#b2590f">if</font> cond <font color="#b2590f">then</font> t <font color="#b2590f">else</font> e</pre>
<p>Слова <code><font color="#b2590f">if</font></code>, <code><font color="#b2590f">then</font></code> и <code><font color="#b2590f">else</font></code> – ключевые. <code><font color=Black>cond</font></code> имеет тип <code><font color=Green>Bool</font></code>, а <code><font color=Black>t</font></code> и <code><font color=Black>e</font></code> одинаковый тип.</p>
<p>В коде программы обычно пишут так:</p>
<pre><font color=Black>x</font> <font color="#b2590f">=</font> <font color="#b2590f">if</font> a <font color=Black>&gt;</font> <font color="#0000ee">3</font> 
    <font color="#b2590f">then</font> <font color=Black>"Hello"</font>
    <font color="#b2590f">else</font> <font color=Black>(</font><font color="#b2590f">if</font> a <font color=Black>&lt;</font> <font color="#0000ee">0</font>
          <font color="#b2590f">then</font> <font color=Black>"Hello"</font>
          <font color="#b2590f">else</font> <font color=Black>"Bye"</font><font color=Black>)</font></pre>
<p>Отступы обязательны.</p>
<p>Давайте загрузим в интерпретатор модуль <code><font color=Green>Prelude</font></code> и наберём те же выражения стандартными функциями:</p>
<pre><font color=Black>*</font><font color=Green>Logic</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Green>Prelude</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> not <font color=Black>(</font><font color=Green>True</font> <font color=Black>&amp;&amp;</font> <font color=Green>False</font><font color=Black>)</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>(</font><font color=Green>True</font> <font color=Black>&amp;&amp;</font> <font color=Green>True</font><font color=Black>)</font> <font color=Black>||</font> <font color=Black>(</font><font color=Green>False</font> <font color=Black>||</font> <font color=Green>False</font><font color=Black>)</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> not <font color=Green>True</font> <font color=Black>/=</font> <font color=Green>False</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">if</font> <font color=Black>(</font><font color=Green>True</font> <font color=Black>||</font> <font color=Green>False</font><font color=Black>)</font> <font color="#b2590f">then</font> <font color=Green>True</font> <font color="#b2590f">else</font> <font color=Green>False</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font></pre>
<p>Бинарные операции с символьными именами пишутся в инфиксной форме, т.е.~между аргументами как в <code><font color=Black>a</font> <font color=Black>&amp;&amp;</font> b</code> или <code><font color=Black>a</font> <font color=Black>+</font> b</code>. Значение с буквенным именем также можно писать в инфиксной форме, для этого оно заключается в апострофы, например <code><font color=Black>a</font> <font color=Black>`and`</font> b</code> или <code><font color=Black>a</font> <font color=Black>`plus`</font> b</code>. Апострофы обычно находятся на одной кнопке с буквой “ё”. Также символьные функции можно применять в префиксной форме, заключив их в скобки, например <code><font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> a b</code> и <code><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a b</code>. Попробуем в интерпретаторе:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Green>True</font> <font color=Black>&amp;&amp;</font> <font color=Green>False</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Integer</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> <font color=Green>True</font> <font color=Green>False</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> and a b <font color="#b2590f">=</font> a <font color=Black>&amp;&amp;</font> b
<font color=Black>and</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> and <font color=Green>True</font> <font color=Green>False</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Green>True</font> <font color=Black>`and`</font> <font color=Green>False</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font></pre>
<p>Обратите внимание на строчку <code><font color="#b2590f">let</font> and a b <font color="#b2590f">=</font> a <font color=Black>&amp;&amp;</font> b</code>. В ней мы определили синоним в интерпретаторе. Сначала мы пишем ключевое слово <code><font color="#b2590f">let</font></code> затем обычное определение синонима, как в программе. Но не совсем обычное синоним должен быть однострочным. У нас не получится например определить такой синоним как <code><font color=Black>not</font></code>. Потому что в нём два уравнения.</p>
<h2 id="класс-show.-строки-и-символы"><a href="#TOC">Класс Show. Строки и символы</a></h2>
<p>Мы набираем в интерпретаторе какое-нибудь сложное выражение, или составной синоним, интерпретатор проводит редукцию и выводит ответ на экран. Откуда интерпретатор знает как отображать значения типа <code><font color=Green>Bool</font></code>? Внутри интерпретатора вызывается метод класса <code><font color=Green>Show</font></code>, который переводит значение в строку. И затем мы видим на экране ответ.<br />Для типа <code><font color=Green>Bool</font></code> экземпляр класса <code><font color=Green>Show</font></code> уже определён, поэтому интерпретатор знает как его отображать.</p>
<p>Обратите внимание на эту особенность языка, вид значения определяется пользователем, в экземпляре класса <code><font color=Green>Show</font></code>. Из соображений наглядности вид значения может сильно отличаться от его внутреннего представления.</p>
<p>В этом разделе мы рассмотрим несколько примеров с классом <code><font color=Green>Show</font></code>, но перед этим мы поговорим о строках и символах в языке Haskell.</p>
<h3 id="строки-и-символы"><a href="#TOC">Строки и символы</a></h3>
<p>Посмотрим в интерпретаторе что из себя представляют строки (тип <code><font color=Green>String</font></code>), для этого мы воспользуемся командой <code><font color="#b2590f">:</font>i</code> (сокращение от <code><font color="#b2590f">:</font>info</code>):</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>String</font>
<font color="#b2590f">type</font> <font color=Green>String</font> <font color="#b2590f">=</font> <font color="#b2590f">[</font><font color=Green>Char</font><font color="#b2590f">]</font> 	<font color="#2149c1">-- Defined in `GHC.Base'</font></pre>
<p>Интерпретатор показал определение типа и в комментариях указал в каком модуле тип определён. В этом определении мы видим новое ключевое слово <code><font color="#b2590f">type</font></code>. До этого для определения типов нам встречалось лишь слово <code><font color="#b2590f">data</font></code>. Ключевое слово <code><font color="#b2590f">type</font></code> определяет синоним типа. При этом мы не вводим новый тип, мы лишь определяем для него псевдоним. <code><font color=Green>String</font></code> является синонимом для списка значений типа <code><font color=Green>Char</font></code>. Тип <code><font color=Green>Char</font></code> представляет символы. Итак строка – это список символов. В Haskell символы пишутся в ординарных кавычках, а строки в двойных:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color=Black>'H'</font><font color=Black>,</font><font color=Black>'e'</font><font color=Black>,</font><font color=Black>'l'</font><font color=Black>,</font><font color=Black>'l'</font><font color=Black>,</font><font color=Black>'o'</font><font color="#b2590f">]</font>
<font color=Black>"Hello"</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Char</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>"Hello"</font>
<font color=Black>"Hello"</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Char</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>'+'</font>
<font color=Black>'+'</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Char</font></pre>
<p>Для обозначения перехода на новую строку используется специальный символ <code><font color="#b2590f">\</font>n</code>. Если строка слишком длинная и не помещается на одной строке, то её можно перенести так:</p>
<pre><font color=Black>str</font> <font color="#b2590f">=</font> <font color=Black>"My long long long long \
        \long long string"</font></pre>
<p>Перенос осуществляется с помощью комбинации следующих друг за другом обратных слэшей.</p>
<p>Нам понадобится функция конкатенации списков <code><font color=Black>(</font><font color=Black>++</font><font color=Black>)</font></code>, она определена в <code><font color=Green>Prelude</font></code>, с её помощью мы будем объединять строки:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t <font color=Black>(</font><font color=Black>++</font><font color=Black>)</font>
<font color=Black>(</font><font color=Black>++</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>"Hello"</font> <font color=Black>++</font> <font color="#b2590f">[</font><font color=Black>' '</font><font color="#b2590f">]</font> <font color=Black>++</font> <font color=Black>"World"</font>
<font color=Black>"Hello World"</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Char</font><font color="#b2590f">]</font></pre>
<h3 id="пример-отображение-дат-и-времени"><a href="#TOC">Пример: Отображение дат и времени</a></h3>
<p>Приведём, пример в котором отображаемое значение не совпадает с видом значения в коде. Мы отобразим значения из мира календаря. Для начала давайте сохраним определения в отдельном модуле:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Calendar</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font> <font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Char</font><font color=Black>,</font> <font color=Green>String</font><font color=Black>,</font> <font color=Green>Show</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>++</font><font color=Black>)</font><font color=Black>)</font>

<font color="#2149c1">-- Дата</font>
<font color="#b2590f">data</font> <font color=Green>Date</font> <font color="#b2590f">=</font> <font color=Green>Date</font> <font color=Green>Year</font> <font color=Green>Month</font> <font color=Green>Day</font>

<font color="#2149c1">-- Год</font>
<font color="#b2590f">data</font> <font color=Green>Year</font>  <font color="#b2590f">=</font> <font color=Green>Year</font> <font color=Green>Int</font>       <font color="#2149c1">-- Int это целые числа</font>

<font color="#2149c1">-- Месяц</font>
<font color="#b2590f">data</font> <font color=Green>Month</font>  <font color="#b2590f">=</font> <font color=Green>January</font>    <font color="#b2590f">|</font> <font color=Green>February</font>   <font color="#b2590f">|</font> <font color=Green>March</font>    <font color="#b2590f">|</font> <font color=Green>April</font>          
            <font color="#b2590f">|</font> <font color=Green>May</font>        <font color="#b2590f">|</font> <font color=Green>June</font>       <font color="#b2590f">|</font> <font color=Green>July</font>     <font color="#b2590f">|</font> <font color=Green>August</font>   
            <font color="#b2590f">|</font> <font color=Green>September</font>  <font color="#b2590f">|</font> <font color=Green>October</font>    <font color="#b2590f">|</font> <font color=Green>November</font> <font color="#b2590f">|</font> <font color=Green>December</font>

<font color="#b2590f">data</font> <font color=Green>Day</font> <font color="#b2590f">=</font> <font color=Green>Day</font> <font color=Green>Int</font>

<font color="#2149c1">-- Неделя</font>
<font color="#b2590f">data</font> <font color=Green>Week</font>  <font color="#b2590f">=</font> <font color=Green>Monday</font>     <font color="#b2590f">|</font> <font color=Green>Tuesday</font>   <font color="#b2590f">|</font> <font color=Green>Wednesday</font> 
           <font color="#b2590f">|</font> <font color=Green>Thursday</font>   <font color="#b2590f">|</font> <font color=Green>Friday</font>    <font color="#b2590f">|</font> <font color=Green>Saturday</font>     
           <font color="#b2590f">|</font> <font color=Green>Sunday</font>   

<font color="#2149c1">-- Время</font>
<font color="#b2590f">data</font> <font color=Green>Time</font> <font color="#b2590f">=</font> <font color=Green>Time</font> <font color=Green>Hour</font> <font color=Green>Minute</font> <font color=Green>Second</font>

<font color="#b2590f">data</font> <font color=Green>Hour</font>   <font color="#b2590f">=</font> <font color=Green>Hour</font>   <font color=Green>Int</font>    <font color="#2149c1">-- Час</font>
<font color="#b2590f">data</font> <font color=Green>Minute</font> <font color="#b2590f">=</font> <font color=Green>Minute</font> <font color=Green>Int</font>    <font color="#2149c1">-- Минута</font>
<font color="#b2590f">data</font> <font color=Green>Second</font> <font color="#b2590f">=</font> <font color=Green>Second</font> <font color=Green>Int</font>    <font color="#2149c1">-- Секунда</font></pre>
<p>Теперь сохраним наш модуль под именем <code><font color=Green>Calendar</font><font color=Black>.</font>hs</code> и загрузим в интерпретатор:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Calendar</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Calendar</font>         <font color=Black>(</font> <font color=Green>Calendar</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Calendar</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Calendar</font><font color=Black>&gt;</font> <font color=Green>Monday</font>

<font color=Black>&lt;</font>interactive<font color=Black>&gt;:</font><font color="#0000ee">3</font><font color="#b2590f">:</font><font color="#0000ee">1</font><font color="#b2590f">:</font>
    <font color=Green>No</font> <font color="#b2590f">instance</font> for <font color=Black>(</font><font color=Green>Show</font> <font color=Green>Week</font><font color=Black>)</font>
      arising from a use <font color="#b2590f">of</font> <font color=Black>`</font><font color=Green>System</font><font color=Black>.</font><font color=Green>IO</font><font color=Black>.</font>print'
    <font color=Green>Possible</font> fix<font color="#b2590f">:</font> add an <font color="#b2590f">instance</font> declaration for <font color=Black>(</font><font color=Green>Show</font> <font color=Green>Week</font><font color=Black>)</font>
    <font color=Green>In</font> a stmt <font color="#b2590f">of</font> an interactive <font color=Green>GHCi</font> command<font color="#b2590f">:</font> <font color=Green>System</font><font color=Black>.</font><font color=Green>IO</font><font color=Black>.</font>print it</pre>
<p>Смотрите мы попытались распечатать значение <code><font color=Green>Monday</font></code>, но в ответ получили ошибку. В ней интерпретатор сообщает нам о том, что для типа <code><font color=Green>Week</font></code> не определён экземпляр класса <code><font color=Green>Show</font></code> и он не знает как его распечатывать. Давайте подскажем ему. Обычно дни недели в календарях печатают не полностью, в имя попадают лишь три первых буквы:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Show</font> <font color=Green>Week</font> <font color="#b2590f">where</font>
    show <font color=Green>Monday</font>     <font color="#b2590f">=</font> <font color=Black>"Mon"</font>
    show <font color=Green>Tuesday</font>    <font color="#b2590f">=</font> <font color=Black>"Tue"</font>
    show <font color=Green>Wednesday</font>  <font color="#b2590f">=</font> <font color=Black>"Wed"</font>
    show <font color=Green>Thursday</font>   <font color="#b2590f">=</font> <font color=Black>"Thu"</font>  
    show <font color=Green>Friday</font>     <font color="#b2590f">=</font> <font color=Black>"Fri"</font> 
    show <font color=Green>Saturday</font>   <font color="#b2590f">=</font> <font color=Black>"Sat"</font>
    show <font color=Green>Sunday</font>     <font color="#b2590f">=</font> <font color=Black>"Sun"</font></pre>
<p>Отступы перед <code><font color=Black>show</font></code> обязательны, но выравнивание по знаку равно не обязательно, мне просто нравится так писать. По отступам компилятор понимает, что все определения относятся к определению <code><font color="#b2590f">instance</font></code>. Теперь запишем экземпляр в модуль, сохраним, и перезагрузим в интерпретатор:</p>
<pre><font color=Black>*</font><font color=Green>Calendar</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>r
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Calendar</font>         <font color=Black>(</font> <font color=Green>Calendar</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Calendar</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Calendar</font><font color=Black>&gt;</font> <font color=Green>Monday</font>
<font color=Green>Mon</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Week</font>
<font color=Black>*</font><font color=Green>Calendar</font><font color=Black>&gt;</font> <font color=Green>Sunday</font>
<font color=Green>Sun</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Week</font></pre>
<p>Теперь наши дни отображаются. Я выпишу ещё один пример экземпляра для <code><font color=Green>Time</font></code>, а остальные достанутся вам в качестве упражнения.</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Show</font> <font color=Green>Time</font> <font color="#b2590f">where</font>
    show <font color=Black>(</font><font color=Green>Time</font> h m s<font color=Black>)</font> <font color="#b2590f">=</font> show h <font color=Black>++</font> <font color=Black>":"</font> <font color=Black>++</font> show m <font color=Black>++</font> <font color=Black>":"</font> <font color=Black>++</font> show s

<font color="#b2590f">instance</font> <font color=Green>Show</font> <font color=Green>Hour</font> <font color="#b2590f">where</font>
    show <font color=Black>(</font><font color=Green>Hour</font> h<font color=Black>)</font> <font color="#b2590f">=</font> addZero <font color=Black>(</font>show h<font color=Black>)</font>

<font color="#b2590f">instance</font> <font color=Green>Show</font> <font color=Green>Minute</font> <font color="#b2590f">where</font>
    show <font color=Black>(</font><font color=Green>Minute</font> m<font color=Black>)</font> <font color="#b2590f">=</font> addZero <font color=Black>(</font>show m<font color=Black>)</font>

<font color="#b2590f">instance</font> <font color=Green>Show</font> <font color=Green>Second</font> <font color="#b2590f">where</font>
    show <font color=Black>(</font><font color=Green>Second</font> s<font color=Black>)</font> <font color="#b2590f">=</font> addZero <font color=Black>(</font>show s<font color=Black>)</font>

<font color=Black>addZero</font> <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> <font color=Green>String</font>
<font color=Black>addZero</font> <font color=Black>(</font>a<font color="#b2590f">:</font><font color=Green>[]</font><font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>'0'</font> <font color="#b2590f">:</font> a <font color="#b2590f">:</font> <font color=Green>[]</font>
<font color=Black>addZero</font> <font color="#b2590f">as</font>     <font color="#b2590f">=</font> <font color="#b2590f">as</font></pre>
<p>Функцией <code><font color=Black>addZero</font></code> мы добавляем ноль в начало строки, в том случае если число однозначное, также в этом определении мы воспользовались тем, что для типа целых чисел <code><font color=Green>Int</font></code> экземпляр <code><font color=Green>Show</font></code> уже определён. Проверим в интерпретаторе:</p>
<pre><font color=Black>*</font><font color=Green>Calendar</font><font color=Black>&gt;</font> <font color=Green>Time</font> <font color=Black>(</font><font color=Green>Hour</font> <font color="#0000ee">13</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Minute</font> <font color="#0000ee">25</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Second</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color="#0000ee">13</font><font color="#b2590f">:</font><font color="#0000ee">25</font><font color="#b2590f">:</font><font color="#0000ee">02</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Time</font></pre>
<h2 id="автоматический-вывод-экземпляров-классов-типов"><a href="#TOC">Автоматический вывод экземпляров классов типов</a></h2>
<p>Для некоторых стандартных классов экземпляры классов типов могут быть выведены автоматически. Это делается с помощью директивы <code><font color="#b2590f">deriving</font></code>. Она пишется сразу после объявления типа. Например так мы можем определить тип и экземпляры для классов <code><font color=Green>Show</font></code> и <code><font color=Green>Eq</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>T</font> <font color="#b2590f">=</font> <font color=Green>A</font> <font color="#b2590f">|</font> <font color=Green>B</font> <font color="#b2590f">|</font> <font color=Green>C</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font></pre>
<p>Отступ за <code><font color="#b2590f">deriving</font></code> обязателен, после ключевого слова в скобках указываются классы, которые мы хотим вывести.</p>
<h2 id="арифметика"><a href="#TOC">Арифметика</a></h2>
<p>В этом разделе мы обсудим основные арифметические операции. В Haskell много стандартных классов, которые группируют различные типы операций, есть класс для сравнения на равенство, отдельный класс для сравнения на больше/меньше, класс для умножения, класс для деления, класс для упорядоченных чисел, и много других. Зачем такое изобилие классов?</p>
<p>Каждый из классов отвечает независимой группе операций. Есть много объектов, которые можно только складывать, но нельзя умножать или делить. Есть объекты, для которых сравнение на равенство имеет смысл, а сравнение на больше/меньше – нет.</p>
<p>Для иллюстрации мы воспользуемся числами Пеано, у них компактное определение, всего два конструктора, которых тем не менее достаточно для описания множества натуральных чисел:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Nat</font> <font color="#b2590f">where</font>

<font color="#b2590f">data</font> <font color=Green>Nat</font> <font color="#b2590f">=</font> <font color=Green>Zero</font> <font color="#b2590f">|</font> <font color=Green>Succ</font> <font color=Green>Nat</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>,</font> <font color=Green>Ord</font><font color=Black>)</font></pre>
<p>Конструктор <code><font color=Green>Zero</font></code> указывает на число ноль, а <code><font color=Black>(</font><font color=Green>Succ</font> n<font color=Black>)</font></code> на число следующее за данным числом <code><font color=Black>n</font></code>. В последней строчке мы видим новый класс <code><font color=Green>Ord</font></code>, этот класс содержит операции сравнения на больше/меньше:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>Ord</font>
<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Eq</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Ord</font> a <font color="#b2590f">where</font>
  compare <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ordering</font>
  <font color=Black>(</font><font color=Black>&lt;</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
  <font color=Black>(</font><font color=Black>&gt;=</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
  <font color=Black>(</font><font color=Black>&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
  <font color=Black>(</font><font color=Black>&lt;=</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
  max <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  min <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a</pre>
<p>Тип <code><font color=Green>Ordering</font></code> кодирует результаты сравнения:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>Ordering</font>
<font color="#b2590f">data</font> <font color=Green>Ordering</font> <font color="#b2590f">=</font> <font color=Green>LT</font> <font color="#b2590f">|</font> <font color=Green>EQ</font> <font color="#b2590f">|</font> <font color=Green>GT</font> 	<font color="#2149c1">-- Defined in GHC.Ordering</font></pre>
<p>Он содержит конструкторы, соответствующие таким понятиям как меньше, равно и больше.</p>
<h3 id="класс-eq.-сравнение-на-равенство"><a href="#TOC">Класс Eq. Сравнение на равенство</a></h3>
<p>Вспомним определение класса <code><font color=Green>Eq</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Eq</font> a <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>==</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
    <font color=Black>(</font><font color=Black>/=</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>

    a <font color=Black>==</font> b <font color="#b2590f">=</font> not <font color=Black>(</font>a <font color=Black>/=</font> b<font color=Black>)</font>
    a <font color=Black>/=</font> b <font color="#b2590f">=</font> not <font color=Black>(</font>a <font color=Black>==</font> b<font color=Black>)</font></pre>
<p>Появились две детали, о которых я умолчал в предыдущей главе. Это две последние строчки. В них мы видим определение <code><font color=Black>==</font></code> через <code><font color=Black>/=</font></code> и наоборот. Это определения методов по умолчанию. Такие определения дают нам возможность определять не все методы класса, а лишь часть основных, а все остальные мы получим автоматически из определений по умолчанию.</p>
<p>Казалось бы почему не оставить в классе <code><font color=Green>Eq</font></code> один метод а другой метод определить в виде отдельной функции:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Eq</font> a <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>==</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>

<font color=Black>(</font><font color=Black>/=</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Eq</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>a</font> <font color=Black>/=</font> b <font color="#b2590f">=</font> not <font color=Black>(</font>a <font color=Black>==</font> b<font color=Black>)</font></pre>
<p>Так не делают по соображениям эффективности. Есть типы для которых проще вычислить <code><font color=Black>/=</font></code> чем <code><font color=Black>==</font></code>. Тогда мы определим тот метод, который нам проще вычислять и второй получим автоматически.</p>
<p>Набор основных методов, через которые определены все остальные называют <em>минимальным полным определением</em> (minimal complete definition) класса. В случае класса <code><font color=Green>Eq</font></code> это метод <code><font color=Black>==</font></code> или метод <code><font color=Black>/=</font></code>.</p>
<p>Мы уже вывели экземпляр для <code><font color=Green>Eq</font></code>, поэтому мы можем пользоваться методами <code><font color=Black>==</font></code> и <code><font color=Black>/=</font></code> для значений типа <code><font color=Green>Num</font></code>:</p>
<pre><font color=Black>*</font><font color=Green>Calendar</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Nat</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Nat</font>              <font color=Black>(</font> <font color=Green>Nat</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Nat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color=Green>Zero</font> <font color=Black>==</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Green>False</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color=Green>Zero</font> <font color=Black>/=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Green>True</font>
<font color=Black>it</font> <font color="#b2590f">::</font> <font color=Green>Bool</font></pre>
<h3 id="класс-num.-сложение-и-умножение"><a href="#TOC">Класс Num. Сложение и умножение</a></h3>
<p>Сложение и умножение определены в классе <code><font color=Green>Num</font></code>. Посмотрим на его определение:</p>
<pre><font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>Num</font>
<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Eq</font> a<font color=Black>,</font> <font color=Green>Show</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Num</font> a <font color="#b2590f">where</font>
  <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  <font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  negate <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a
  abs <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a
  signum <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a
  fromInteger <font color="#b2590f">::</font> <font color=Green>Integer</font> <font color="#b2590f">-&gt;</font> a
  	<font color="#2149c1">-- Defined in GHC.Num</font></pre>
<p>Методы <code><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font></code>, <code><font color=Black>(</font><font color=Black>*</font><font color=Black>)</font></code>, <code><font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font></code> в представлении не нуждаются, метод <code><font color=Black>negate</font></code> является унарным минусом, его можно определить через <code><font color=Black>(</font><font color="#2149c1">-</font><font color=Black>)</font></code> так:</p>
<pre><font color=Black>negate</font> x <font color="#b2590f">=</font> <font color="#0000ee">0</font> <font color="#2149c1">-</font> x</pre>
<p>Метод <code><font color=Black>abs</font></code> является модулем числа, а метод <code><font color=Black>signum</font></code> возвращает знак числа, метод <code><font color=Black>fromInteger</font></code> позволяет создавать значения данного типа из стандартных целых чисел <code><font color=Green>Integer</font></code>.</p>
<p>Этот класс устарел, было бы лучше сделать отельный класс для сложения и вычитания и отдельный класс для умножения. Также контекст класса, часто становится помехой. Есть объекты, которые нет смысла печатать но, есть смысл определить на них сложение и умножение. Но пока в целях совместимости с уже написанным кодом, класс <code><font color=Green>Num</font></code> остаётся прежним.</p>
<p>Определим экземпляр для чисел Пеано, но давайте сначала разберём функции по частям.</p>
<h4 id="сложение"><a href="#TOC">Сложение</a></h4>
<p>Начнём со сложения:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> <font color=Green>Nat</font> <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a <font color=Green>Zero</font>     <font color="#b2590f">=</font> a
    <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font>a <font color=Black>+</font> b<font color=Black>)</font></pre>
<p>Первое уравнение говорит о том, что если второй аргумент равен нулю, то мы вернём первый аргумент в качестве результата. Во втором уравнении мы “перекидываем” конструктор <code><font color=Green>Succ</font></code> из второго аргумента за пределы суммы. Схематически вычисление суммы можно представить так:</p>
<p><span class="LaTeX">$\textbf{3+2} \rightarrow 1+\textbf{(3+1)} \rightarrow 1+(1+\textbf{(3+0)})$</span></p>
<p><span class="LaTeX">$1+(1+\textbf{3}) \rightarrow 1+(1+(1+(1+(1+0)))) \rightarrow 5$</span></p>
<p>Все наши числа имеют вид <span class="LaTeX">$0$</span> или <span class="LaTeX">$1+n$</span>, мы принимаем на вход два числа в таком виде и хотим в результате составить число в этом же виде, для этого мы последовательно перекидываем <span class="LaTeX">$(1+)$</span> в начало выражения из второго аргумента.</p>
<h4 id="вычитание"><a href="#TOC">Вычитание</a></h4>
<p>Операция отрицания не имеет смысла, поэтому мы воспользуемся специальной функцией <code><font color=Black>error</font> <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> a</code>, она принимает строку с сообщением об ошибке, при её вычислении программа остановится с ошибкой и сообщение будет выведено на экран.</p>
<pre>    negate <font color="#b2590f">_</font> <font color="#b2590f">=</font> error <font color=Black>"negate is undefined for Nat"</font></pre>
<h4 id="умножение"><a href="#TOC">Умножение</a></h4>
<p>Теперь посмотрим на умножение:</p>
<pre>    <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> a <font color=Green>Zero</font>     <font color="#b2590f">=</font> <font color=Green>Zero</font>
    <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> a <font color=Black>+</font> <font color=Black>(</font>a <font color=Black>*</font> b<font color=Black>)</font>     </pre>
<p>В первом уравнении мы вернём ноль, если второй аргумент окажется нулём, а во втором мы за каждый конструктор <code><font color=Green>Succ</font></code> во втором аргументе прибавляем к результату первый аргумент. В итоге, после вычисления <code><font color=Black>a</font> <font color=Black>*</font> b</code> мы получим аргумент <code><font color=Black>a</font></code> сложенный <code><font color=Black>b</font></code> раз. Это и есть умножение. При этом мы воспользовались операцией сложения, которую только что определили. Посмотрим на схему вычисления:</p>
<p><span class="LaTeX">$\textbf{3*2} \rightarrow 3+\textbf{(3*1)} \rightarrow 3+(3+\textbf{(3*0)}) \rightarrow 3+\textbf{(3+0)} \rightarrow \textbf{3+3} \rightarrow$</span></p>
<p><span class="LaTeX">$1+\textbf{(3+2)} \rightarrow 1+(1+\textbf{(3+1)}) \rightarrow 1+(1+(1+\textbf{(3+0)})) \rightarrow$</span></p>
<p><span class="LaTeX">$1+(1+1+\textbf{3}) \rightarrow 1+(1+(1+(1+(1+(1+0))))) \rightarrow 6$</span></p>
<h4 id="операции-abs-и-signum"><a href="#TOC">Операции abs и signum</a></h4>
<p>Поскольку числа у нас положительные, то методы <code><font color=Black>abs</font></code> и <code><font color=Black>signum</font></code> почти ничего не делают:</p>
<pre>    abs    x    <font color="#b2590f">=</font> x 
    signum <font color=Green>Zero</font> <font color="#b2590f">=</font> <font color=Green>Zero</font>
    signum <font color="#b2590f">_</font>    <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>Zero</font></pre>
<h4 id="перегрузка-чисел"><a href="#TOC">Перегрузка чисел</a></h4>
<p>Остался последний метод <code><font color=Black>fromInteger</font></code>. Он конструирует значение нашего типа из стандартного:</p>
<pre>    fromInteger <font color="#0000ee">0</font> <font color="#b2590f">=</font> <font color=Green>Zero</font>
    fromInteger n <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font>fromInteger <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Зачем он нужен? Попробуйте узнать тип числа <code><font color="#0000ee">1</font></code> в интерпретаторе:</p>
<pre><font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t <font color="#0000ee">1</font>
<font color="#0000ee">1</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Num</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> t</pre>
<p>Интерпретатор говорит о том, тип значения <code><font color="#0000ee">1</font></code> является некоторым типом из класса <code><font color=Green>Num</font></code>. В Haskell обозначения для чисел перегружены. Когда мы пишем <code><font color="#0000ee">1</font></code> на самом деле мы пишем <code><font color=Black>(</font>fromInteger <font color=Black>(</font><font color="#0000ee">1</font><font color="#b2590f">::</font><font color=Green>Integer</font><font color=Black>)</font><font color=Black>)</font></code>. Поэтому теперь мы можем не писать цепочку <code><font color=Green>Succ</font></code>-ов, а воспользоваться методом <code><font color=Black>fromInteger</font></code>, для этого сохраним определение экземпляра для <code><font color=Green>Num</font></code> и загрузим обновлённый модуль в интерпретатор:</p>
<pre><font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Nat</font>              <font color=Black>(</font> <font color=Green>Nat</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Nat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#0000ee">7</font> <font color="#b2590f">::</font> <font color=Green>Nat</font>
<font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color=Black>(</font><font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Nat</font>
<font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color=Black>*</font> <font color="#0000ee">3</font> <font color="#b2590f">::</font> <font color=Green>Nat</font>
<font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Вы можете убедиться насколько гибкими являются числа в Haskell:</p>
<pre><font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Nat</font>
<font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Double</font>
<font color="#0000ee">2.0</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">1</font>
<font color="#0000ee">2</font></pre>
<p>Мы выписали три одинаковых выражения и получили три разных результата, меняя объявление типов. В последнем выражении тип был приведён к <code><font color=Green>Integer</font></code>. Это поведение интерпретатора по умолчанию. Если мы напишем:</p>
<pre><font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> q <font color="#b2590f">=</font> <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">1</font>
<font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t q
<font color=Black>q</font> <font color="#b2590f">::</font> <font color=Green>Integer</font></pre>
<p>Мы видим, что значение <code><font color=Black>q</font></code> было переведено в <code><font color=Green>Integer</font></code>, это происходит лишь в интерпретаторе, если такая переменная встретится в программе и компилятор не сможет определить её тип из контекста, произойдёт ошибка проверки типов, компилятор скажет, что он не смог определить тип. Помочь компилятору можно, добавив объявление типа с помощью конструкции <code><font color=Black>(</font>v <font color="#b2590f">::</font> <font color=Green>T</font><font color=Black>)</font></code>.</p>
<p>Посмотрим ещё раз на определение экземпляра <code><font color=Green>Num</font></code> для <code><font color=Green>Nat</font></code> целиком:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> <font color=Green>Nat</font> <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a <font color=Green>Zero</font>     <font color="#b2590f">=</font> a
    <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font>a <font color=Black>+</font> b<font color=Black>)</font>

    <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> a <font color=Green>Zero</font>     <font color="#b2590f">=</font> <font color=Green>Zero</font>
    <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> a <font color=Black>(</font><font color=Green>Succ</font> b<font color=Black>)</font> <font color="#b2590f">=</font> a <font color=Black>+</font> <font color=Black>(</font>a <font color=Black>*</font> b<font color=Black>)</font>   

    fromInteger <font color="#0000ee">0</font> <font color="#b2590f">=</font> <font color=Green>Zero</font>
    fromInteger n <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font>fromInteger <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>)</font>

    abs    x    <font color="#b2590f">=</font> x 
    signum <font color=Green>Zero</font> <font color="#b2590f">=</font> <font color=Green>Zero</font>
    signum <font color="#b2590f">_</font>    <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>Zero</font>

    negate <font color="#b2590f">_</font> <font color="#b2590f">=</font> error <font color=Black>"negate is undefined for Nat"</font></pre>
<h3 id="класс-fractional.-деление"><a href="#TOC">Класс Fractional. Деление</a></h3>
<p>Деление определено в классе <code><font color=Green>Fractional</font></code>:</p>
<pre><font color=Black>*</font><font color=Green>Nat</font><font color=Black>&gt;:</font>m <font color=Green>Prelude</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>Fractional</font>
<font color="#b2590f">class</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Fractional</font> a <font color="#b2590f">where</font>
  <font color=Black>(</font><font color=Black>/</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
  recip <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a
  fromRational <font color="#b2590f">::</font> <font color=Green>Rational</font> <font color="#b2590f">-&gt;</font> a
  	<font color="#2149c1">-- Defined in `GHC.Real'</font>
<font color="#b2590f">instance</font> <font color=Green>Fractional</font> <font color=Green>Float</font> <font color="#2149c1">-- Defined in `GHC.Float'</font>
<font color="#b2590f">instance</font> <font color=Green>Fractional</font> <font color=Green>Double</font> <font color="#2149c1">-- Defined in `GHC.Float'</font></pre>
<p>Функция <code><font color=Black>recip</font></code>, это аналог <code><font color=Black>negate</font></code> для <code><font color=Green>Num</font></code>. Она делит единицу на данное число. Функция <code><font color=Black>fromRational</font></code> строит число данного типа из дробного числа. Если мы пишем <code><font color="#0000ee">2</font></code>, то к нему подспудно будет применена функция <code><font color=Black>fromInteger</font></code>, а если <code><font color="#0000ee">2.0</font></code>, то будет применена функция <code><font color=Black>fromRational</font></code>.</p>
<h3 id="стандартные-числа"><a href="#TOC">Стандартные числа</a></h3>
<p>В этом подразделе мы рассмотрим несколько стандартных типов для чисел в Haskell. Все эти числа являются экземплярами основных численных классов. Тех которые мы рассмотрели, и многих-многих других.</p>
<h4 id="целые-числа"><a href="#TOC">Целые числа</a></h4>
<p>В Haskell предусмотрено два типа для целых чисел. Это <code><font color=Green>Integer</font></code> и <code><font color=Green>Int</font></code>. Чем они отличаются? Значения типа <code><font color=Green>Integer</font></code> не ограничены, мы можем проводить вычисления с очень-очень-очень большими числами, если памяти на нашем компьютере хватит. Числа из типа <code><font color=Green>Int</font></code> ограничены. Каждое число занимает определённый размер в памяти компьютера. Диапазон значений для <code><font color=Green>Int</font></code> составляет от <span class="LaTeX">$-2^{29}$</span> до <span class="LaTeX">$2^{29}-1$</span>. Вычисления с <code><font color=Green>Int</font></code> более эффективны.</p>
<h4 id="действительные-числа"><a href="#TOC">Действительные числа</a></h4>
<p> Действительные числа бывают дробными (тип <code><font color=Green>Rational</font></code>), с ординарной точностью <code><font color=Green>Float</font></code> и с двойной точностью <code><font color=Green>Double</font></code>. Числа из типа <code><font color=Green>Float</font></code> занимают меньше места, но они не такие точные как <code><font color=Green>Double</font></code>. Если вы сомневаетесь чем пользоваться, выбирайте <code><font color=Green>Double</font></code>, обычно <code><font color=Green>Float</font></code> используется только там, где необходимо хранить огромные массивы чисел. В этом случае мы экономим много памяти.</p>
<h4 id="преобразование-численных-типов"><a href="#TOC">Преобразование численных типов</a></h4>
<p>Во многих языках программирования при сложении или умножении чисел разных типов проводится автоматическое приведение типов. Обычно целые числа становятся действительными, <code><font color=Green>Float</font></code> превращается в <code><font color=Green>Double</font></code> и так далее. Это противоречит строгой типизации, поэтому в Haskell этого нет:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>(</font><font color="#0000ee">1</font><font color="#b2590f">::</font><font color=Green>Int</font><font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font><font color="#0000ee">1</font><font color="#b2590f">::</font><font color=Green>Double</font><font color=Black>)</font>

<font color=Black>&lt;</font>interactive<font color=Black>&gt;:</font><font color="#0000ee">2</font><font color="#b2590f">:</font><font color="#0000ee">13</font><font color="#b2590f">:</font>
    <font color=Green>Couldn't</font> match expected <font color="#b2590f">type</font> <font color=Black>`</font><font color=Green>Int'</font> with actual <font color="#b2590f">type</font> <font color=Black>`</font><font color=Green>Double'</font>
    <font color=Green>In</font> the second argument <font color="#b2590f">of</font> <font color=Black>`</font><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font><font color=Black>'</font><font color=Black>,</font> namely <font color=Black>`</font><font color=Black>(</font><font color="#0000ee">1</font> <font color="#b2590f">::</font> <font color=Green>Double</font><font color=Black>)</font><font color=Black>'</font>
    <font color=Green>In</font> the expression<font color="#b2590f">:</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color="#b2590f">::</font> <font color=Green>Int</font><font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color="#b2590f">::</font> <font color=Green>Double</font><font color=Black>)</font>
    <font color=Green>In</font> an equation for <font color=Black>`</font>it'<font color="#b2590f">:</font> it <font color="#b2590f">=</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color="#b2590f">::</font> <font color=Green>Int</font><font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font><font color="#0000ee">1</font> <font color="#b2590f">::</font> <font color=Green>Double</font><font color=Black>)</font></pre>
<p>Любое преобразование типов контролируется пользователем. Мы должны вызвать специальную функцию.</p>
<p><strong>От целых к действительным:</strong> Часто возникает необходимость приведения целых чисел к действительным при делении. Для этого можно воспользоваться функцией: <code><font color=Black>fromIntegral</font></code></p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i fromIntegral
<font color=Black>fromIntegral</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Integral</font> a<font color=Black>,</font> <font color=Green>Num</font> b<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b
  	<font color="#2149c1">-- Defined in `GHC.Real'</font></pre>
<p>Определим функцию поиска среднего между двумя целыми числами:</p>
<pre><font color=Black>meanInt</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Black>meanInt</font> a b <font color="#b2590f">=</font> fromIntegral <font color=Black>(</font>a <font color=Black>+</font> b<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font></pre>
<p>В этой функции двойка имеет тип <code><font color=Green>Double</font></code>. Обратите внимание на скобки: составной синоним всегда притягивает аргументы сильнее чем бинарная операция.</p>
<p><strong>От действительных к целым:</strong> В этом нам поможет класс <code><font color=Green>RealFrac</font></code>. Методы говорят сами за себя:</p>
<pre><font color=Green>Prelude</font> <font color=Green>GHC</font><font color=Black>.</font><font color=Green>Float</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>RealFrac</font>
<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Real</font> a<font color=Black>,</font> <font color=Green>Fractional</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>RealFrac</font> a <font color="#b2590f">where</font>
  properFraction <font color="#b2590f">::</font> <font color=Green>Integral</font> b <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> a<font color=Black>)</font>
  truncate <font color="#b2590f">::</font> <font color=Green>Integral</font> b <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b
  round <font color="#b2590f">::</font> <font color=Green>Integral</font> b <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b
  ceiling <font color="#b2590f">::</font> <font color=Green>Integral</font> b <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b
  floor <font color="#b2590f">::</font> <font color=Green>Integral</font> b <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b
  	<font color="#2149c1">-- Defined in `GHC.Real'</font>
<font color="#b2590f">instance</font> <font color=Green>RealFrac</font> <font color=Green>Float</font> <font color="#2149c1">-- Defined in `GHC.Float'</font>
<font color="#b2590f">instance</font> <font color=Green>RealFrac</font> <font color=Green>Double</font> <font color="#2149c1">-- Defined in `GHC.Float'</font></pre>
<p>Метод <code><font color=Black>properFraction</font></code> отделяет целую часть числа от дробной:</p>
<pre><font color=Black>properFraction</font> <font color="#b2590f">::</font> <font color=Green>Integral</font> b <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> a<font color=Black>)</font></pre>
<p>Для того, чтобы вернуть сразу два значения используется кортеж (кортежи пишутся в обычных скобках значения следуют через запятую):</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> properFraction <font color="#0000ee">2.5</font>
<font color=Black>(</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">0.5</font><font color=Black>)</font></pre>
<p> Для пар (кортеж, состоящий из двух элементов) определены две удобные функции извлечения элементов, их смысл можно понять по одним лишь типам:</p>
<pre><font color=Black>fst</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>snd</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> b</pre>
<p>Проверим:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> properFraction <font color="#0000ee">2.5</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Black>(</font>fst x<font color=Black>,</font> snd x<font color=Black>)</font>
<font color=Black>(</font><font color="#0000ee">2</font><font color=Black>,</font> <font color="#0000ee">0.5</font><font color=Black>)</font></pre>
<p>Мы бы и сами могли определить такие функции:</p>
<pre><font color=Black>fst</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>fst</font> <font color=Black>(</font>a<font color=Black>,</font> <font color="#b2590f">_</font><font color=Black>)</font> <font color="#b2590f">=</font> a 

<font color=Black>snd</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> b
<font color=Black>snd</font> <font color=Black>(</font><font color="#b2590f">_</font><font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">=</font> b</pre>
<p><strong>Между действительными числами:</strong> Кто-то написал очень хорошую функцию, но она определена на <code><font color=Green>Double</font></code>, а вам приходится использовать <code><font color=Green>Float</font></code>. Как быть? Нам поможет функция <code><font color=Black>realToFrac</font></code>:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i realToFrac
<font color=Black>realToFrac</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Real</font> a<font color=Black>,</font> <font color=Green>Fractional</font> b<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> b
  	<font color="#2149c1">-- Defined in `GHC.Real'</font></pre>
<p>Она принимает значение из класса <code><font color=Green>Real</font></code> и приводит его к значению, которое можно делить. Что это за класс <code><font color=Green>Real</font></code>? Математики наверное смекнут, что это противоположность комплексным числам (где-то должен быть определён тип или класс <code><font color=Green>Complex</font></code>, и он правда есть, но об этом в следующем разделе). При переходе к комплексным числам мы теряем способность сравнения на больше/меньше, но сохраняем возможность вычисления арифметических операций, поэтому класс <code><font color=Green>Real</font></code> это пересечение классов <code><font color=Green>Num</font></code> и <code><font color=Green>Ord</font></code>:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>i <font color=Green>Real</font>
<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Num</font> a<font color=Black>,</font> <font color=Green>Ord</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Real</font> a <font color="#b2590f">where</font>
  toRational <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Rational</font></pre>
<p>Здесь “пересечение” означает “и тот и другой”. Пересечение классов кодируется с помощью контекста. Вернёмся к нашему первому примеру:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> realToFrac <font color=Black>(</font><font color="#0000ee">1</font><font color="#b2590f">::</font><font color=Green>Float</font><font color=Black>)</font> <font color=Black>+</font> <font color=Black>(</font><font color="#0000ee">1</font><font color="#b2590f">::</font><font color=Green>Double</font><font color=Black>)</font>
<font color="#0000ee">2.0</font></pre>
<p>Отметим, что этой функцией можно пользоваться не только для типов <code><font color=Green>Float</font></code> и <code><font color=Green>Double</font></code>, в Haskell возможны самые экзотические числа.</p>
<p>Если преобразования между <code><font color=Green>Float</font></code> и <code><font color=Green>Double</font></code> происходят очень-очень часто, возможно имеет смысл воспользоваться специальными для <code><font color=Green>GHC</font></code> функциями: Они определены в модуле <code><font color=Green>GHC</font><font color=Black>.</font><font color=Green>Float</font></code>:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Black>+</font><font color=Green>GHC</font><font color=Black>.</font><font color=Green>Float</font>
<font color=Green>Prelude</font> <font color=Green>GHC</font><font color=Black>.</font><font color=Green>Float</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t float2Double
<font color=Black>float2Double</font> <font color="#b2590f">::</font> <font color=Green>Float</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Green>Prelude</font> <font color=Green>GHC</font><font color=Black>.</font><font color=Green>Float</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t double2float
<font color=Black>double2Float</font> <font color="#b2590f">::</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>Float</font></pre>
<h2 id="документация"><a href="#TOC">Документация</a></h2>
<p>К этой главе мы уже рассмотрели основные конструкции языка и базовые типы. Если у вас есть какая-то задача, вы уже можете начать её решать. Для этого сначала нужно будет описать в типах проблему, затем выразить с помощью функций её решение.</p>
<p>Но не стоит писать все функции самостоятельно, если функция достаточно общая её наверняка кто-нибудь уже написал. Самые полезные функции и классы определены в модуле <code><font color=Green>Prelude</font></code> и основных стандартных библиотечных модулях. Было бы излишним описывать каждую функцию, книга превратилась бы в справочник. Вместо этого давайте научимся искать функции в документации. Нам понадобится умение составлять типы функций и небольшое знание английского языка.</p>
<p>Для начала о том, где находится документация к стандартным модулям. Если вы установили <code><font color=Black>ghc</font></code> вместе с <code><font color=Green>Haskell</font> <font color=Green>Platform</font></code> под Windows скорее всего во вкладке <code><font color=Green>Пуск</font></code>, там где иконка <code><font color=Black>ghc</font></code> там же находится и документация. В Linux необходимо найти директорию с документацией, скорее всего она в директории <code><font color=Black>/</font>usr<font color=Black>/</font>local<font color=Black>/</font>share<font color=Black>/</font>doc<font color=Black>/</font>ghc<font color=Black>/</font>libraries</code>. Также документацию можно найти в интернете, наберите в поисковике Haskell Hierarchical Libraries. На главной странице документации вы найдёте огромное количество модулей. Нас пока интересуют разделы <code><font color=Green>Data</font></code> и <code><font color=Green>Prelude</font></code>. Разделы расположены по алфавиту. То что вы видите это стандартный вид документации в Haskell. Документация делается с помощью специального приложения <code><font color=Green>Haddock</font></code>, мы тоже научимся такие делать, но позже, пока мы попробуем разобраться с тем как искать в документации функции.</p>
<p>Предположим нам нужно вычислить длину списка. Нам нужна функция, которая принимает список и возвращает целое число, скорее всего её тип <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font></code>, обычно во всех библиотечных функциях для целых чисел используется тип <code><font color=Green>Int</font></code>, также на месте параметра используются буквы <code><font color=Black>a</font></code>, <code><font color=Black>b</font></code>, <code><font color=Black>c</font></code>. Мы можем открыть документацию к <code><font color=Green>Prelude</font></code> набрать в строке поиска тип <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font></code>. Или поискать такую функцию в разделе функций для списков <code><font color=Green>List</font> <font color=Green>Operations</font></code>. Тогда мы увидим единственную функцию с таким типом, под говорящим именем <code><font color=Black>length</font></code>. Так мы нашли то, что искали.</p>
<p>Или мы ищем функцию, которая переворачивает список, нам нужна функция с типом <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></code>. Таких функций в <code><font color=Green>Prelude</font></code> несколько, но имя <code><font color=Black>reverse</font></code> одной из них может намекнуть на её смысл.</p>
<p>Но одной <code><font color=Green>Prelude</font></code> мир стандартных функций Haskell не ограничивается, если вы не нашли необходимую вам функцию в <code><font color=Green>Prelude</font></code> её стоит поискать в других библиотечных модулях. Обычно функции разделяются по тому на каких типах они определены. Так например функция <code><font color=Black>sort</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></code> определена не в <code><font color=Green>Prelude</font></code>, а в отдельном библиотечном модуле для списков он называется <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code>. Так же есть много других модулей для разных типов, таких как <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Bool</font></code>, <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Char</font></code>, <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font></code>, <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Maybe</font></code> и многие другие. Не пугайтесь изобилия модулей постепенно они станут вашей опорой.</p>
<p>Для поиска в стандартных библиотеках есть замечательный интернет-сервис Hoogle (<a href="http://www.haskell.org/hoogle/"><code class="url">http://www.haskell.org/hoogle/</code></a>). Hoogle может искать значения не только по имени, но и по типам. Например мы хотим узнать целочисленный код символа. Поиск по типу <code><font color=Green>Char</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font></code> выдаёт искомую функцию <code><font color=Black>digitToInt</font></code>.</p>
<h2 id="краткое-содержание"><a href="#TOC">Краткое содержание</a></h2>
<p>В этой главе мы познакомились с интерпретатором <code><font color=Black>ghci</font></code> и основными типами. Рассмотрели много примеров.</p>
<h4 id="типы"><a href="#TOC">Типы</a></h4>
<table>
<tbody>
<tr class="odd">
<td align="left"><code><font color=Green>Bool</font></code></td>
<td align="left"></td>
<td align="left">Основные операции: <code><font color=Black>&amp;&amp;</font></code>, <code><font color=Black>||</font></code>, <code><font color=Black>not</font></code>, <code><font color="#b2590f">if</font> c <font color="#b2590f">then</font> t <font color="#b2590f">else</font> e</code></td>
</tr>
<tr class="even">
<td align="left"><code><font color=Green>Char</font></code></td>
<td align="left"></td>
<td align="left">Значения пишутся в ординарных кавычках, как в <code><font color=Black>'H'</font></code>, <code><font color=Black>'+'</font></code></td>
</tr>
<tr class="odd">
<td align="left"><code><font color=Green>String</font></code></td>
<td align="left"></td>
<td align="left">Значения пишутся в двойных кавычках, как в <code><font color=Black>"Hello World"</font></code></td>
</tr>
<tr class="even">
<td align="left"><code><font color=Green>Int</font></code></td>
<td align="left"></td>
<td align="left">Эффективные целые числа, но ограниченные</td>
</tr>
<tr class="odd">
<td align="left"><code><font color=Green>Integer</font></code></td>
<td align="left"></td>
<td align="left">Не ограниченные целые числа, но не эффективные</td>
</tr>
<tr class="even">
<td align="left"><code><font color=Green>Double</font></code></td>
<td align="left"></td>
<td align="left">Числа с двойной точностью</td>
</tr>
<tr class="odd">
<td align="left"><code><font color=Green>Float</font></code></td>
<td align="left"></td>
<td align="left">Числа с ординарной точностью</td>
</tr>
<tr class="even">
<td align="left"><code><font color=Green>Rational</font></code></td>
<td align="left"></td>
<td align="left">Дробные числа</td>
</tr>
</tbody>
</table>
<p>Нам впервые встретились кортежи (на функции <code><font color=Black>properFraction</font></code>). Кортежи используются для возвращения из функции нескольких значений. Элементы кортежа могут иметь разные типы. Для извлечения элементов из кортежей-пар используются функции <code><font color=Black>fst</font></code> и <code><font color=Black>snd</font></code>. Кортежи пишутся в скобках, и элементы разделены запятыми:</p>
<pre><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font>
<font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>,</font> c<font color=Black>)</font>
<font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>,</font> c<font color=Black>,</font> d<font color=Black>)</font>
<font color=Black>...</font></pre>
<h4 id="классы"><a href="#TOC">Классы</a></h4>
<table>
<tbody>
<tr class="odd">
<td align="left"><code><font color=Green>Show</font></code></td>
<td align="left">Печать</td>
</tr>
<tr class="even">
<td align="left"><code><font color=Green>Eq</font></code></td>
<td align="left">Сравнение на равенство</td>
</tr>
<tr class="odd">
<td align="left"><code><font color=Green>Num</font></code></td>
<td align="left">Сложение и умножение</td>
</tr>
<tr class="even">
<td align="left"><code><font color=Green>Fractional</font></code></td>
<td align="left">Деление</td>
</tr>
</tbody>
</table>
<h4 id="особенности-синтаксиса"><a href="#TOC">Особенности синтаксиса</a></h4>
<p>Запись применения функции:</p>
<table>
<col width="21%" />
<col width="23%" />
<thead>
<tr class="header">
<th align="left">Префиксная</th>
<th align="left">Инфиксная</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code><font color=Black>add</font> a b</code></td>
<td align="left"><code><font color=Black>a</font> <font color=Black>`add`</font> b</code></td>
</tr>
<tr class="even">
<td align="left"><code><font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a b</code></td>
<td align="left"><code><font color=Black>a</font> <font color=Black>+</font> b</code></td>
</tr>
</tbody>
</table>
<p>Также мы научились приводить одни численные типы к другим и пользоваться документацией.</p>
<h2 id="упражнения"><a href="#TOC">Упражнения</a></h2>
<ul>
<li><p>Напишите функцию <code><font color=Black>beside</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font></code>, которая будет возвращать <code><font color=Green>True</font></code> только в том случае, если два аргумента находятся рядом, т.е.~один из них можно получить через другой операцией <code><font color=Green>Succ</font></code>.</p></li>
<li><p>Напишите функцию <code><font color=Black>beside2</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font></code>, которая будет возвращать <code><font color=Green>True</font></code> только если аргументы являются соседями через некоторое другое число.</p></li>
<li><p>Мы написали очень не эффективную функцию сложения натуральных чисел. Проблема в том, что число рекурсивных вызовов функции зависит от величины первого аргумента. Если мы захотим прибавить единицу к сотне, то порядок следования аргументов существенно повлияет на скорость вычисления. Напишите функцию, которая лишена этого недостатка.</p></li>
<li><p>Напишите функцию возведения в степень <code><font color=Black>pow</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font></code>.</p></li>
<li><p>Напишите тип, описывающий бинарные деревья <code><font color=Green>BinTree</font> a</code>. Бинарное дерево может быть либо листом со значением типа <code><font color=Black>a</font></code>, либо хранить два поддерева.</p></li>
<li><p>Напишите функцию <code><font color=Black>reverse</font> <font color="#b2590f">::</font> <font color=Green>BinTree</font> a <font color="#b2590f">-&gt;</font> <font color=Green>BinTree</font> a</code>, которая переворачивает дерево. Она меняет местами два элемента в узле дерева.</p></li>
<li><p>Напишите функцию <code><font color=Black>depth</font> <font color="#b2590f">::</font> <font color=Green>BinTree</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font></code>, которая вычисляет глубину дерева, т.е.~самый длинный путь от корня дерева к листу.</p></li>
<li><p>Напишите функцию <code><font color=Black>leaves</font> <font color="#b2590f">::</font> <font color=Green>BinTree</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></code>, которая переводит бинарное дерево в список, возвращая все элементы в листьях дерева.</p></li>
<li><p>Обратите внимание на раздел <code><font color=Green>List</font> <font color=Green>Operations</font></code> в <code><font color=Green>Prelude</font></code>. Посмотрите на функции и их типы. Попробуйте догадаться по типу функции и названию что она делает.</p></li>
<li><p>Попробуйте разобраться по документации с классами <code><font color=Green>Ord</font></code> (сравнение на больше/меньше), <code><font color=Green>Enum</font></code> (перечисления) и <code><font color=Green>Integral</font></code> (целые числа). Также стоит отметить класс <code><font color=Green>Floating</font></code>. Если у вас не получится, не беда, они обязательно встретятся нам вновь. Там и разберёмся.</p></li>
<li><p>Найдите функцию, которая переставляет элементы пары местами (элементы могут быть разных типов).<br /> Потренируйтесь с кортежами. Определите аналоги функций <code><font color=Black>fst</font></code> и <code><font color=Black>snd</font></code> для не пар. Обратите внимание на то, что сочетание символов <code><font color=Green>(,)</font></code> это функция-конструктор пары:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color=Green>(,)</font> <font color=Black>"Hi"</font> <font color="#0000ee">101</font>
<font color=Black>(</font><font color=Black>"Hi"</font><font color=Black>,</font><font color="#0000ee">101</font><font color=Black>)</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t <font color=Green>(,)</font>
<font color=Green>(,)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font></pre>
<p>Также определены <code><font color=Green>(,,)</font></code>, <code><font color=Green>(,,,)</font></code> и другие.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="1.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="3.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol style="list-style-type: decimal">
<li>Основы
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="3" style="list-style-type: decimal">
<li>Типы
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
