<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="./style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#музыкальный-пример">Музыкальный пример</a><ul>
<li><a href="#музыкальная-нотация">Музыкальная нотация</a><ul>
<li><a href="#нотная-запись-в-европейской-традиции">Нотная запись в европейской традиции</a></li>
<li><a href="#протокол-midi">Протокол midi</a></li>
</ul></li>
<li><a href="#музыкальная-запись-в-виде-событий">Музыкальная запись в виде событий</a><ul>
<li><a href="#преобразование-событий-во-времени">Преобразование событий во времени</a><ul>
<li><a href="#класс-преобразований-во-времени">Класс преобразований во времени</a></li>
</ul></li>
<li><a href="#композиция-треков">Композиция треков</a></li>
<li><a href="#экземпляры-стандартных-классов">Экземпляры стандартных классов</a></li>
</ul></li>
<li><a href="#ноты-в-midi">Ноты в midi</a><ul>
<li><a href="#синонимы-для-нот">Синонимы для нот</a><ul>
<li><a href="#высота-ноты">Высота ноты</a></li>
<li><a href="#длительность-ноты">Длительность ноты</a></li>
<li><a href="#громкость-ноты">Громкость ноты</a></li>
<li><a href="#смена-инструмента">Смена инструмента</a></li>
<li><a href="#паузы">Паузы</a></li>
</ul></li>
</ul></li>
<li><a href="#перевод-в-midi">Перевод в midi</a></li>
<li><a href="#пример">Пример</a></li>
<li><a href="#эффективное-представление-музыкальной-нотации">Эффективное представление музыкальной нотации</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="20.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="appendix.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="музыкальный-пример"><a href="#TOC">Музыкальный пример</a></h1>
<p>В этой главе мы напишем музыкальный секвенсор. Мы будем переводить нотную запись в midi-файл с помощью библиотеки <code><font color=Green>HCodecs</font></code>. Она предоставляет возможность создания midi-файлов по описанию в Haskell. При этом описание напоминает описание самого формата midi. Мы же хотим подняться уровнем выше и описывать музыку нотами и композицией нот.</p>
<h2 id="музыкальная-нотация"><a href="#TOC">Музыкальная нотация</a></h2>
<p>Для начала зададимся выясним: а что же такое музыка с точки зрения нашего секвенсора? Мы ищем представление музыки, термины, в которых было бы удобно мыслить композитору. При этом необходимо понимать, что наш поиск ограничен средствами низкоуровневого представления музыки. В нашем случае это midi-файл. Так например мы можем сразу отбросить представление в виде сигналов, последовательности сэмплов, поскольку мы не сможем реализовать это представление в рамках midi. За ответом обратимся к истории.</p>
<h3 id="нотная-запись-в-европейской-традиции"><a href="#TOC">Нотная запись в европейской традиции</a></h3>
<p>В европейской традиции принято описывать музыку в виде нотной записи. Нотный лист состоит из серии нотных станов. Нотный стан состоит из пяти линеек. Каждая линейка обозначает определённую высоту. Нота состоит из обозначения длительности и высоты. Разные длительности обозначаются штрихами и цветом ноты, а высоте соответствует расположение на нотном стане.</p>
<div class="figure">
<img src="../pic/21/notes.jpg" alt="Буквенные обозначения высоты ноты" /><p class="caption">Буквенные обозначения высоты ноты</p>
</div>
<p>По длительности ноты различают на: целые, половины, четверти, восьмые, шестнадцатые и так далее. Каждая последующая длительность в два раза меньше предыдущей. Длительность измеряется в долях от такта. Такты обозначаются сплошной линией, которая перечёркивает все пять линеек нотного стана. По высоте ноты, зависят от двух целых чисел, это номер октавы и номер ступени лада. В ладе обычно всего 12 ступеней. Их обозначают разными именами. Например в латинской нотации их обозначают так:</p>
<!-- Switch arguments separator to ? instead of | -->




<table>
<col width="6%" />
<col width="8%" />
<col width="7%" />
<col width="8%" />
<col width="7%" />
<col width="7%" />
<col width="8%" />
<col width="7%" />
<col width="8%" />
<col width="7%" />
<col width="8%" />
<col width="8%" />
<thead>
<tr class="header">
<th align="left">0</th>
<th align="left">1</th>
<th align="left">2</th>
<th align="left">3</th>
<th align="left">4</th>
<th align="left">5</th>
<th align="left">6</th>
<th align="left">7</th>
<th align="left">8</th>
<th align="left">9</th>
<th align="left">10</th>
<th align="left">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$C$</span></td>
<td align="left"><span class="LaTeX">$C#$</span></td>
<td align="left"><span class="LaTeX">$D$</span></td>
<td align="left"><span class="LaTeX">$D#$</span></td>
<td align="left"><span class="LaTeX">$E$</span></td>
<td align="left"><span class="LaTeX">$F$</span></td>
<td align="left"><span class="LaTeX">$F#$</span></td>
<td align="left"><span class="LaTeX">$G$</span></td>
<td align="left"><span class="LaTeX">$G#$</span></td>
<td align="left"><span class="LaTeX">$A$</span></td>
<td align="left"><span class="LaTeX">$A#$</span></td>
<td align="left"><span class="LaTeX">$B$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$C$</span></td>
<td align="left"><span class="LaTeX">$Db$</span></td>
<td align="left"><span class="LaTeX">$D$</span></td>
<td align="left"><span class="LaTeX">$Eb$</span></td>
<td align="left"><span class="LaTeX">$E$</span></td>
<td align="left"><span class="LaTeX">$F$</span></td>
<td align="left"><span class="LaTeX">$Gb$</span></td>
<td align="left"><span class="LaTeX">$G$</span></td>
<td align="left"><span class="LaTeX">$Ab$</span></td>
<td align="left"><span class="LaTeX">$A$</span></td>
<td align="left"><span class="LaTeX">$Bb$</span></td>
<td align="left"><span class="LaTeX">$B$</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="LaTeX">$do$</span></td>
<td align="left">
</td>
<td align="left"><span class="LaTeX">$re$</span></td>
<td align="left">
</td>
<td align="left"><span class="LaTeX">$mi$</span></td>
<td align="left"><span class="LaTeX">$fa$</span></td>
<td align="left">
</td>
<td align="left"><span class="LaTeX">$sol$</span></td>
<td align="left">
</td>
<td align="left"><span class="LaTeX">$la$</span></td>
<td align="left">
</td>
<td align="left"><span class="LaTeX">$ti$</span></td>
</tr>
</tbody>
</table>
<p>В самом нижнем ряду расположены имена нот. Во втором и четвёртом – обозначения нот с диезами и с бемолями. Одна и та же нота может обозначаться по-разному. Буквами обозначают ноты тональности до мажор (это семь букв для семи нот), а остальные ноты получают повышением на один шаг с помощью знака диез <span class="LaTeX">$#$</span> или понижением на один шаг с помощью знака бемоль <span class="LaTeX">$b$</span>.</p>
<p>Также ноты различают по громкости. В европейской традиции считается, что громкость изменяется не часто в сравнении с высотой и длительностью, поэтому для обозначения громкости введены специальные символы, которые пишутся под нотным станом, только когда громкость изменяется.</p>
<p>Из этого обзора мы поняли, что единицей музыкальной записи является нота, она состоит из обозначения длительности, высоты и громкости. Высота в свою очередь состоит из обозначения октавы и ступени лада. Теперь давайте посмотрим крупным планом на протокол <code><font color=Black>midi</font></code>.</p>
<h3 id="протокол-midi"><a href="#TOC">Протокол midi</a></h3>
<p>Протокол midi появился в ответ на бурное развитие синтезаторов. Каждый из синтезаторов предлагал свои тембры, при этом люди задумались, а нужна ли синтезатору клавиатура? Вопрос кажется абсурдным, если мы думаем об одном синтезаторе, но представьте, что у вас их десять, в каждом свой чем-то особенный тембр. При этом нам нужно десять разных тембров, но мы вынужденны таскать за собой десять примерно одинаковых клавиатур. Для того чтобы отделить тембр от управления (нажатия на клавиши игроком) был придуман протокол midi. Протокол midi описывает специфическую для нажатия на клавиши информацию. Производители тембров или генераторов тона, могут научить генератор тона понимать midi. При этом мы можем сделать отдельную клавиатуру, которая не имеет собственного генератора тона, но умеет посылать сообщения протокола midi, так мы сможем управлять десятью генераторами тона от разных производителей с помощью одной клавиатуры. Такие клавиатуры называют midi-клавиатурами.</p>
<p>Познакомимся с терминологией midi. Протокол midi рассчитан на управление синтезаторами в режиме реального времени. Можно сказать, что midi-файл – это история концерта или выступления, низкоуровневая нотная запись. Каждое движение игрока кодируется событием. Например нажатие на клавишу, отпускание клавиши, сила давления на клавишу в определённый момент времени, нажатие педали, поворот реле или смена тэмбра.</p>
<p>Протокол midi изначально задумывался как расширяемый протокол. Каждый производитель тембров имеет возможность добавить какие-то особенные настройки. При этом те сообщения, которые данный генератор тона не понимает просто игнорируются. Наш секвенсор будет понимать такие события как нажатие на клавишу и отпускание клавиши. Также у нас будут разные инструменты.</p>
<p>Установим библиотеку <code><font color=Green>HCodecs</font></code> с <code><font color=Green>Hackage</font></code>:</p>
<pre><font color=Black>cabal</font> install <font color=Green>HCodecs</font></pre>
<p>Теперь заглянем на страницу документации этого пакета (на сайте Hackage), нас интересует модуль <code><font color=Green>Codec</font><font color=Black>.</font><font color=Green>Midi</font></code>, ведь мы хотим создавать именно midi-файлы. Здесь мы видим описание протокола midi, закодированное в типах. Посмотрим на тип <code><font color=Green>Message</font></code>, он описывает midi-сообщения. В первую очередь нас интересуют конструкторы:</p>
<pre><font color=Green>NoteOn</font> <font color=Black>{</font>
    channel  <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Channel</font><font color=Black>,</font>
    key      <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Key</font><font color=Black>,</font>
    velocity <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Velocity</font> <font color=Black>}</font>

<font color=Green>NoteOff</font>	<font color=Black>{</font>
    channel  <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Channel</font><font color=Black>,</font>
    key      <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Key</font><font color=Black>,</font>
    velocity <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Velocity</font> <font color=Black>}</font></pre>
<p>Восклицательные знаки перед типами означают взрывные шаблоны, о которых мы говорили в главах о ленивых вычислениях. Конструктор <code><font color=Green>NoteOn</font></code> обозначает нажатие клавиши на канале <code><font color=Green>Channel</font></code> с высотой <code><font color=Green>Key</font></code> и уровнем громкости <code><font color=Green>Velocity</font></code>. Конструктор <code><font color=Green>NoteOff</font></code> обозначает отпускание клавиши, параметры имеют тот же смысл, что и в случае <code><font color=Green>NoteOn</font></code>.</p>
<p>Думаю что такое высота и громкость примерно понятно, но что такое канал? Считается, что один исполнитель может управлять сразу несколькими генераторами тона. Управление распределяется по каналам. На каждом канале мы можем управлять отдельным инструментом. Немного о высоте и громкости. Они кодируются целыми числами из диапазона от 0 до 127. Ноте до первой октавы (<span class="LaTeX">$C$</span>) соответствует цифра 60, ноте ля первой октавы (<span class="LaTeX">$A$</span>) соответствует номер 69. Одно число кодирует сразу и октаву и ступень лада.</p>
<p>Может показаться странным параметр <code><font color=Green>Velocity</font></code> в конструкторе <code><font color=Green>NoteOff</font></code>, он обозначает отпускание клавиши с определённой громкостью. Обычно этот параметр игнорируется и в него записывают среднее значение 64 или начальное значение 0.</p>
<p>Также мы будем играть разными инструментами. Инструменты в протоколе midi называются программами. Мы можем установить определённый инструмент на данном канале с помощью сообщения:</p>
<pre><font color=Green>ProgramChange</font> <font color=Black>{</font>
    channel <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Channel</font><font color=Black>,</font>
    preset  <font color="#b2590f">::</font> <font color=Black>!</font><font color=Green>Preset</font> <font color=Black>}</font></pre>
<p>Целое число <code><font color=Green>Preset</font></code> указывает на код инструмента. Теперь посмотрим, что же такое midi-файл:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Midi</font> <font color="#b2590f">=</font> <font color=Green>Midi</font> <font color=Black>{</font>
    fileType <font color="#b2590f">::</font> <font color=Green>FileType</font><font color=Black>,</font>
    timeDiv  <font color="#b2590f">::</font> <font color=Green>TimeDiv</font><font color=Black>,</font>
    tracks   <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Track</font> <font color=Green>Ticks</font><font color="#b2590f">]</font> <font color=Black>}</font></pre>
<p>midi-файл состоит из трёх значений. Это обозначение типа файла:</p>
<pre><font color="#b2590f">data</font> <font color=Green>FileType</font> <font color="#b2590f">=</font> <font color=Green>SingleTrack</font> <font color="#b2590f">|</font> <font color=Green>MultiTrack</font> <font color="#b2590f">|</font> <font color=Green>MultiPattern</font></pre>
<p>По типу midi-файлы могут различаться на файлы с одним треком, файлы с несколькими треками, и файлы, которые содержат группы треков, которые называют узорами (pattern). По смыслу трек соответствует партии инструмента.</p>
<p>Тип <code><font color=Green>TimeDiv</font></code> кодирует скорость записи сообщений. Различают два варианта:</p>
<pre><font color="#b2590f">data</font> <font color=Green>TimeDive</font> <font color="#b2590f">=</font> <font color=Green>TicksPerBeat</font> <font color=Green>Int</font> 
              <font color="#b2590f">|</font> <font color=Green>TicksPerSecond</font> <font color=Green>Int</font> <font color=Green>Int</font></pre>
<p>Первый конструктор говорит о том, что разрешение времени закодировано в формате PPQN, он указывает на число ударов в одной четвертной длительности. Второй конструктор говорит о том, что разрешение кодируется в формате SMPTE, оно указывает на число кадров в секунде.</p>
<p>Теперь посмотрим, что такое трек:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Track</font> a <font color="#b2590f">=</font> <font color="#b2590f">[</font><font color=Black>(</font>a<font color=Black>,</font> <font color=Green>Message</font><font color=Black>)</font><font color="#b2590f">]</font></pre>
<p>Трек это список событий с временными отсчётами. Время в midi отсчитывается относительно предыдущего события. Например в следующей записи три события произошли одновременно и затем спустя 10 тактов произошли ещё два события:</p>
<pre><font color="#b2590f">[</font><font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> e1<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> e2<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> e3<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">10</font><font color=Black>,</font> e4<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> e5<font color=Black>)</font><font color="#b2590f">]</font></pre>
<h2 id="музыкальная-запись-в-виде-событий"><a href="#TOC">Музыкальная запись в виде событий</a></h2>
<p>Писать музыку в виде событий midi очень неудобно, пусть даже и через <code><font color=Green>HCodecs</font></code>, необходимо придумать надстройку над протоколом midi. Я долго думал об этом и в итоге пришёл к выводу, что наиболее простой и податливый способ представления музыки на нотном уровне реализован в языке Csound. Там ноты представлены в виде последовательности событий. Каждое событие начинается в определённый момент и длится некоторое время. Событие содержит код инструмента и набор параметров, которые могут включать в себя громкость, высоту звука и какие-то специфические для данного инструмента настройки. Обязательными параметрами события являются лишь номер инструмента, который играет ноту, начало события и длительность события. Мы ослабим эти ограничения. Событие будет содержать лишь время начала, длительность и некоторое содержание.</p>
<pre><font color="#b2590f">data</font> <font color=Green>Event</font> t a <font color="#b2590f">=</font> <font color=Green>Event</font> <font color=Black>{</font>
    eventStart      <font color="#b2590f">::</font> t<font color=Black>,</font>
    eventDur        <font color="#b2590f">::</font> t<font color=Black>,</font>
    eventContent    <font color="#b2590f">::</font> a
    <font color=Black>}</font> <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font></pre>
<p>Параметр <code><font color=Black>t</font></code> символизирует время, а параметр <code><font color=Black>a</font></code> – некоторое содержание события. Мы будем говорить, что в некоторый момент времени произошло значение типа <code><font color=Black>a</font></code> и оно длилось некоторое время. Треком мы будем называть набор событий, которые длятся определённой время:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Track</font> t a <font color="#b2590f">=</font> <font color=Green>Track</font> <font color=Black>{</font>
    trackDur        <font color="#b2590f">::</font> t<font color=Black>,</font>
    trackEvents     <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Event</font> t a<font color="#b2590f">]</font> 
    <font color=Black>}</font> </pre>
<p>Первый параметр указывает на общую длительность трека, а второй содержит события, которые произошли. Мы явно указываем длительность трека для того, чтобы иметь возможность представить тишину. Значение тишины будет выглядеть так:</p>
<pre><font color=Black>silence</font> t <font color="#b2590f">=</font> <font color=Green>Track</font> t <font color=Green>[]</font></pre>
<p>Этим мы говорим, что ничего не произошло в течение <code><font color=Black>t</font></code> единиц времени.</p>
<h3 id="преобразование-событий-во-времени"><a href="#TOC">Преобразование событий во времени</a></h3>
<p>Наши события привязаны ко времени. Мы можем ввести линейные операции, которые будут изменять расположение событий во времени. Самый простой способ изменения положения это задержка. Мы можем задержать появление события, прибавив какое-нибудь число ко времени начала события:</p>
<pre><font color=Black>delayEvent</font> <font color="#b2590f">::</font> <font color=Green>Num</font> t <font color="#b2590f">=&gt;</font> t <font color="#b2590f">-&gt;</font> <font color=Green>Event</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Event</font> t a
<font color=Black>delayEvent</font> d e <font color="#b2590f">=</font> e<font color=Black>{</font> eventStart <font color="#b2590f">=</font> d <font color=Black>+</font> eventStart e <font color=Black>}</font></pre>
<p>Ещё одно простое преобразование заключается в изменении масштаба времени, в музыке или анимации этой операции соответствует перемотка. Событие начинает происходить быстрее или медленнее:</p>
<pre><font color=Black>stretchEvent</font> <font color="#b2590f">::</font> <font color=Green>Num</font> t <font color="#b2590f">=&gt;</font> t <font color="#b2590f">-&gt;</font> <font color=Green>Event</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Event</font> t a
<font color=Black>stretchEvent</font> s e <font color="#b2590f">=</font> e<font color=Black>{</font> 
    eventStart  <font color="#b2590f">=</font> s <font color=Black>*</font> eventStart e<font color=Black>,</font> 
    eventDur    <font color="#b2590f">=</font> s <font color=Black>*</font> eventDur   e <font color=Black>}</font></pre>
<p>Для изменения масштаба времени мы умножили временные параметры на число <code><font color=Black>s</font></code>. Эти операции мы можем перенести и на значения типа <code><font color=Green>Track</font></code>.</p>
<pre><font color=Black>delayTrack</font> <font color="#b2590f">::</font> <font color=Green>Num</font> t <font color="#b2590f">=&gt;</font> t <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Black>delayTrack</font> d <font color=Black>(</font><font color=Green>Track</font> t es<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Track</font> <font color=Black>(</font>t <font color=Black>+</font> d<font color=Black>)</font> <font color=Black>(</font>map <font color=Black>(</font>delayEvent d<font color=Black>)</font> es<font color=Black>)</font> 

<font color=Black>stretchTrack</font> <font color="#b2590f">::</font> <font color=Green>Num</font> t <font color="#b2590f">=&gt;</font> t <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Black>stretchTrack</font> s <font color=Black>(</font><font color=Green>Track</font> t es<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Track</font> <font color=Black>(</font>t <font color=Black>*</font> s<font color=Black>)</font> <font color=Black>(</font>map <font color=Black>(</font>stretchEvent s<font color=Black>)</font> es<font color=Black>)</font> </pre>
<h4 id="класс-преобразований-во-времени"><a href="#TOC">Класс преобразований во времени</a></h4>
<p>У нас есть аналогичные операции преобразования во времени для событий и треков, это говорит о том, что мы можем ввести специальный класс, который объединит в себе эти операции. Назовём его классом <code><font color=Green>Temporal</font></code> (временн<em>о</em>й):</p>
<pre><font color="#b2590f">class</font> <font color=Green>Temporal</font> a <font color="#b2590f">where</font>
    <font color="#b2590f">type</font> <font color=Green>Dur</font> a <font color="#b2590f">::</font> <font color=Black>*</font>
    dur     <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Dur</font> a
    delay   <font color="#b2590f">::</font> <font color=Green>Dur</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a
    stretch <font color="#b2590f">::</font> <font color=Green>Dur</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a</pre>
<p>В этом классе определён один тип, который обозначает размерность времени, и три метода в дополнении к методам <code><font color=Black>delay</font></code> и <code><font color=Black>stretch</font></code> мы добавим метод <code><font color=Black>dur</font></code>, мы будем считать, что всё что происходит во времени конечно и с помощью метода <code><font color=Black>dur</font></code> мы всегда можем узнать протяжённость значения их класса <code><font color=Green>Temporal</font></code> во времени. Для определения этого класса нам придётся подключить расширение <code><font color=Green>TypeFamilies</font></code>. Теперь мы легко можем определить экземпляры класса <code><font color=Green>Temporal</font></code> для <code><font color=Green>Event</font></code> и <code><font color=Green>Track</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> t <font color="#b2590f">=&gt;</font> <font color=Green>Temporal</font> <font color=Black>(</font><font color=Green>Event</font> t a<font color=Black>)</font> <font color="#b2590f">where</font>
    <font color="#b2590f">type</font> <font color=Green>Dur</font> <font color=Black>(</font><font color=Green>Event</font> t a<font color=Black>)</font> <font color="#b2590f">=</font> t
    dur     <font color="#b2590f">=</font> eventDur
    delay   <font color="#b2590f">=</font> delayEvent
    stretch <font color="#b2590f">=</font> stretchEvent

<font color="#b2590f">instance</font> <font color=Green>Num</font> t <font color="#b2590f">=&gt;</font> <font color=Green>Temporal</font> <font color=Black>(</font><font color=Green>Track</font> t a<font color=Black>)</font> <font color="#b2590f">where</font>
    <font color="#b2590f">type</font> <font color=Green>Dur</font> <font color=Black>(</font><font color=Green>Track</font> t a<font color=Black>)</font> <font color="#b2590f">=</font> t
    dur     <font color="#b2590f">=</font> trackDur
    delay   <font color="#b2590f">=</font> delayTrack
    stretch <font color="#b2590f">=</font> stretchTrack    </pre>
<h3 id="композиция-треков"><a href="#TOC">Композиция треков</a></h3>
<p>Определим две полезные в музыке операции: параллельную и последовательную композицию треков. В параллельной композиции мы играем два трека одновременно:</p>
<pre><font color=Black>(</font><font color=Black>=:=</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> t <font color="#b2590f">=&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Green>Track</font> t es <font color=Black>=:=</font> <font color=Green>Track</font> t' es' <font color="#b2590f">=</font> <font color=Green>Track</font> <font color=Black>(</font>max t t'<font color=Black>)</font> <font color=Black>(</font>es <font color=Black>++</font> es'<font color=Black>)</font></pre>
<p>Теперь общая длительность трека равна длительности большего из треков, а события включают в себя события каждого из треков. С помощью преобразований во времени мы можем определить последовательную композицию, для этого мы сместим второй трек на длину первого и сыграем их одновременно:</p>
<pre><font color=Black>(</font><font color=Black>+:+</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> t<font color=Black>,</font> <font color=Green>Num</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Black>(</font><font color=Black>+:+</font><font color=Black>)</font> a b <font color="#b2590f">=</font> a <font color=Black>=:=</font> delay <font color=Black>(</font>dur a<font color=Black>)</font> b</pre>
<p>При этом у нас как раз и получится, что мы сначала сыграем целиком трек <code><font color=Black>a</font></code>, а затем трек <code><font color=Black>b</font></code>. Теперь определим аналоги операций <code><font color=Black>=:=</font></code> и <code><font color=Black>+:+</font></code> для списков:</p>
<pre><font color=Black>chord</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Num</font> t<font color=Black>,</font> <font color=Green>Ord</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font><font color=Green>Track</font> t a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Black>chord</font> <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>=:=</font><font color=Black>)</font> <font color=Black>(</font>silence <font color="#0000ee">0</font><font color=Black>)</font>

<font color=Black>line</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Num</font> t<font color=Black>,</font> <font color=Green>Ord</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font><font color=Green>Track</font> t a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Black>line</font> <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>+:+</font><font color=Black>)</font> <font color=Black>(</font>silence <font color="#0000ee">0</font><font color=Black>)</font></pre>
<p>Мы можем определить в терминах этих операций цикличный повтор событий:</p>
<pre><font color=Black>loop</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Num</font> t<font color=Black>,</font> <font color=Green>Ord</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> t a
<font color=Black>loop</font> n t <font color="#b2590f">=</font> line <font color=Black>$</font> replicate n t</pre>
<h3 id="экземпляры-стандартных-классов"><a href="#TOC">Экземпляры стандартных классов</a></h3>
<p>Мы можем сделать тип трек экземпляром класса <code><font color=Green>Functor</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Functor</font> <font color=Black>(</font><font color=Green>Event</font> t<font color=Black>)</font> <font color="#b2590f">where</font>
    fmap f e <font color="#b2590f">=</font> e<font color=Black>{</font> eventContent <font color="#b2590f">=</font> f <font color=Black>(</font>eventContent e<font color=Black>)</font> <font color=Black>}</font>

<font color="#b2590f">instance</font> <font color=Green>Functor</font> <font color=Black>(</font><font color=Green>Track</font> t<font color=Black>)</font> <font color="#b2590f">where</font>
    fmap f t <font color="#b2590f">=</font> t<font color=Black>{</font> trackEvents <font color="#b2590f">=</font> fmap <font color=Black>(</font>fmap f<font color=Black>)</font> <font color=Black>(</font>trackEvents t<font color=Black>)</font> <font color=Black>}</font></pre>
<p>Мы можем также определить экземпляр для класса <code><font color=Green>Monoid</font></code>. Параллельная композиция будет операцией объединения, а нейтральным элементом будет тишина, которая длится ноль единиц времени:</p>
<pre><font color="#b2590f">instance</font> <font color=Black>(</font><font color=Green>Ord</font> t<font color=Black>,</font> <font color=Green>Num</font> t<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Monoid</font> <font color=Black>(</font><font color=Green>Track</font> t a<font color=Black>)</font> <font color="#b2590f">where</font>
    mappend <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>=:=</font><font color=Black>)</font>
    mempty  <font color="#b2590f">=</font> silence <font color="#0000ee">0</font></pre>
<h2 id="ноты-в-midi"><a href="#TOC">Ноты в midi</a></h2>
<p>С помощью типа <code><font color=Green>Track</font></code> мы можем описывать всё, что имеет свойство случаться во времени и длиться, мы можем описывать наборы событий. Операции из класса <code><font color=Green>Temporal</font></code> и операции последовательной и параллельной композиции дают нам возможность собирать сложные наборы событий из простейших. Но для того чтобы это стало музыкой, нам не хватает нот.</p>
<p>Так построим их. Поскольку мы собираемся играть музыку в midi, наши ноты будут содержать только три основных параметра, это номер инструмента, громкость и высота. Длительность ноты будет кодироваться в событии, эта информация уже встроена в тип <code><font color=Green>Track</font></code>.</p>
<pre><font color="#b2590f">data</font> <font color=Green>Note</font> <font color="#b2590f">=</font> <font color=Green>Note</font> <font color=Black>{</font>
    noteInstr   <font color="#b2590f">::</font> <font color=Green>Instr</font><font color=Black>,</font>
    noteVolume  <font color="#b2590f">::</font> <font color=Green>Volume</font><font color=Black>,</font>
    notePitch   <font color="#b2590f">::</font> <font color=Green>Pitch</font><font color=Black>,</font>
    isDrum      <font color="#b2590f">::</font> <font color=Green>Bool</font>  <font color=Black>}</font></pre>
<p>Итак нота содержит код инструмента, громкость и высоту и ещё один параметр. По последнему параметру можно узнать сыграна нота на барабане или нет. В midi ноты для ударных обрабатываются особым образом. Десятый канал выделен под ударные, при этом номер инструмента игнорируется, а вместо этого высота звука кодирует номер ударного инструмента. Теперь определимся с типами параметров:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Instr</font>  <font color="#b2590f">=</font> <font color=Green>Int</font>
<font color="#b2590f">type</font> <font color=Green>Volume</font> <font color="#b2590f">=</font> <font color=Green>Int</font>
<font color="#b2590f">type</font> <font color=Green>Pitch</font>  <font color="#b2590f">=</font> <font color=Green>Int</font></pre>
<p>Целые числа соответствуют целым числам в протоколе midi. Значения для типов <code><font color=Green>Volume</font></code> и <code><font color=Green>Pitch</font></code> лежат в диапазоне от 0 до 127.</p>
<p>Введём специальное обозначение для музыкального типа <code><font color=Green>Track</font></code>:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Score</font> <font color="#b2590f">=</font> <font color=Green>Track</font> <font color=Green>Double</font> <font color=Green>Note</font></pre>
<h3 id="синонимы-для-нот"><a href="#TOC">Синонимы для нот</a></h3>
<h4 id="высота-ноты"><a href="#TOC">Высота ноты</a></h4>
<p>Музыкантам ближе буквенные обозначения для нот нежели коды midi. Определим удобные синонимы:</p>
<pre><font color=Black>note</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>note</font> n <font color="#b2590f">=</font> <font color=Green>Track</font> <font color="#0000ee">1</font> <font color="#b2590f">[</font><font color=Green>Event</font> <font color="#0000ee">0</font> <font color="#0000ee">1</font> <font color=Black>(</font><font color=Green>Note</font> <font color="#0000ee">0</font> <font color="#0000ee">64</font> <font color=Black>(</font><font color="#0000ee">60</font><font color=Black>+</font>n<font color=Black>)</font> <font color=Green>False</font><font color=Black>)</font><font color="#b2590f">]</font></pre>
<p>Эта функция строит трек, который содержит одну ноту. Нота длится одну целую длительность играется на инструменте с кодом <code><font color="#0000ee">0</font></code>, на средней громкости. Параметр функции задаёт смещение от ноты до первой октавы. Определим остальные ноты:</p>
<pre><font color=Black>a</font><font color=Black>,</font> b<font color=Black>,</font> c<font color=Black>,</font> d<font color=Black>,</font> e<font color=Black>,</font> f<font color=Black>,</font> g<font color=Black>,</font>
    <font color="#b2590f">as</font><font color=Black>,</font> bs<font color=Black>,</font> cs<font color=Black>,</font> ds<font color=Black>,</font> es<font color=Black>,</font> fs<font color=Black>,</font> gs<font color=Black>,</font>
    af<font color=Black>,</font> bf<font color=Black>,</font> cf<font color=Black>,</font> df<font color=Black>,</font> ef<font color=Black>,</font> ff<font color=Black>,</font> gf <font color="#b2590f">::</font> <font color=Green>Score</font>

<font color=Black>c</font> <font color="#b2590f">=</font> note <font color="#0000ee">0</font><font color=Black>;</font>    cs <font color="#b2590f">=</font> note <font color="#0000ee">1</font><font color=Black>;</font>    d <font color="#b2590f">=</font> note <font color="#0000ee">2</font><font color=Black>;</font>    ds <font color="#b2590f">=</font> note <font color="#0000ee">3</font><font color=Black>;</font>	
<font color=Black>...</font></pre>
<p>Первая буква содержит буквенное обозначение ноты, а вторая либо <code><font color=Black>s</font></code> (от англ. sharp диез) или <code><font color=Black>f</font></code> (от англ. flat бемоль). Все эти ноты находятся в первой октаве, но смещением высоты на 12 единиц мы легко можем смещать эти ноты в любую другую октаву:</p>
<pre><font color=Black>higher</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>higher</font> n <font color="#b2590f">=</font> fmap <font color=Black>(</font><font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>{</font> notePitch <font color="#b2590f">=</font> <font color="#0000ee">12</font><font color=Black>*</font>n <font color=Black>+</font> notePitch a <font color=Black>}</font><font color=Black>)</font>

<font color=Black>lower</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> 
<font color=Black>lower</font> n <font color="#b2590f">=</font> higher <font color=Black>(</font><font color="#2149c1">-</font>n<font color=Black>)</font>

<font color=Black>high</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>high</font> <font color="#b2590f">=</font> higher <font color="#0000ee">1</font>

<font color=Black>low</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> 
<font color=Black>low</font> <font color="#b2590f">=</font> lower <font color="#0000ee">1</font></pre>
<p>С помощью этих функций мы легко можем смещать группы нот в любую октаву. Функция <code><font color=Black>higher</font></code> принимает число октав, на которые необходимо сместить вверх высоту во всех нотах трека. Смещение высоты на 12 определяет смещение на одну октаву. Остальные функции определены в через функцию <code><font color=Black>higher</font></code>.</p>
<h4 id="длительность-ноты"><a href="#TOC">Длительность ноты</a></h4>
<p>Пока что наши ноты длятся 1 единицу времени. Но нам бы хотелось иметь в распоряжении и другие длительности. Ноты других длительностей мы можем легко получать с помощью функции <code><font color=Black>stretch</font></code>, мы просто изменим масштаб времени и длительность всех нот изменится. Определим несколько синонимов:</p>
<pre><font color=Black>bn</font><font color=Black>,</font> hn<font color=Black>,</font> qn<font color=Black>,</font> en<font color=Black>,</font> sn <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>

<font color="#2149c1">-- (brewis note)   (half note)         (quater note)</font>
<font color=Black>bn</font> <font color="#b2590f">=</font> stretch <font color="#0000ee">2</font><font color=Black>;</font>    hn <font color="#b2590f">=</font> stretch <font color="#0000ee">0.5</font><font color=Black>;</font>   qn <font color="#b2590f">=</font> stretch <font color="#0000ee">0.25</font><font color=Black>;</font>

<font color="#2149c1">-- (eighth note)      (sizth note)</font>
<font color=Black>en</font> <font color="#b2590f">=</font> stretch <font color="#0000ee">0.125</font><font color=Black>;</font>   sn <font color="#b2590f">=</font> stretch <font color="#0000ee">0.0625</font><font color=Black>;</font></pre>
<p>Эти преобразования отвечают длительностям нот в европейской музыкальной традиции.</p>
<h4 id="громкость-ноты"><a href="#TOC">Громкость ноты</a></h4>
<p>Пока мы умеем создавать ноты средней громкости, но мы можем определить преобразователи на манер тех, что изменяли высоту звука октавами:</p>
<pre><font color=Black>louder</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>louder</font> n <font color="#b2590f">=</font> fmap <font color=Black>$</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>{</font> noteVolume <font color="#b2590f">=</font> n <font color=Black>+</font> noteVolume a <font color=Black>}</font>

<font color=Black>quieter</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>quieter</font> n <font color="#b2590f">=</font> louder <font color=Black>(</font><font color="#2149c1">-</font>n<font color=Black>)</font></pre>
<h4 id="смена-инструмента"><a href="#TOC">Смена инструмента</a></h4>
<p>Изначально мы создаём ноты, которые играются на инструменте с кодом 0, в протоколе General Midi этот номер соответствует роялю. Но с помощью класса <code><font color=Green>Functor</font></code> мы легко можем изменить инструмент:</p>
<pre><font color=Black>instr</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>instr</font> n <font color="#b2590f">=</font> fmap <font color=Black>$</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>{</font> noteInstr <font color="#b2590f">=</font> n<font color=Black>,</font> isDrum <font color="#b2590f">=</font> <font color=Green>False</font> <font color=Black>}</font>

<font color=Black>drum</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>drum</font> n <font color="#b2590f">=</font> fmap <font color=Black>$</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>{</font> notePitch <font color="#b2590f">=</font> n<font color=Black>,</font> isDrum <font color="#b2590f">=</font> <font color=Green>True</font> <font color=Black>}</font></pre>
<p>Согласно протоколу midi в случае ударных инструментов высота звука кодирует инструмент. Поэтому в функции <code><font color=Black>drum</font></code> мы изменяем именно поле <code><font color=Black>notePitch</font></code>. Создадим также несколько синонимов для создания нот, которые играются на барабанах. В этом случае нам не важна высота звука но важна громкость:</p>
<pre><font color=Black>bam</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>bam</font> n <font color="#b2590f">=</font> <font color=Green>Track</font> <font color="#0000ee">1</font> <font color="#b2590f">[</font><font color=Green>Event</font> <font color="#0000ee">0</font> <font color="#0000ee">1</font> <font color=Black>(</font><font color=Green>Note</font> <font color="#0000ee">0</font> n <font color="#0000ee">35</font> <font color=Green>True</font><font color=Black>)</font><font color="#b2590f">]</font></pre>
<p>Номер 35 кодирует “бочку”.</p>
<h4 id="паузы"><a href="#TOC">Паузы</a></h4>
<p>Слово <code><font color=Black>silence</font></code> верно отражает смысл, но оно слишком длинное. Давайте определим несколько синонимов:</p>
<pre><font color=Black>rest</font> <font color="#b2590f">::</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>Score</font>
<font color=Black>rest</font> <font color="#b2590f">=</font> silence

<font color=Black>wnr</font> <font color="#b2590f">=</font> rest <font color="#0000ee">1</font><font color=Black>;</font>   bnr <font color="#b2590f">=</font> bn wnr<font color=Black>;</font>   hnr <font color="#b2590f">=</font> hn wnr<font color=Black>;</font>	
<font color=Black>qnr</font> <font color="#b2590f">=</font> qn wnr<font color=Black>;</font>   enr <font color="#b2590f">=</font> en wnr<font color=Black>;</font>   snr <font color="#b2590f">=</font> sn wnr<font color=Black>;</font>	</pre>
<h2 id="перевод-в-midi"><a href="#TOC">Перевод в midi</a></h2>
<p>Теперь мы можем составить какую нибудь мелодию:</p>
<pre><font color=Black>q</font> <font color="#b2590f">=</font> line <font color="#b2590f">[</font>c<font color=Black>,</font> c<font color=Black>,</font> hn e<font color=Black>,</font> hn d<font color=Black>,</font> bn e<font color=Black>,</font> chord <font color="#b2590f">[</font>c<font color=Black>,</font> e<font color="#b2590f">]</font><font color="#b2590f">]</font></pre>
<p>Мы можем составлять мелодии, но пока мы не умеем их интерпретировать. Для этого нам нужно написать функцию:</p>
<pre><font color=Black>render</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Midi</font></pre>
<p>Мы реализуем простейший случай. Будем считать, что у нас только 15 инструментов, а все остальные инструменты – ударные. Мы запишем нашу музыку на один трек midi-файла, распределив 15 неударных инструментов по разным каналам. Ещё одно упрощение заключается в том, что мы зададим фиксированное разрешение по времени для всех возможных мелодий. Будем считать, что 96 ударов для одной четверти нам достаточно. Принимая во внимания эти посылки мы можем написать такую функцию:</p>
<pre><font color="#b2590f">import</font> <font color="#b2590f">qualified</font> <font color=Green>Codec</font><font color=Black>.</font><font color=Green>Midi</font> <font color="#b2590f">as</font> <font color=Green>M</font>

<font color=Black>render</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>Midi</font>
<font color=Black>render</font> s <font color="#b2590f">=</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Midi</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>SingleTrack</font> <font color=Black>(</font><font color=Green>M</font><font color=Black>.</font><font color=Green>TicksPerBeat</font> divisions<font color=Black>)</font> <font color="#b2590f">[</font>toTrack s<font color="#b2590f">]</font>

<font color=Black>divisions</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font>
<font color=Black>divisions</font> <font color="#b2590f">=</font> <font color="#0000ee">96</font>

<font color=Black>toTrack</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> 
<font color=Black>toTrack</font> <font color="#b2590f">=</font> undefined</pre>
<p>Мы загрузили модуль <code><font color=Green>Codec</font><font color=Black>.</font><font color=Green>Midi</font></code> под псевдонимом <code><font color=Green>M</font></code>, так мы сможем отличать низкоуровневые определения от тех, что мы определили сами. Теперь перед каждым именем из модуля <code><font color=Green>Codec</font><font color=Black>.</font><font color=Green>Midi</font></code> необходимо писать приставку <code><font color=Green>M</font></code>.</p>
<p>В нашей упрощённой реализации на одном канале может играть только один инструмент. В самом начале мы назначим инструмент на канал с помощью сообщения <code><font color=Green>ProgramChange</font></code>. Для этого нам необходимо понять какому инструменту какой канал соответствует. В библиотеке <code><font color=Green>HCodecs</font></code> каналы идут от нуля до 15. Девятый канал предназначен для ударных. Представим, что у нас есть функция, которая распределяет нотную запись по инструментам:</p>
<pre><font color="#b2590f">type</font> <font color=Green>MidiEvent</font> <font color="#b2590f">=</font> <font color=Green>Event</font> <font color=Green>Double</font> <font color=Green>Note</font>

<font color=Black>groupInstr</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font><font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color=Black>)</font></pre>
<p>Эта функция принимает нотную запись, а возвращает пару. Первый элемент содержит список списков нот для неударных инструментов, каждый подсписок содержит ноты только для одного инструмента. Второй элемент пары содержит все ноты для ударных инструментов. Представим также, что у нас есть функция, которая превращает эту пару в набор midi-сообщений:</p>
<pre><font color=Black>mergeInstr</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color="#b2590f">[</font><font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font></pre>
<p>Наши отсчёты времени записаны в виде значений типа <code><font color=Green>Double</font></code>, Нам необходимо перейти к целочисленным <code><font color=Green>Ticks</font></code>. Представим, что такая функция у нас уже есть:</p>
<pre><font color=Black>tfmTime</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font></pre>
<p>Тогда функция <code><font color=Black>toTrack</font></code> примет вид:</p>
<pre><font color=Black>toTrack</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font>
<font color=Black>toTrack</font> <font color="#b2590f">=</font> tfmTime <font color=Black>.</font> mergeInstr <font color=Black>.</font> groupInstr</pre>
<p>Все три составляющие функции пока не определены. Начнём с функции <code><font color=Black>tfmTime</font></code>. Нам необходимо отсортировать события во времени для того, чтобы мы смогли перейти из абсолютных отсчётов во времени в относительные. Специально для этого в библиотеке <code><font color=Green>HСodecs</font></code> определена функция:</p>
<pre><font color=Black>fromAbsTime</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> a</pre>
<p>Также нам понадобится функция:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Time</font> <font color="#b2590f">=</font> <font color=Green>Double</font>

<font color=Black>fromRealTime</font> <font color="#b2590f">::</font> <font color=Green>TimeDiv</font> <font color="#b2590f">-&gt;</font> <font color=Green>Trrack</font> <font color=Green>Time</font> <font color="#b2590f">-&gt;</font> <font color=Green>Track</font> <font color=Green>Ticks</font></pre>
<p>Она проводит квантование во времени. С помощью неё мы преобразуем отсчёты в <code><font color=Green>Double</font></code> в целочисленные отсчёты. С помощью этих функций мы можем определить функцию <code><font color=Black>timeDiv</font></code> так:</p>
<pre><font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font><font color=Black>(</font>sortBy<font color=Black>)</font>
<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font> <font color=Black>(</font>on<font color=Black>)</font>
<font color=Black>...</font>

<font color=Black>tfmTime</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font>
<font color=Black>tfmTime</font> <font color="#b2590f">=</font> <font color=Green>M</font><font color=Black>.</font>fromAbsTime <font color=Black>.</font> <font color=Green>M</font><font color=Black>.</font>fromRealTime timeDiv <font color=Black>.</font> 
    sortBy <font color=Black>(</font>compare <font color=Black>`on`</font> fst<font color=Black>)</font></pre>
<p>В этой функции мы сначала сортируем события во времени, затем переходим от абсолютных единиц к относительным и в самом конце производим квантование по времени. Функция <code><font color=Black>sortBy</font></code> сортирует элементы согласно некоторой функции упорядочивания:</p>
<pre><font color=Black>sortBy</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ordering</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<p>Она принимает функцию упорядочивания и список. Мы воспользовались этой функцией, потому что нам необходимо отсортировать элементы списка сообщений по значению временных отсчётов. Функцию упорядочивания мы составляем с помощью специальной функции <code><font color=Black>on</font></code>, которая определена в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font></code>. С этой функцией мы уже сталкивались, когда говорили о функциях высшего порядка, она принимает функцию двух аргументов и функцию одного аргумента и словно “подкладывает” вторую функцию под первую:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Function</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t on
<font color=Black>on</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> c</pre>
<p>Теперь напишем функцию <code><font color=Black>mergeInstr</font></code>. Она устанавливает инструменты на каналы и преобразует события в последовательность midi-сообщений. При этом мы различаем сообщения для ударных и сообщения для всех остальных инструментов:</p>
<pre><font color=Black>mergeInstr</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color="#b2590f">[</font><font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>mergeInstr</font> <font color=Black>(</font>instrs<font color=Black>,</font> drums<font color=Black>)</font> <font color="#b2590f">=</font> concat <font color=Black>$</font> drums' <font color="#b2590f">:</font> instrs'
    <font color="#b2590f">where</font> instrs' <font color="#b2590f">=</font> zipWith setChannel <font color=Black>(</font><font color="#b2590f">[</font><font color="#0000ee">0</font> <font color="#b2590f">..</font> <font color="#0000ee">8</font><font color="#b2590f">]</font> <font color=Black>++</font> <font color="#b2590f">[</font><font color="#0000ee">10</font> <font color="#b2590f">..</font> <font color="#0000ee">15</font><font color="#b2590f">]</font><font color=Black>)</font> instrs
          drums'  <font color="#b2590f">=</font> setDrumChannel drums  

<font color=Black>setChannel</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Channel</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>setChannel</font> <font color="#b2590f">=</font> undefined

<font color=Black>setDrumChannel</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>setDrumChannel</font> <font color="#b2590f">=</font>  undefined</pre>
<p>Имя <code><font color=Black>instrs'</font></code> указывает на последовательность списков сообщений для каждого неударного инструмента. Функция <code><font color=Black>setChannel</font></code> принимает номер канала и список событий. По ним она строит список midi-сообщений. Определим эту функцию:</p>
<pre><font color=Black>setChannel</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Channel</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>setChannel</font> ch ms <font color="#b2590f">=</font> <font color="#b2590f">case</font> ms <font color="#b2590f">of</font>
    <font color=Green>[]</font>      <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>
    x<font color="#b2590f">:</font>xs    <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>ProgramChange</font> ch <font color=Black>(</font>instrId x<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">:</font> <font color=Black>(</font>fromEvent ch <font color=Black>=&lt;&lt;</font> ms<font color=Black>)</font>
    
<font color=Black>instrId</font> <font color="#b2590f">=</font> noteInstr <font color=Black>.</font> eventContent

<font color=Black>fromEvent</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Channel</font> <font color="#b2590f">-&gt;</font> <font color=Green>MidiEvent</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>fromEvent</font> <font color="#b2590f">=</font> undefined</pre>
<p>Первым событием мы присоединяем событие, которое устанавливает на данном канале определённый инструмент. По построению программы все ноты в переданном списке играются на одном и том же инструменте, поэтому мы узнаём идентификатор инструмента из первого элемента списка. У нас появилась новая неопределённая функция <code><font color=Black>fromEvent</font></code> она переводит сообщение в список midi-сообщений:</p>
<pre><font color=Black>fromEvent</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Channel</font> <font color="#b2590f">-&gt;</font> <font color=Green>MidiEvent</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>fromEvent</font> ch e <font color="#b2590f">=</font> <font color="#b2590f">[</font>
    <font color=Black>(</font>eventStart e<font color=Black>,</font> noteOn n<font color=Black>)</font><font color=Black>,</font> 
    <font color=Black>(</font>eventStart e <font color=Black>+</font> eventDur e<font color=Black>,</font> noteOff n<font color=Black>)</font><font color="#b2590f">]</font>
    <font color="#b2590f">where</font> n <font color="#b2590f">=</font> clipToMidi <font color=Black>$</font> eventContent e
          noteOn  n <font color="#b2590f">=</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>NoteOn</font>  ch <font color=Black>(</font>notePitch n<font color=Black>)</font> <font color=Black>(</font>noteVolume n<font color=Black>)</font>
          noteOff n <font color="#b2590f">=</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>NoteOff</font> ch <font color=Black>(</font>notePitch n<font color=Black>)</font> <font color="#0000ee">0</font>

<font color=Black>clipToMidi</font> <font color="#b2590f">::</font> <font color=Green>Note</font> <font color="#b2590f">-&gt;</font> <font color=Green>Note</font>
<font color=Black>clipToMidi</font> n <font color="#b2590f">=</font> n <font color=Black>{</font> 
    notePitch   <font color="#b2590f">=</font> clip <font color=Black>$</font> notePitch n<font color=Black>,</font>
    noteVolume  <font color="#b2590f">=</font> clip <font color=Black>$</font> noteVolume n <font color=Black>}</font>
    <font color="#b2590f">where</font> clip <font color="#b2590f">=</font> max <font color="#0000ee">0</font> <font color=Black>.</font> min <font color="#0000ee">127</font></pre>
<p>Определив эти функции, мы легко можем написать и функцию <code><font color=Black>setDrumChannel</font></code> она переводит сообщения для ударных инструментов в midi-сообщения:</p>
<pre><font color=Black>setDrumChannel</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>Double</font>
<font color=Black>setDrumChannel</font> ms <font color="#b2590f">=</font> fromEvent drumChannel <font color=Black>=&lt;&lt;</font> ms 
    <font color="#b2590f">where</font> drumChannel <font color="#b2590f">=</font> <font color="#0000ee">9</font>        </pre>
<p>Для ударных инструментов выделен отдельный канал. Считается, что все они происходят на 10 канале. Поскольку в библиотеке <code><font color=Green>HCodecs</font></code> первый канал называется нулевым, мы будем записывать все сообщения на девятый канал.</p>
<p>Мы переводим событие в два midi-сообщения, первое говорит о том, что мы начали играть ноту, а второе говорит о том, что мы закончили её играть. Функция <code><font color=Black>clipToMidi</font></code> приводит значения для высоты и громкости в диапазон midi.</p>
<p>Нам осталось определить только одну функцию. Эта функция распределяет события по инструментам. Сначала мы разделим события на те, что играются на ударных и неударных инструментах, а затем разделим “неударные” ноты по инструментам:</p>
<pre><font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Arrow</font><font color=Black>(</font>first<font color=Black>,</font> second<font color=Black>)</font>
<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font><font color=Black>(</font>sortBy<font color=Black>,</font> groupBy<font color=Black>,</font> partition<font color=Black>)</font>
<font color=Black>...</font>

<font color=Black>groupInstr</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font><font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font><font color=Black>)</font>
<font color=Black>groupInstr</font> <font color="#b2590f">=</font> first groupByInstrId <font color=Black>.</font> 
    partition <font color=Black>(</font>not <font color=Black>.</font> isDrum <font color=Black>.</font> eventContent<font color=Black>)</font> <font color=Black>.</font> trackEvents
    <font color="#b2590f">where</font> groupByInstrId <font color="#b2590f">=</font> groupBy <font color=Black>(</font><font color=Black>(</font><font color=Black>==</font><font color=Black>)</font> <font color=Black>`on`</font> instrId<font color=Black>)</font> <font color=Black>.</font> 
                           sortBy  <font color=Black>(</font>compare <font color=Black>`on`</font> instrId<font color=Black>)</font></pre>
<p>В этом определении мы воспользовались двумя новыми стандартными функциями из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code>. Функция <code><font color=Black>partition</font></code> разделяет список на пару списков. В первом списке находятся все те элементы, для которых заданный предикат вернул <code><font color=Green>True</font></code>, а во втором списке – все остальные элементы исходного списка:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t partition
<font color=Black>partition</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font></pre>
<p>Функция <code><font color=Black>groupBy</font></code> превращает список в список списков:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>t groupBy
<font color=Black>groupBy</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color="#b2590f">]</font></pre>
<p>Если бинарная функция на соседних элементах исходного списка вернула <code><font color=Green>True</font></code>, то они помещаются в один подсписок. Эта функция используется для того чтобы сгруппировать элементы списка по какому-нибудь признаку. При этом для того чтобы сгруппировать элементы по идентификатору инструмента, мы сначала отсортировали события по значению идентификатора. После этого значения с одинаковыми идентификаторами стали соседними и мы сгруппировали их с помощью <code><font color=Black>groupBy</font></code>.</p>
<p>Функция <code><font color=Black>first</font></code> применяет функцию к первому элементу пары. Вот мы и закончили, можно послушать результаты. На самом деле остались два нюанса. В функции <code><font color=Black>setChannel</font></code> мы полагаем, что мелодия начинается в момент времени <code><font color=Black>t</font> <font color="#b2590f">=</font> <font color="#0000ee">0</font></code>, но на практике это может оказаться не так, мы можем сместить ноты функцией <code><font color=Black>delay</font></code> в отрицательную сторону. Тогда первые ноты будут содержать отрицательное время начала события. Но мы можем исправить эту ситуацию, сместив все ноты на время самой первой ноты, конечно смещать необходимо только в том случае если время окажется отрицательным:</p>
<pre><font color=Black>alignEvents</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>MidiEvent</font><font color="#b2590f">]</font>
<font color=Black>alignEvents</font> es 
    <font color="#b2590f">|</font> d <font color=Black>&lt;</font> <font color="#0000ee">0</font>     <font color="#b2590f">=</font> map <font color=Black>(</font>delay <font color=Black>(</font>abs d<font color=Black>)</font><font color=Black>)</font> es
    <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font> es
    <font color="#b2590f">where</font> d <font color="#b2590f">=</font> minimum <font color=Black>$</font> map eventStart es</pre>
<p>Вызовем эту функцию сразу после функции <code><font color=Black>trackEvents</font></code> в функции <code><font color=Black>groupInstr</font></code>. Второй нюанс заключается в том, что каждый трек в midi-файле должен заканчиваться специальным сообщением, в библиотеке <code><font color=Green>HCodecs</font></code> оно обозначается с помощью конструктора <code><font color=Green>TrackEnd</font></code>. В самом конце необходимо добавить сообщение <code><font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color=Green>TrackEnd</font><font color=Black>)</font></code>:</p>
<pre><font color=Black>toTrack</font> <font color="#b2590f">::</font> <font color=Green>Score</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font>
<font color=Black>toTrack</font> <font color="#b2590f">=</font> addEndMsg <font color=Black>.</font> tfmTime <font color=Black>.</font> mergeInstr <font color=Black>.</font> groupInstr

<font color=Black>addEndMsg</font> <font color="#b2590f">::</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font> <font color="#b2590f">-&gt;</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Track</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Ticks</font>
<font color=Black>addEndMsg</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>++</font> <font color="#b2590f">[</font><font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>TrackEnd</font><font color=Black>)</font><font color="#b2590f">]</font><font color=Black>)</font></pre>
<p>Теперь мы можем проверить, что у нас получилось. Создадим файл:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Main</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>System</font>

<font color="#b2590f">import</font> <font color=Green>Track</font>
<font color="#b2590f">import</font> <font color=Green>Score</font>
<font color="#b2590f">import</font> <font color=Green>Codec</font><font color=Black>.</font><font color=Green>Midi</font>

<font color=Black>out</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>&gt;&gt;</font> system <font color=Black>"timidity tmp.mid"</font><font color=Black>)</font> <font color=Black>.</font> 
    exportFile <font color=Black>"tmp.mid"</font> <font color=Black>.</font> render</pre>
<p>В функции <code><font color=Black>out</font></code> мы переводим нотную запись в значение типа <code><font color=Green>Midi</font></code>, затем сохраняем это значение в файле <code><font color=Black>tmp</font><font color=Black>.</font>mid</code> и в самом конце запускаем файл с помощью проигрывателя <code><font color=Black>timidity</font></code>. Вместо <code><font color=Black>timidity</font></code> вы можете воспользоваться вашим любимым проигрывателем <code><font color=Black>midi</font></code>-файлов. Теперь загрузим модуль <code><font color=Green>Main</font></code> в интерпретатор. Послушаем ноту до:</p>
<pre><font color=Black>*</font><font color=Green>Main</font><font color=Black>&gt;</font> out c</pre>
<p>Далее следуют сообщения из проигрывателя <code><font color=Black>timidity</font></code> и долгожданный звук. Мы слышим ноту до, сыгранную на рояле. Наберём какую-нибудь мелодию:</p>
<pre><font color=Black>*</font><font color=Green>Main</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> line <font color="#b2590f">[</font>c<font color=Black>,</font> hn e<font color=Black>,</font> hn e<font color=Black>,</font> low b<font color=Black>,</font> c<font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Main</font><font color=Black>&gt;</font> out x</pre>
<p>Сыграем в два раза быстрее, на другом инструменте:</p>
<pre><font color=Black>*</font><font color=Green>Main</font><font color=Black>&gt;</font> out <font color=Black>$</font> instr <font color="#0000ee">15</font> <font color=Black>$</font> hn x</pre>
<p>Сыграем канон. Канон это когда одна и та же мелодия ведётся в разных голосах с запаздыванием. Сыграем двухголосный канон:</p>
<pre><font color=Black>*</font><font color=Green>Main</font><font color=Black>&gt;</font> out <font color=Black>$</font> instr <font color="#0000ee">80</font> <font color=Black>(</font>loop <font color="#0000ee">3</font> x<font color=Black>)</font> <font color=Black>=:=</font> delay <font color="#0000ee">2</font> <font color=Black>(</font>instr <font color="#0000ee">65</font> <font color=Black>$</font> low <font color=Black>$</font> loop <font color="#0000ee">3</font> x<font color=Black>)</font></pre>
<p>Номера инструментов можно посмотреть по справке к протоколу General Midi. Это дополнение к протоколу midi определяет какие номера каким инструментам должны соответствовать. Звучит ужасно, но звучит!</p>
<h2 id="пример"><a href="#TOC">Пример</a></h2>
<p>Опираясь на примитивы композиции, которые мы определил в модуле <code><font color=Green>Score</font></code>, мы можем написать мелодию. Ниже приведён небольшой пример. Инструменты:</p>
<pre><font color=Black>closedHiHat</font> <font color="#b2590f">=</font> drum <font color="#0000ee">42</font><font color=Black>;</font>		rideCymbal <font color="#b2590f">=</font> drum <font color="#0000ee">59</font><font color=Black>;</font> 	  cabasa <font color="#b2590f">=</font> drum <font color="#0000ee">69</font><font color=Black>;</font>
<font color=Black>maracas</font>     <font color="#b2590f">=</font> drum <font color="#0000ee">70</font><font color=Black>;</font>		tom        <font color="#b2590f">=</font> drum <font color="#0000ee">45</font><font color=Black>;</font>

<font color=Black>flute</font>       <font color="#b2590f">=</font> instr <font color="#0000ee">73</font><font color=Black>;</font>		piano       <font color="#b2590f">=</font> instr <font color="#0000ee">0</font><font color=Black>;</font></pre>
<p>Ударная секция:</p>
<pre><font color=Black>b1</font> <font color="#b2590f">=</font> bam <font color="#0000ee">100</font>
<font color=Black>b0</font> <font color="#b2590f">=</font> bam <font color="#0000ee">84</font>

<font color=Black>drums1</font> <font color="#b2590f">=</font> loop <font color="#0000ee">80</font> <font color=Black>$</font> chord <font color="#b2590f">[</font>
    tom   <font color=Black>$</font> line <font color="#b2590f">[</font>qn b1<font color=Black>,</font> qn b0<font color=Black>,</font> hnr<font color="#b2590f">]</font><font color=Black>,</font>
    maracas <font color=Black>$</font> line <font color="#b2590f">[</font>hnr<font color=Black>,</font> hn b0<font color="#b2590f">]</font> 
    <font color="#b2590f">]</font>
   
<font color=Black>drums2</font> <font color="#b2590f">=</font> quieter <font color="#0000ee">20</font> <font color=Black>$</font> cabasa <font color=Black>$</font> loop <font color="#0000ee">120</font> <font color=Black>$</font> en <font color=Black>$</font> line <font color="#b2590f">[</font>b1<font color=Black>,</font> b0<font color=Black>,</font> b0<font color=Black>,</font> b0<font color=Black>,</font> b0<font color="#b2590f">]</font>

<font color=Black>drums3</font> <font color="#b2590f">=</font> closedHiHat <font color=Black>$</font> loop <font color="#0000ee">50</font> <font color=Black>$</font> en <font color=Black>(</font>line <font color="#b2590f">[</font>b1<font color=Black>,</font> loop <font color="#0000ee">12</font> wnr<font color="#b2590f">]</font><font color=Black>)</font>

<font color=Black>drums</font> <font color="#b2590f">=</font> drums1 <font color=Black>=:=</font> drums2 <font color=Black>=:=</font> drums3</pre>
<p>Уже сейчас мы можем загрузить эту партию в интерпретатор и послушать, вызвав <code><font color=Black>out</font> drums</code>. Аккорды к мелодии:</p>
<pre><font color=Black>c7</font>  <font color="#b2590f">=</font> chord <font color="#b2590f">[</font>c<font color=Black>,</font> e<font color=Black>,</font> b<font color="#b2590f">]</font>
<font color=Black>gs7</font> <font color="#b2590f">=</font> chord <font color="#b2590f">[</font>low af<font color=Black>,</font> c<font color=Black>,</font> g<font color="#b2590f">]</font>
<font color=Black>g7</font>  <font color="#b2590f">=</font> chord <font color="#b2590f">[</font>low g<font color=Black>,</font> low bf<font color=Black>,</font> f<font color="#b2590f">]</font>

<font color=Black>harmony</font> <font color="#b2590f">=</font> piano <font color=Black>$</font> loop <font color="#0000ee">12</font> <font color=Black>$</font> lower <font color="#0000ee">1</font> <font color=Black>$</font> bn <font color=Black>$</font> line <font color="#b2590f">[</font>bn c7<font color=Black>,</font> gs7<font color=Black>,</font> g7<font color="#b2590f">]</font></pre>
<p>Мелодия:</p>
<pre><font color=Black>ac</font> <font color="#b2590f">=</font> louder <font color="#0000ee">5</font>

<font color=Black>mel1</font> <font color="#b2590f">=</font> bn <font color=Black>$</font> line <font color="#b2590f">[</font>bnr<font color=Black>,</font> subMel<font color=Black>,</font> ac <font color=Black>$</font> stretch <font color=Black>(</font><font color="#0000ee">1</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>/</font><font color="#0000ee">8</font><font color=Black>)</font> e<font color=Black>,</font> c<font color=Black>,</font>
    subMel<font color=Black>,</font> enr<font color="#b2590f">]</font>
    <font color="#b2590f">where</font> subMel <font color="#b2590f">=</font> line <font color="#b2590f">[</font>g<font color=Black>,</font> stretch <font color="#0000ee">1.5</font> <font color=Black>$</font> qn g<font color=Black>,</font> qn f<font color=Black>,</font> qn g<font color="#b2590f">]</font>

<font color=Black>mel2</font> <font color="#b2590f">=</font> loop <font color="#0000ee">2</font> <font color=Black>$</font> qn <font color=Black>$</font> line <font color="#b2590f">[</font>subMel<font color=Black>,</font> ac <font color=Black>$</font> bn ds<font color=Black>,</font> c<font color=Black>,</font> d<font color=Black>,</font> ac <font color=Black>$</font> bn c<font color=Black>,</font> c<font color=Black>,</font> c<font color=Black>,</font> wnr<font color=Black>,</font>
     subMel<font color=Black>,</font> ac <font color=Black>$</font> bn g<font color=Black>,</font> f<font color=Black>,</font> ds<font color=Black>,</font> ac <font color=Black>$</font> bn f<font color=Black>,</font> ds<font color=Black>,</font> ac <font color=Black>$</font> bn c<font color="#b2590f">]</font>
    <font color="#b2590f">where</font> subMel <font color="#b2590f">=</font> line <font color="#b2590f">[</font>ac ds<font color=Black>,</font> c<font color=Black>,</font> d<font color=Black>,</font> ac <font color=Black>$</font> bn c<font color=Black>,</font> c<font color=Black>,</font> c<font color="#b2590f">]</font>

<font color=Black>mel3</font> <font color="#b2590f">=</font> loop <font color="#0000ee">2</font> <font color=Black>$</font> line <font color="#b2590f">[</font>pat1 <font color=Black>(</font>high c<font color=Black>)</font> <font color="#b2590f">as</font> g<font color=Black>,</font> pat1 g f d<font color="#b2590f">]</font> 
    <font color="#b2590f">where</font> pat1 a b c <font color="#b2590f">=</font> line <font color="#b2590f">[</font>pat a<font color=Black>,</font> loop <font color="#0000ee">3</font> qnr<font color=Black>,</font> wnr<font color=Black>,</font> 
                pat b<font color=Black>,</font> qnr<font color=Black>,</font> hnr<font color=Black>,</font> pat c<font color=Black>,</font> qnr<font color=Black>,</font> hnr<font color="#b2590f">]</font>
          pat  x     <font color="#b2590f">=</font> en <font color=Black>(</font>x <font color=Black>+:+</font> x<font color=Black>)</font>  

<font color=Black>mel</font> <font color="#b2590f">=</font> flute <font color=Black>$</font> line <font color="#b2590f">[</font>mel1<font color=Black>,</font> mel2<font color=Black>,</font> mel3<font color="#b2590f">]</font></pre>
<p>Добавим в конце звук тарелки:</p>
<pre><font color=Black>cha</font> <font color="#b2590f">=</font> delay <font color=Black>(</font>dur mel1 <font color=Black>+</font> dur mel2<font color=Black>)</font> <font color=Black>$</font> loop <font color="#0000ee">10</font> <font color=Black>$</font> rideCymbal <font color=Black>$</font> delay <font color="#0000ee">1</font> b1</pre>
<p>Соберём всё вместе и послушаем:</p>
<pre><font color=Black>res</font> <font color="#b2590f">=</font> chord <font color="#b2590f">[</font>
        drums<font color=Black>,</font> 
        harmony<font color=Black>,</font> 
        high mel<font color=Black>,</font> 
        louder <font color="#0000ee">40</font> cha<font color=Black>,</font> 
        rest <font color="#0000ee">0</font><font color="#b2590f">]</font>

<font color=Black>main</font> <font color="#b2590f">=</font> out res</pre>
<p>В конце стоит фиктивный элемент <code><font color=Black>rest</font> <font color="#0000ee">0</font></code> для того чтобы было удобно глушить инструменты комментированием.</p>
<h2 id="эффективное-представление-музыкальной-нотации"><a href="#TOC">Эффективное представление музыкальной нотации</a></h2>
<p>Реализация, которую мы рассмотрели не эффективна, Мы могли бы определить тип <code><font color=Green>Track</font></code> и по-другому. Мы очень часто пользуемся операцией <code><font color=Black>delay</font></code> через операцию <code><font color=Black>line</font></code>. Так в выражении:</p>
<pre><font color=Black>q</font> <font color="#b2590f">=</font> line <font color="#b2590f">[</font>s1<font color=Black>,</font> s2<font color=Black>,</font> line <font color="#b2590f">[</font>loop <font color="#0000ee">2</font> s3<font color=Black>,</font> s4<font color="#b2590f">]</font><font color=Black>,</font> s5<font color="#b2590f">]</font></pre>
<p>Мы будем несколько раз обходить элемент <code><font color=Black>s3</font></code> для каждого применения <code><font color=Black>line</font></code>. К примеру сначала мы смести все элементы на 3, потом сместим на 5, потом на 10, но вместо этого мы могли бы сразу сместить все элементы на 18 за один проход. Для этого мы можем закодировать преобразования событий во времени в типе <code><font color=Green>Track</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Track</font> t a <font color="#b2590f">=</font> <font color=Green>Track</font> <font color=Black>{</font>
    trackDur    <font color="#b2590f">::</font> t<font color=Black>,</font>
    trackEvents <font color="#b2590f">::</font> <font color=Green>TList</font> t a


<font color="#b2590f">data</font> <font color=Green>TList</font> t a <font color="#b2590f">=</font> <font color=Green>Empty</font> <font color="#b2590f">|</font> <font color=Green>Single</font> a <font color="#b2590f">|</font> <font color=Green>Append</font> <font color=Black>(</font><font color=Green>TList</font> t a<font color=Black>)</font> <font color=Black>(</font><font color=Green>TList</font> t a<font color=Black>)</font> 
               <font color="#b2590f">|</font> <font color=Green>TFun</font> <font color=Black>(</font><font color=Green>Tfm</font> t<font color=Black>)</font> <font color=Black>(</font><font color=Green>TList</font> t a<font color=Black>)</font>

<font color="#b2590f">data</font> <font color=Green>Tfm</font> t <font color="#b2590f">=</font> <font color=Green>Tfm</font> <font color=Black>!</font>t <font color=Black>!</font>t</pre>
<p>Тип <code><font color=Green>TList</font></code> позволяет проводить быстрое объединение списков. Дополнительный конструктор <code><font color=Green>TFun</font></code> обозначает линейное преобразование списка во времени. Линейное преобразование кодируется двумя числами, это масштаб и смещение. Мы считаем, что события в конструкторе <code><font color=Green>Single</font></code> начинаются в момент времени <code><font color="#0000ee">0</font></code> и длятся <code><font color="#0000ee">1</font></code> единицу времени. Так например событие, которое произошло на 2 единице времени и длилось 4 единицы можно представить так:</p>
<pre><font color=Green>TFun</font> <font color=Black>(</font><font color="#0000ee">4</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Single</font> a<font color=Black>)</font></pre>
<p>Значение <code><font color=Green>Tfm</font> k d</code> обозначает линейную функцию</p>
<p><span class="LaTeX">$f(x) = k x + d$</span></p>
<p>Для того чтобы получить настоящие отсчёты по времени мы применяем её к временным координатам “не преобразованного” события, то есть события <code><font color=Green>Event</font> <font color="#0000ee">0</font> <font color="#0000ee">1</font> a</code>.</p>
<p>Единственное, что нам нужно для того чтобы встроить этот вариант в библиотеку это написать функцию:</p>
<pre><font color=Black>fromTList</font> <font color="#b2590f">::</font> <font color=Green>TList</font> t a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Event</font> t a<font color="#b2590f">]</font></pre>
<p>И конечно переопределить все функции композиции. Но все сложные функции, которые отвечают за перевод из <code><font color=Green>Track</font></code> в <code><font color=Green>Midi</font></code> останутся прежними.</p>
<h2 id="краткое-содержание"><a href="#TOC">Краткое содержание</a></h2>
<p>В этой главе мы построили секвенсор для создания midi-файлов. Мы воспользовались библиотекой <code><font color=Green>HCodecs</font></code> и создали над ней небольшую надстройку.</p>
<p>В нашей библиотеке примитивными конструкциями были события, параллельная композиция (одновременное воспроизведение) и преобразование событий во времени (сдвиг и масштабирование). Все остальные операции выражались через эти простейшие операции. Отметим, что есть и другие подходы. Например в библиотеках <code><font color=Green>Haskore</font></code> и <code><font color=Green>Euterpea</font></code> примитивными конструкциями является единичное событие (без отметок во времени) и параллельная и последовательная композиции. Подход, который мы рассмотрели в более общем виде реализован в библиотеках <code><font color=Black>temporal</font><font color="#2149c1">-</font>music<font color="#2149c1">-</font>notation</code> и <code><font color=Black>temporal</font><font color="#2149c1">-</font>music<font color="#2149c1">-</font>notation<font color="#2149c1">-</font>demo</code>.</p>
<h2 id="упражнения"><a href="#TOC">Упражнения</a></h2>
<ul>
<li><p>Попробуйте написать какую-нибудь мелодию.</p></li>
<li><p>Подумайте каких операций не хватает. Например было бы удобно иметь возможность вырезать из мелодии куски. Так в примере у нас остались хвосты от ударной секции, определите операцию, которая позволяет убрать лишнее.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="20.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="appendix.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="20" style="list-style-type: decimal">
<li>Императивное программирование
</div> <div id="wrap-next-name"><div id="next-name">
Приложение
</div></div></div>  
 </div> 
</li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
