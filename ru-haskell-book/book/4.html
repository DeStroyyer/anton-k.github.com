<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#декларативный-и-композиционный-стиль">Декларативный и композиционный стиль</a><ul>
<li><a href="#локальные-переменные">Локальные переменные</a><ul>
<li><a href="#where-выражения">where-выражения</a></li>
<li><a href="#let-выражения">let-выражения</a></li>
</ul></li>
<li><a href="#декомпозиция">Декомпозиция</a><ul>
<li><a href="#сопоставление-с-образцом">Сопоставление с образцом</a></li>
<li><a href="#case-выражения">case-выражения</a></li>
</ul></li>
<li><a href="#условные-выражения">Условные выражения</a><ul>
<li><a href="#охранные-выражения">Охранные выражения</a></li>
<li><a href="#if-выражения">if-выражения</a></li>
</ul></li>
<li><a href="#определение-функций">Определение функций</a><ul>
<li><a href="#уравнения">Уравнения</a></li>
<li><a href="#безымянные-функции">Безымянные функции</a></li>
</ul></li>
<li><a href="#какой-стиль-лучше">Какой стиль лучше?</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="3.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="5.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="декларативный-и-композиционный-стиль"><a href="#декларативный-и-композиционный-стиль">Декларативный и композиционный стиль</a></h1>
<p>В Haskell существует несколько встроенных выражений, которые облегчают построение функций и делают код более наглядным. Их можно разделить на два вида: выражения, которые поддерживают <em>декларативный стиль</em> (declarative style) определения функций, и выражения которые поддерживают <em>композиционный стиль</em> (expression style).</p>
<p>Что это за стили? В декларативном стиле определения функций больше похожи на математическую нотацию, словно это предложения языка. В композиционном стиле мы строим из маленьких выражений более сложные, применяем к этим выражениям другие выражения и строим ещё большие.</p>
<p>В Haskell есть полноценная поддержка и того и другого стиля, поэтому конструкции которые мы рассмотрим в этой главе будут по смыслу дублировать друг друга. Выбор стиля скорее дело вкуса, существуют приверженцы и того и другого стиля, поэтому разработчики Haskell не хотели никого ограничивать.</p>
<h2 id="локальные-переменные"><a href="#локальные-переменные">Локальные переменные</a></h2>
<p>Вспомним формулу вычисления площади треугольника по трём сторонам:</p>
<p><span class="LaTeX">$$S = \sqrt{p \cdot (p - a) \cdot (p - b) \cdot (p - c)}$$</span></p>
<p>Где <span class="LaTeX">$a$</span>, <span class="LaTeX">$b$</span> и <span class="LaTeX">$c$</span> – длины сторон треугольника, а <span class="LaTeX">$p$</span> это полупериметр.</p>
<p>Как бы мы определили эту функцию теми средствами, что у нас есть? Наверное, мы бы написали так:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> sqrt <font color=Black>(</font>p a b c <font color=Black>*</font> <font color=Black>(</font>p a b c <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p a b c <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p a b c <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font>

<font color=Black>p</font> a b c <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font></pre>
<p>Согласитесь это не многим лучше чем решение в лоб:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> sqrt <font color=Black>(</font><font color=Black>(</font>a<font color=Black>+</font>b<font color=Black>+</font>c<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font> <font color=Black>*</font> <font color=Black>(</font><font color=Black>(</font>a<font color=Black>+</font>b<font color=Black>+</font>c<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font> <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font><font color=Black>(</font>a<font color=Black>+</font>b<font color=Black>+</font>c<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font> <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font><font color=Black>(</font>a<font color=Black>+</font>b<font color=Black>+</font>c<font color=Black>)</font><font color=Black>/</font><font color="#0000ee">2</font> <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font></pre>
<p>И в том и в другом случае нам приходится дублировать выражения, нам бы хотелось чтобы определение выглядело так же, как и обычное математическое определение:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> sqrt <font color=Black>(</font>p <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font>

<font color=Black>p</font> <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font></pre>
<p>Нам нужно, чтобы <code><font color=Black>p</font></code> знало, что <code><font color=Black>a</font></code>, <code><font color=Black>b</font></code> и <code><font color=Black>c</font></code> берутся из аргументов функции <code><font color=Black>square</font></code>. В этом нам помогут локальные переменные.</p>
<h3 id="where-выражения"><a href="#where-выражения">where-выражения</a></h3>
<p>В декларативном стиле для этого предусмотрены  <code><font color="#b2590f">where</font></code>-выражения. Они пишутся так:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> sqrt <font color=Black>(</font>p <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font>
    <font color="#b2590f">where</font> p <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font></pre>
<p>Или так:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> sqrt <font color=Black>(</font>p <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">where</font> 
    p <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font></pre>
<p>За определением функции следует специальное слово <code><font color="#b2590f">where</font></code>, которое вводит локальные имена-синонимы. При этом аргументы функции включены в область видимости имён. Синонимов может быть несколько:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> sqrt <font color=Black>(</font>p <font color=Black>*</font> pa <font color=Black>*</font> pb <font color=Black>*</font> pc<font color=Black>)</font>
    <font color="#b2590f">where</font> p  <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font>
          pa <font color="#b2590f">=</font> p <font color="#2149c1">-</font> a
          pb <font color="#b2590f">=</font> p <font color="#2149c1">-</font> b
          pc <font color="#b2590f">=</font> p <font color="#2149c1">-</font> c</pre>
<p>Отметим, что отступы обязательны. Haskell по отступам понимает, что эти выражения относятся к <code><font color="#b2590f">where</font></code>.</p>
<p>Как и в случае объявления функций порядок следования локальных переменных в <code><font color="#b2590f">where</font></code>-выражении не важен. Главное чтобы в выражениях справа от знака равно мы пользовались именами из списка аргументов исходной функции или другими определёнными именами. Локальные переменные видны только в пределах той функции, в которой они вводятся.</p>
<p>Что интересно, слева от знака равно в <code><font color="#b2590f">where</font></code>-выражениях можно проводить декомпозицию значений, также как и в аргументах функции:</p>
<pre><font color=Black>pred</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font>
<font color=Black>pred</font> x <font color="#b2590f">=</font> y
    <font color="#b2590f">where</font> <font color=Black>(</font><font color=Green>Succ</font> y<font color=Black>)</font> <font color="#b2590f">=</font> x</pre>
<p>Эта функция делает тоже самое что и функция</p>
<pre><font color=Black>pred</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font>
<font color=Black>pred</font> <font color=Black>(</font><font color=Green>Succ</font> y<font color=Black>)</font> <font color="#b2590f">=</font> y</pre>
<p>В <code><font color="#b2590f">where</font></code>-выражениях можно определять новые функции а также выписывать их типы:</p>
<pre><font color=Black>add2</font> x <font color="#b2590f">=</font> succ <font color=Black>(</font>succ x<font color=Black>)</font>
    <font color="#b2590f">where</font> succ <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
          succ x <font color="#b2590f">=</font> x <font color=Black>+</font> <font color="#0000ee">1</font></pre>
<p>А можно и не выписывать, компилятор догадается:</p>
<pre><font color=Black>add2</font> x <font color="#b2590f">=</font> succ <font color=Black>(</font>succ x<font color=Black>)</font>
    <font color="#b2590f">where</font> succ x <font color="#b2590f">=</font> x <font color=Black>+</font> <font color="#0000ee">1</font></pre>
<p>Но иногда это бывает полезно, при использовании классов типов, для избежания неопределённости применения.</p>
<p>Приведём ещё один пример. Посмотрим на функцию фильтрации списков, она определена в <code><font color=Green>Prelude</font></code>:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>filter</font>  p  <font color=Green>[]</font>     <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>filter</font>  p  <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> <font color="#b2590f">if</font> p x <font color="#b2590f">then</font> x <font color="#b2590f">:</font> rest <font color="#b2590f">else</font> rest
    <font color="#b2590f">where</font> rest <font color="#b2590f">=</font> filter p xs</pre>
<p>Мы определили локальную переменную <code><font color=Black>rest</font></code>, которая указывает на рекурсивный вызов функции на оставшейся части списка.</p>
<p><code><font color="#b2590f">where</font></code>-выражения определяются для каждого уравнения в определении функции:</p>
<pre><font color=Black>even</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>even</font> <font color=Green>Zero</font>        <font color="#b2590f">=</font> res
    <font color="#b2590f">where</font> res <font color="#b2590f">=</font> <font color=Green>True</font>
<font color=Black>even</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font> <font color="#b2590f">=</font> res
    <font color="#b2590f">where</font> res <font color="#b2590f">=</font> <font color=Green>False</font>
<font color=Black>even</font> x <font color="#b2590f">=</font> even res
    <font color="#b2590f">where</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> res<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">=</font> x</pre>
<p>Конечно в этом примере <code><font color="#b2590f">where</font></code> не нужны, но здесь они приведены для иллюстрации привязки <code><font color="#b2590f">where</font></code>-выражения к данному уравнению. Мы определили три локальных переменных с одним и тем же именем.</p>
<p><code><font color="#b2590f">where</font></code>-выражения могут быть и у значений, которые определяются внутри <code><font color="#b2590f">where</font></code>-выражений. Но лучше избегать сильно вложенных выражений.</p>
<h3 id="let-выражения"><a href="#let-выражения">let-выражения</a></h3>
<p>В композиционном стиле функция вычисления площади треугольника будет выглядеть так:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> <font color="#b2590f">let</font> p <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font>
               <font color="#b2590f">in</font>  sqrt <font color=Black>(</font>p <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font> </pre>
<p>Слова  <code><font color="#b2590f">let</font></code> и <code><font color="#b2590f">in</font></code> – ключевые. Выгодным отличием <code><font color="#b2590f">let</font></code>-выражений является то, что они являются обычными выражениями и не привязаны к определённому месту как <code><font color="#b2590f">where</font></code>-выражения. Они могут участвовать в любой части обычного выражения:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> <font color="#b2590f">let</font> p <font color="#b2590f">=</font> <font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font>
               <font color="#b2590f">in</font>  sqrt <font color=Black>(</font><font color=Black>(</font><font color="#b2590f">let</font> pa <font color="#b2590f">=</font> p <font color="#2149c1">-</font> a <font color="#b2590f">in</font> p <font color=Black>*</font> pa<font color=Black>)</font> <font color=Black>*</font> 
                         <font color=Black>(</font><font color="#b2590f">let</font> pb <font color="#b2590f">=</font> p <font color="#2149c1">-</font> b
                              pc <font color="#b2590f">=</font> p <font color="#2149c1">-</font> c  
                          <font color="#b2590f">in</font>  pb <font color=Black>*</font> pc<font color=Black>)</font><font color=Black>)</font> </pre>
<p>В этом проявляется их принадлежность композиционному стилю. <code><font color="#b2590f">let</font></code>-выражения могут участвовать в любом подвыражении, они также группируются скобками. А <code><font color="#b2590f">where</font></code>-выражения привязаны к уравнениям в определении функции.</p>
<p>Также как и в <code><font color="#b2590f">where</font></code>-выражениях, в <code><font color="#b2590f">let</font></code>-выражениях слева от знака равно можно проводить декомпозицию значений.</p>
<pre><font color=Black>pred</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font>
<font color=Black>pred</font> x <font color="#b2590f">=</font> <font color="#b2590f">let</font> <font color=Black>(</font><font color=Green>Succ</font> y<font color=Black>)</font> <font color="#b2590f">=</font> x
         <font color="#b2590f">in</font>  y</pre>
<p>Определим функцию фильтрации списков через <code><font color="#b2590f">let</font></code>:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>filter</font>  p  <font color=Green>[]</font>     <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>filter</font>  p  <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> 
    <font color="#b2590f">let</font> rest <font color="#b2590f">=</font> filter p xs
    <font color="#b2590f">in</font>  <font color="#b2590f">if</font> p x <font color="#b2590f">then</font> x <font color="#b2590f">:</font> rest <font color="#b2590f">else</font> rest</pre>
<h2 id="декомпозиция"><a href="#декомпозиция">Декомпозиция</a></h2>
<p>Декомпозиция или сопоставление с образцом позволяет выделять из составных значений, простейшие значения с помощью которых они были построены</p>
<pre><font color=Black>pred</font> <font color=Black>(</font><font color=Green>Succ</font> x<font color=Black>)</font> <font color="#b2590f">=</font> x</pre>
<p>и организовывать условные вычисления которые зависят от вида поступающих на вход функции значений</p>
<pre><font color=Black>not</font> <font color=Green>True</font>  <font color="#b2590f">=</font> <font color=Green>False</font>
<font color=Black>not</font> <font color=Green>False</font> <font color="#b2590f">=</font> <font color=Green>True</font></pre>
<h3 id="сопоставление-с-образцом"><a href="#сопоставление-с-образцом">Сопоставление с образцом</a></h3>
<p>Декомпозицию в декларативном стиле мы уже изучили, это обычный случай разбора значений в аргументах функции. Рассмотрим одну полезную возможность при декомпозиции. Иногда нам хочется провести декомпозицию и дать псевдоним всему значению. Это можно сделать с помощью специального символа <code><font color="#b2590f">@</font></code>.</p>
<p>Например определим функцию, которая возвращает соседние числа для данного числа Пеано:</p>
<pre><font color=Black>beside</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Nat</font><font color=Black>,</font> <font color=Green>Nat</font><font color=Black>)</font>
<font color=Black>beside</font>  <font color=Green>Zero</font>       <font color="#b2590f">=</font> error <font color=Black>"undefined"</font>
<font color=Black>beside</font>  x<font color="#b2590f">@</font><font color=Black>(</font><font color=Green>Succ</font> y<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>y<font color=Black>,</font> <font color=Green>Succ</font> x<font color=Black>)</font></pre>
<p>В выражении <code><font color=Black>x</font><font color="#b2590f">@</font><font color=Black>`</font><font color=Black>`</font><font color=Black>(</font><font color=Green>Succ</font> y<font color=Black>)</font></code> мы одновременно проводим разбор и даём имя всему значению.</p>
<h3 id="case-выражения"><a href="#case-выражения">case-выражения</a></h3>
<p>Оказывается декомпозицию можно проводить в любом выражении, для этого существуют  <code><font color="#b2590f">case</font></code>-выражения:</p>
<pre><font color="#b2590f">data</font> <font color=Green>AnotherNat</font> <font color="#b2590f">=</font> <font color=Green>None</font> <font color="#b2590f">|</font> <font color=Green>One</font> <font color="#b2590f">|</font> <font color=Green>Two</font> <font color="#b2590f">|</font> <font color=Green>Many</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font>

<font color=Black>toAnother</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>AnotherNat</font>
<font color=Black>toAnother</font> x <font color="#b2590f">=</font> 
    <font color="#b2590f">case</font> x <font color="#b2590f">of</font>
        <font color=Green>Zero</font>                <font color="#b2590f">-&gt;</font> <font color=Green>None</font>
        <font color=Green>Succ</font> <font color=Green>Zero</font>           <font color="#b2590f">-&gt;</font> <font color=Green>One</font>
        <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>    <font color="#b2590f">-&gt;</font> <font color=Green>Two</font>
        <font color="#b2590f">_</font>                   <font color="#b2590f">-&gt;</font> <font color=Green>Many</font>

<font color=Black>fromAnother</font> <font color="#b2590f">::</font> <font color=Green>AnotherNat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font>
<font color=Black>fromAnother</font> <font color=Green>None</font>    <font color="#b2590f">=</font> <font color=Green>Zero</font>
<font color=Black>fromAnother</font> <font color=Green>One</font>     <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>Zero</font>
<font color=Black>fromAnother</font> <font color=Green>Two</font>     <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Black>fromAnother</font> <font color=Green>Many</font>    <font color="#b2590f">=</font> error <font color=Black>"undefined"</font> </pre>
<p>Слова <code><font color="#b2590f">case</font></code> и <code><font color="#b2590f">of</font></code> – ключевые. Выгодным отличием <code><font color="#b2590f">case</font></code>-выражений является то, что нам не приходится каждый раз выписывать имя функции. Обратите внимание на то, что в <code><font color="#b2590f">case</font></code>-выражениях также можно пользоваться обычными переменными и безымянными переменными.</p>
<p>Для проведения декомпозиции по нескольким переменным можно воспользоваться кортежами. Например определим знакомую функцию равенства для <code><font color=Green>Nat</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Eq</font> <font color=Green>Nat</font> <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>==</font><font color=Black>)</font> a b <font color="#b2590f">=</font>
        <font color="#b2590f">case</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">of</font>
            <font color=Black>(</font><font color=Green>Zero</font><font color=Black>,</font>    <font color=Green>Zero</font><font color=Black>)</font>     <font color="#b2590f">-&gt;</font> <font color=Green>True</font>
            <font color=Black>(</font><font color=Green>Succ</font> a'<font color=Black>,</font> <font color=Green>Succ</font> b'<font color=Black>)</font>  <font color="#b2590f">-&gt;</font> a' <font color=Black>==</font> b'
            <font color="#b2590f">_</font>                   <font color="#b2590f">-&gt;</font> <font color=Green>False</font></pre>
<p>Мы проводим сопоставление с образцом по кортежу <code><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font></code>, соответственно слева от знака <code><font color="#b2590f">-&gt;</font></code> мы проверяем значения в кортежах, для этого мы также заключаем значения в скобки и пишем их через запятую.</p>
<p>Давайте определим функцию <code><font color=Black>filter</font></code> в ещё более композиционном стиле. Для этого мы заменим в исходном определении <code><font color="#b2590f">where</font></code> на <code><font color="#b2590f">let</font></code> и декомпозицию в аргументах на <code><font color="#b2590f">case</font></code>-выражение:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>filter</font>  p  a <font color="#b2590f">=</font> 
    <font color="#b2590f">case</font> a <font color="#b2590f">of</font>
        <font color=Green>[]</font>      <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>
        x<font color="#b2590f">:</font>xs    <font color="#b2590f">-&gt;</font>  <font color="#b2590f">let</font> rest <font color="#b2590f">=</font> filter p xs
                    <font color="#b2590f">in</font>  <font color="#b2590f">if</font> <font color=Black>(</font>p x<font color=Black>)</font> 
                        <font color="#b2590f">then</font> <font color=Black>(</font>x<font color="#b2590f">:</font>rest<font color=Black>)</font>
                        <font color="#b2590f">else</font> rest</pre>
<h2 id="условные-выражения"><a href="#условные-выражения">Условные выражения</a></h2>
<p>С условными выражениями мы уже сталкивались в сопоставлении с образцом. Например в определении функции <code><font color=Black>not</font></code>:</p>
<pre><font color=Black>not</font> <font color=Green>True</font>  <font color="#b2590f">=</font> <font color=Green>False</font>
<font color=Black>not</font> <font color=Green>False</font> <font color="#b2590f">=</font> <font color=Green>True</font></pre>
<p>В зависимости от поступающего значения мы выбираем одну из двух альтернатив. Условные выражении в сопоставлении с образцом позволяют реагировать лишь на частичное (с учётом переменных) совпадение дерева значения в аргументах функции.</p>
<p>Часто нам хочется определить более сложные условия для альтернатив. Например, если значение на входе функции больше 2, но меньше 10, верни <code><font color=Green>A</font></code>, а если больше 10, верни <code><font color=Green>B</font></code>, а во всех остальных случаях верни <code><font color=Green>C</font></code>. Или если на вход поступила строка состоящая только из букв латинского алфавита, верни <code><font color=Green>A</font></code>, а в противном случае верни <code><font color=Green>B</font></code>. Нам бы хотелось реагировать лишь в том случае, если значение некоторого типа <code><font color=Black>a</font></code> удовлетворяет некоторому предикату. Предикатами обычно называют функции типа <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font></code>. Мы говорим, что значение удовлетворяет предикату, если предикат для этого значения возвращает <code><font color=Green>True</font></code>.</p>
<h3 id="охранные-выражения"><a href="#охранные-выражения">Охранные выражения</a></h3>
<p>В декларативном стиле условные выражения представлены <em>охранными выражениями</em> (guards). Предположим у нас есть тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>HowMany</font> <font color="#b2590f">=</font> <font color=Green>Little</font> <font color="#b2590f">|</font> <font color=Green>Enough</font> <font color="#b2590f">|</font> <font color=Green>Many</font></pre>
<p>И мы хотим написать функцию, которая принимает число людей, которые хотят посетить выставку, а возвращает значение типа <code><font color=Green>HowMany</font></code>. Эта функция оценивает вместительность выставочного зала. С помощью охранных выражений мы можем написать её так:</p>
<pre><font color=Black>hallCapacity</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>HowMany</font>
<font color=Black>hallCapacity</font> n
    <font color="#b2590f">|</font> n <font color=Black>&lt;</font> <font color="#0000ee">10</font>    <font color="#b2590f">=</font> <font color=Green>Little</font>
    <font color="#b2590f">|</font> n <font color=Black>&lt;</font> <font color="#0000ee">30</font>    <font color="#b2590f">=</font> <font color=Green>Enough</font>
    <font color="#b2590f">|</font> <font color=Green>True</font>      <font color="#b2590f">=</font> <font color=Green>Many</font></pre>
<p>Специальный символ <code><font color="#b2590f">|</font></code> уже встречался нам в определении типов. Там он играл роль разделителя альтернатив в сумме типов. Здесь же он разделяет альтернативы в условных выражениях. Сначала мы пишем <code><font color="#b2590f">|</font></code> затем выражение-предикат, которое возвращает значение типа <code><font color=Green>Bool</font></code>, затем равно и после равно – возвращаемое значение. Альтернативы так же как и в случае декомпозиции аргументов функции обходятся сверху вниз, до тех пор пока в одной из альтернатив предикат не вернёт значение <code><font color=Green>True</font></code>. Обратите внимание на то, что нам не нужно писать во второй альтернативе:</p>
<pre>    <font color="#b2590f">|</font> <font color="#0000ee">10</font> <font color=Black>&lt;=</font> n <font color=Black>&amp;&amp;</font> n <font color=Black>&lt;</font> <font color="#0000ee">30</font>   <font color="#b2590f">=</font> <font color=Green>Enough</font></pre>
<p>Если вычислитель дошёл до этой альтернативы, значит значение точно больше либо равно <code><font color="#0000ee">10</font></code>. Поскольку в предыдущей альтернативе предикат вернул <code><font color=Green>False</font></code>.</p>
<p>Предикат в последней альтернативе является константой <code><font color=Green>True</font></code>, он пройдёт сопоставление с любым значением <code><font color=Black>n</font></code>. В данном случае, если учесть предыдущие альтернативы мы знаем, что если вычислитель дошёл до последней альтернативы , значение <code><font color=Black>n</font></code> больше либо равно <code><font color="#0000ee">30</font></code>. Для повышения наглядности кода в <code><font color=Green>Prelude</font></code> определена специальная константа-синоним значению <code><font color=Green>True</font></code> под именем <code><font color=Black>otherwise</font></code>.</p>
<p>Определим функцию <code><font color=Black>filter</font></code> для списков в более декларативном стиле, для этого заменим <code><font color="#b2590f">if</font></code>-выражение в исходной версии на охранные выражения:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>filter</font>  p  <font color=Green>[]</font>       <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>filter</font>  p  <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font>   
    <font color="#b2590f">|</font> p x           <font color="#b2590f">=</font> x <font color="#b2590f">:</font> rest
    <font color="#b2590f">|</font> otherwise     <font color="#b2590f">=</font> rest
    <font color="#b2590f">where</font> rest <font color="#b2590f">=</font> filter p xs</pre>
<p>Или мы можем разместить охранные выражения по-другому:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>filter</font>  p  <font color=Green>[]</font>                   <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>filter</font>  p  <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font>   <font color="#b2590f">|</font> p x       <font color="#b2590f">=</font> x <font color="#b2590f">:</font> rest
                    <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font> rest
    <font color="#b2590f">where</font> rest <font color="#b2590f">=</font> filter p xs</pre>
<p>Отметим то, что локальная переменная <code><font color=Black>rest</font></code> видна и в той и в другой альтернативе. Вы спокойно можете пользоваться локальными переменными в любой части уравнения, в котором они определены.</p>
<p>Определим с помощью охранных выражений функцию <code><font color=Black>all</font></code>, она принимает предикат и список, и проверяет удовлетворяют ли все элементы списка данному предикату.</p>
<pre><font color=Black>all</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>all</font> p <font color=Green>[]</font>        <font color="#b2590f">=</font> <font color=Green>True</font>
<font color=Black>all</font> p <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font>    
    <font color="#b2590f">|</font> p x       <font color="#b2590f">=</font> all p xs
    <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font> <font color=Green>False</font></pre>
<p>С помощью охранных выражений можно очень наглядно описывать условные выражения. Но иногда можно обойтись и простыми логическими операциями. Например функцию <code><font color=Black>all</font></code> можно было бы определить так:</p>
<pre><font color=Black>all</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>all</font>  p  <font color=Green>[]</font>        <font color="#b2590f">=</font> <font color=Green>True</font>
<font color=Black>all</font>  p  <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font>    <font color="#b2590f">=</font> p x <font color=Black>&amp;&amp;</font> all p xs</pre>
<p>Или так:</p>
<pre><font color=Black>all</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>all</font>  p  xs <font color="#b2590f">=</font> null <font color=Black>(</font>filter notP xs<font color=Black>)</font>
    <font color="#b2590f">where</font> notP x <font color="#b2590f">=</font> not <font color=Black>(</font>p x<font color=Black>)</font></pre>
<p>Или даже так:</p>
<pre><font color="#b2590f">import</font> <font color=Green>Prelude</font><font color=Black>(</font>all<font color=Black>)</font></pre>
<p>Функция <code><font color=Black>null</font></code> определена в <code><font color=Green>Prelude</font></code> она возвращает <code><font color=Green>True</font></code> только если список пуст.</p>
<h3 id="if-выражения"><a href="#if-выражения">if-выражения</a></h3>
<p>В композиционном стиле в качестве условных выражений используются уже знакомые нам <code><font color="#b2590f">if</font></code>-выражения. Вспомним как они выглядят:</p>
<pre><font color=Black>a</font> <font color="#b2590f">=</font> <font color="#b2590f">if</font> bool 
    <font color="#b2590f">then</font> x1
    <font color="#b2590f">else</font> x2</pre>
<p>Слова <code><font color="#b2590f">if</font></code>, <code><font color="#b2590f">then</font></code> и <code><font color="#b2590f">else</font></code> – ключевые. Тип <code><font color=Black>a</font></code>, <code><font color=Black>x1</font></code> и <code><font color=Black>x2</font></code> совпадают.</p>
<p>Любое охранное выражение, в котором больше одной альтернативы, можно представить в виде <code><font color="#b2590f">if</font></code>-выражения и наоборот. Перепишем все функции их предыдущего подраздела с помощью <code><font color="#b2590f">if</font></code>-выражений:</p>
<pre><font color=Black>hallCapacity</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>HowMany</font>
<font color=Black>hallCapacity</font> n <font color="#b2590f">=</font>
    <font color="#b2590f">if</font> <font color=Black>(</font>n <font color=Black>&lt;</font> <font color="#0000ee">10</font><font color=Black>)</font>
    <font color="#b2590f">then</font> <font color=Green>Little</font>
    <font color="#b2590f">else</font> <font color=Black>(</font><font color="#b2590f">if</font> n <font color=Black>&lt;</font> <font color="#0000ee">30</font> 
          <font color="#b2590f">then</font> <font color=Green>Enough</font>
          <font color="#b2590f">else</font> <font color=Green>Many</font><font color=Black>)</font>

<font color=Black>all</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>all</font> p <font color=Green>[]</font>     <font color="#b2590f">=</font> <font color=Green>True</font>
<font color=Black>all</font> p <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> <font color="#b2590f">if</font> <font color=Black>(</font>p x<font color=Black>)</font> <font color="#b2590f">then</font> all p xs <font color="#b2590f">else</font> <font color=Green>False</font></pre>
<h2 id="определение-функций"><a href="#определение-функций">Определение функций</a></h2>
<p>Под функцией мы понимаем составной синоним, который принимает аргументы, возможно разбирает их на части и составляет из этих частей новые выражения. Теперь посмотрим как такие синонимы определяются в каждом из стилей.</p>
<h3 id="уравнения"><a href="#уравнения">Уравнения</a></h3>
<p>В декларативном стиле функции определяются с помощью уравнений. Пока мы видели лишь этот способ определения функций, примерами могут служить все предыдущие примеры. Вкратце напомним, что функция определяется набором уравнений вида:</p>
<pre><font color=Black>name</font> декомпозиция1 <font color="#b2590f">=</font> композиция1
<font color=Black>name</font> декомпозиция2 <font color="#b2590f">=</font> композиция2
<font color=Black>...</font>
<font color=Black>name</font> декомпозицияN <font color="#b2590f">=</font> композицияN</pre>
<p>Где <code><font color=Black>name</font></code> – имя функции. В <code><font color=Black>декомпозиции</font></code> происходит разбор поступающих на вход значений, а в <code><font color=Black>композиции</font></code> происходит составление значения результата. Уравнения обходятся вычислителем сверху вниз до тех пор пока он не найдёт такое уравнение, для которого переданные в функции значения не подойдут в указанный в декомпозиции шаблон значений (если сопоставление с образцом аргументов пройдёт успешно). Как только такое уравнение найдено, составляется выражение справа от знака равно (<code><font color=Black>композиция</font></code>). Это значение будет результатом функции. Если такое уравнение не будет найдено программа остановится с ошибкой.</p>
<p>К примеру попробуйте вычислить в интерпретаторе выражение <code><font color=Black>notT</font> <font color=Green>False</font></code>, для такой функции:</p>
<pre><font color=Black>notT</font> <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>notT</font> <font color=Green>True</font> <font color="#b2590f">=</font> <font color=Green>False</font></pre>
<p>Что мы увидим?</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> notT <font color=Green>False</font>
<font color=Black>***</font> <font color=Green>Exception</font><font color="#b2590f">:</font> <font color=Black>&lt;</font>interactive<font color=Black>&gt;:</font><font color="#0000ee">1</font><font color="#b2590f">:</font><font color="#0000ee">4</font><font color="#2149c1">-</font><font color="#0000ee">20</font><font color="#b2590f">:</font> <font color=Green>Non</font><font color="#2149c1">-</font>exhaustive patterns <font color="#b2590f">in</font> function notT</pre>
<p>Интерпретатор сообщил нам о том, что он не нашёл уравнения для переданного в функцию значения.</p>
<h3 id="безымянные-функции"><a href="#безымянные-функции">Безымянные функции</a></h3>
<p>В композиционном стиле функции определяются по-другому. Это необычный метод, он пришёл в Haskell из лямбда-исчисления. Функции строятся с помощью специальных конструкций, которые называются лямбда-функциями. По сути лямбда-функции являются безымянными функциями. Давайте посмотрим на лямбда функцию, которая прибавляет к аргументу единицу:</p>
<pre><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x <font color=Black>+</font> <font color="#0000ee">1</font></pre>
<p>Для того, чтобы превратить лямбда-функцию в обычную функцию мысленно замените знак <code><font color="#b2590f">\</font></code> на имя <code><font color=Black>noName</font></code>, а стрелку на знак равно:</p>
<pre><font color=Black>noName</font> x <font color="#b2590f">=</font> x <font color=Black>+</font> <font color="#0000ee">1</font></pre>
<p>Мы получили обычную функцию Haskell, с такими мы уже много раз встречались. Зачем специальный синтаксис для определения безымянных функций? Ведь можно определить её в виде уравнений. К тому же кому могут понадобиться безымянные функции? Ведь смысл функции в том, чтобы выделить определённый шаблон поведения и затем ссылаться на него по имени функции.</p>
<p>Смысл безымянной функции в том, что ею, также как и любым другим элементом композиционного стиля, можно пользоваться в любой части обычных выражений. С её помощью мы можем создавать функции “на лету”. Предположим, что мы хотим профильтровать список чисел, мы хотим выбрать из них лишь те, что меньше 10, но больше 2, и к тому же они должны быть чётными. Мы можем написать:</p>
<pre><font color=Black>f</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font>
<font color=Black>f</font> <font color="#b2590f">=</font> filter p
    <font color="#b2590f">where</font> p x <font color="#b2590f">=</font> x <font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color=Black>&amp;&amp;</font> x <font color=Black>&lt;</font> <font color="#0000ee">10</font> <font color=Black>&amp;&amp;</font> even x</pre>
<p>При этом нам приходится давать какое-нибудь имя предикату, например <code><font color=Black>p</font></code>. С помощью безымянной функции мы могли бы написать так:</p>
<pre><font color=Black>f</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font>
<font color=Black>f</font> <font color="#b2590f">=</font> filter <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x <font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color=Black>&amp;&amp;</font> x <font color=Black>&lt;</font> <font color="#0000ee">10</font> <font color=Black>&amp;&amp;</font> even x<font color=Black>)</font></pre>
<p>Смотрите мы составили предикат сразу в аргументе функции <code><font color=Black>filter</font></code>. Выражение <code><font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x <font color=Black>&gt;</font> <font color="#0000ee">2</font> <font color=Black>&amp;&amp;</font> x <font color=Black>&lt;</font> <font color="#0000ee">10</font> <font color=Black>&amp;&amp;</font> even x<font color=Black>)</font></code> является обычным значением.</p>
<p>Возможно у вас появился вопрос, где аргумент функции? Где тот список по которому мы проводим фильтрацию. Ответ на этот вопрос кроется в частичном применении. Давайте вычислим по правилу применения тип функции <code><font color=Black>filter</font></code>:</p>
<pre>    f <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>,</font>    x <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font>
    <font color="#2149c1">------------------------------------------------------</font>
                <font color=Black>(</font>f x<font color=Black>)</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font></pre>
<p>После применения параметр <code><font color=Black>a</font></code> связывается с типом <code><font color=Green>Int</font></code>, поскольку при применении происходит сопоставление более общего предиката <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font></code> из функции <code><font color=Black>filter</font></code> с тем, который мы передали первым аргументом <code><font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font></code>. После этого мы получаем тип <code><font color=Black>(</font>f x<font color=Black>)</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font></code> это как раз тип функции, которая принимает список целых чисел и возвращает список целых чисел. Частичное применение позволяет нам не писать в таких выражениях:</p>
<pre><font color=Black>f</font> xs <font color="#b2590f">=</font> filter p xs
    <font color="#b2590f">where</font> p x <font color="#b2590f">=</font> <font color=Black>...</font></pre>
<p>последний аргумент <code><font color=Black>xs</font></code>.</p>
<p>К примеру вместо</p>
<pre><font color=Black>add</font> a b <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> a b</pre>
<p>мы можем просто написать:</p>
<pre><font color=Black>add</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font></pre>
<p>Такой стиль определения функций называют <em>бесточечным</em> (point-free).</p>
<p>Давайте выразим функцию <code><font color=Black>filter</font></code> с помощью лямбда-функций:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font>
<font color=Black>filter</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>p <font color="#b2590f">-&gt;</font> <font color="#b2590f">\</font>xs <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> xs <font color="#b2590f">of</font>
    <font color=Green>[]</font>     <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>
    <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">let</font> rest <font color="#b2590f">=</font> filter p xs
              <font color="#b2590f">in</font>  <font color="#b2590f">if</font>   p x
                  <font color="#b2590f">then</font> x <font color="#b2590f">:</font> rest
                  <font color="#b2590f">else</font> rest</pre>
<p>Мы определили функцию <code><font color=Black>filter</font></code> пользуясь только элементами композиционного стиля. Обратите внимание на скобки в объявлении типа функции. Я хотел напомнить вам о том, что все функции в Haskell являются функциями одного аргумента. Это определение функции <code><font color=Black>filter</font></code> как нельзя лучше подчёркивает этот факт. Мы говорим, что функция <code><font color=Black>filter</font></code> является функцией одного аргумента <code><font color=Black>p</font></code> в выражении <code><font color="#b2590f">\</font>p <font color="#b2590f">-&gt;</font></code>, которая возвращает также функцию одного аргумента. Мы выписываем это в явном виде в выражении <code><font color="#b2590f">\</font>xs <font color="#b2590f">-&gt;</font></code>. Далее идёт выражение, которое содержит определение функции.</p>
<p>Отметим, что лямбда функции могут принимать несколько аргументов, в предыдущем определении мы могли бы написать:</p>
<pre><font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font>
<font color=Black>filter</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>p xs <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> xs <font color="#b2590f">of</font>
    <font color=Black>...</font></pre>
<p>но это лишь синтаксический сахар, который разворачивается в предыдущую запись.</p>
<p>Для тренировки определим несколько стандартных функций для работы с кортежами с помощью лямбда-функций (все они определены в <code><font color=Green>Prelude</font></code>):</p>
<pre><font color=Black>fst</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>fst</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font><font color=Black>(</font>a<font color=Black>,</font> <font color="#b2590f">_</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> a

<font color=Black>snd</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> b
<font color=Black>snd</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font><font color=Black>(</font><font color="#b2590f">_</font><font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> b

<font color=Black>swap</font> <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> a<font color=Black>)</font>
<font color=Black>swap</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> a<font color=Black>)</font></pre>
<p>Обратите внимание на то, что все функции словно являются константами. Они не содержат аргументов. Аргументы мы “пристраиваем” с помощью безымянных функций.</p>
<p>Определим функции преобразования первого и второго элемента кортежа (эти функции определены в модуле <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Arrow</font></code>)</p>
<pre><font color=Black>first</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a'<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a'<font color=Black>,</font> b<font color=Black>)</font>
<font color=Black>first</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>f <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>f a<font color=Black>,</font> b<font color=Black>)</font>

<font color=Black>second</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> b'<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> b'<font color=Black>)</font>
<font color=Black>second</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>f <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> f b<font color=Black>)</font></pre>
<p>Также в <code><font color=Green>Prelude</font></code> есть полезные функции, которые превращают функции с частичным применением в обычны функции и наоборот:</p>
<pre><font color=Black>curry</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c
<font color=Black>curry</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>f <font color="#b2590f">-&gt;</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">\</font>b <font color="#b2590f">-&gt;</font> f <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font>

<font color=Black>uncurry</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>
<font color=Black>uncurry</font> <font color="#b2590f">=</font> <font color="#b2590f">\</font>f <font color="#b2590f">-&gt;</font> <font color="#b2590f">\</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a b</pre>
<p>Функция <code><font color=Black>curry</font></code> принимает функцию двух аргументов для которой частичное применение невозможно. Это имитируется с помощью кортежей. Функция принимает кортеж из двух элементов. Функция <code><font color=Black>curry</font></code> (от слова каррирование, частичное применение) превращает такую функцию в обычную функцию Haskell. А функция <code><font color=Black>uncurry</font></code> выполняет обратное преобразование.</p>
<p>С помощью лямбда-функций можно имитировать локальные переменные. Так например можно переписать формулу для вычисления площади треугольника:</p>
<pre><font color=Black>square</font> a b c <font color="#b2590f">=</font> 
    <font color=Black>(</font><font color="#b2590f">\</font>p <font color="#b2590f">-&gt;</font> sqrt <font color=Black>(</font>p <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> a<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>*</font> <font color=Black>(</font>p <font color="#2149c1">-</font> c<font color=Black>)</font><font color=Black>)</font><font color=Black>)</font> 
    <font color=Black>(</font><font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font><font color=Black>)</font></pre>
<p>Смотрите мы определили функцию, которая принимает параметром полупериметр <code><font color=Black>p</font></code> и передали в неё значение <code><font color=Black>(</font><font color=Black>(</font>a <font color=Black>+</font> b <font color=Black>+</font> c<font color=Black>)</font> <font color=Black>/</font> <font color="#0000ee">2</font><font color=Black>)</font></code>. Если в нашей функции несколько локальных переменных, то мы можем составить лямбда-функцию от нескольких переменных и подставить в неё нужные значения.</p>
<h2 id="какой-стиль-лучше"><a href="#какой-стиль-лучше">Какой стиль лучше?</a></h2>
<p>Основной критерий выбора заключается в том, сделает ли этот элемент код более <em>ясным</em>. Наглядность кода станет залогом успешной поддержки. Его будет легче понять и улучшить при необходимости.</p>
<p>Далее мы рассмотрим несколько примеров определений из <code><font color=Green>Prelude</font></code> и подумаем, почему был выбран тот или иной стиль. Начнём с класса <code><font color=Green>Ord</font></code> и посмотрим на определения по умолчанию:</p>
<pre><font color="#2149c1">-- Тип упорядочивания</font>

<font color="#b2590f">data</font>  <font color=Green>Ordering</font>  <font color="#b2590f">=</font>  <font color=Green>LT</font> <font color="#b2590f">|</font> <font color=Green>EQ</font> <font color="#b2590f">|</font> <font color=Green>GT</font>
          <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Eq</font><font color=Black>,</font> <font color=Green>Ord</font><font color=Black>,</font> <font color=Green>Enum</font><font color=Black>,</font> <font color=Green>Read</font><font color=Black>,</font> <font color=Green>Show</font><font color=Black>,</font> <font color=Green>Bounded</font><font color=Black>)</font>


<font color="#b2590f">class</font>  <font color=Black>(</font><font color=Green>Eq</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Ord</font> a  <font color="#b2590f">where</font>
    compare              <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Ordering</font>
    <font color=Black>(</font><font color=Black>&lt;</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&lt;=</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;=</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
    max<font color=Black>,</font> min             <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a

        <font color="#2149c1">-- Минимальное полное определение:</font>
        <font color="#2149c1">--      (&lt;=) или compare</font>
        <font color="#2149c1">-- Использование compare может оказаться более </font>
        <font color="#2149c1">-- эффективным для сложных типов.</font>
    compare x y
         <font color="#b2590f">|</font> x <font color=Black>==</font> y    <font color="#b2590f">=</font>  <font color=Green>EQ</font>
         <font color="#b2590f">|</font> x <font color=Black>&lt;=</font> y    <font color="#b2590f">=</font>  <font color=Green>LT</font>
         <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font>  <font color=Green>GT</font>

    x <font color=Black>&lt;=</font> y           <font color="#b2590f">=</font>  compare x y <font color=Black>/=</font> <font color=Green>GT</font>
    x <font color=Black>&lt;</font>  y           <font color="#b2590f">=</font>  compare x y <font color=Black>==</font> <font color=Green>LT</font>
    x <font color=Black>&gt;=</font> y           <font color="#b2590f">=</font>  compare x y <font color=Black>/=</font> <font color=Green>LT</font>
    x <font color=Black>&gt;</font>  y           <font color="#b2590f">=</font>  compare x y <font color=Black>==</font> <font color=Green>GT</font>

    max x y 
         <font color="#b2590f">|</font> x <font color=Black>&lt;=</font> y    <font color="#b2590f">=</font>  y
         <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font>  x
    min x y
         <font color="#b2590f">|</font> x <font color=Black>&lt;=</font> y    <font color="#b2590f">=</font>  x
         <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font>  y</pre>
<p>Все функции определены в декларативном стиле. Тип <code><font color=Green>Ordering</font></code> кодирует результат операции сравнения. Два числа могут быть либо равны (значение <code><font color=Green>EQ</font></code>), либо первое меньше второго (значение <code><font color=Green>LT</font></code>), либо первое больше второго (значение <code><font color=Green>GT</font></code>).</p>
<p>Обратите внимание на функцию <code><font color=Black>compare</font></code>. Мы не пишем дословное определение значений типа <code><font color=Green>Ordering</font></code>:</p>
<pre>    compare x y
         <font color="#b2590f">|</font> x <font color=Black>==</font> y    <font color="#b2590f">=</font>  <font color=Green>EQ</font>
         <font color="#b2590f">|</font> x <font color=Black>&lt;</font>  y    <font color="#b2590f">=</font>  <font color=Green>LT</font>
         <font color="#b2590f">|</font> x <font color=Black>&gt;</font>  y    <font color="#b2590f">=</font>  <font color=Green>GT</font></pre>
<p>В этом случае функция <code><font color=Black>compare</font></code> была бы определена через две других функции класса <code><font color=Green>Ord</font></code>, а именно больше <code><font color=Black>&gt;</font></code> и меньше <code><font color=Black>&lt;</font></code>. Мы же хотим минимизировать число функций в этом определении. Поэтому вместо этого определения мы полагаемся на очерёдность обхода альтернатив в охранном выражении.</p>
<p>Если первый случай не прошёл, то во втором случае нет разницы между функциями <code><font color=Black>&lt;</font></code> и <code><font color=Black>&lt;=</font></code>. А если не прошёл и этот случай, то остаётся только вернуть значение <code><font color=Green>GT</font></code>. Так мы определили функцию <code><font color=Black>compare</font></code> через одну функцию класса <code><font color=Green>Ord</font></code>.</p>
<p>Теперь посмотрим на несколько полезных функций для списков. Посмотрим на три основные функции для списков, одна из них возможно вам уже порядком поднадоела:</p>
<pre><font color="#2149c1">-- Преобразование списка</font>
<font color=Black>map</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font>
<font color=Black>map</font> f <font color=Green>[]</font>     <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>map</font> f <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> f x <font color="#b2590f">:</font> map f xs

<font color="#2149c1">-- Фильтрация списка</font>
<font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>filter</font> p <font color=Green>[]</font>                 <font color="#b2590f">=</font> <font color=Green>[]</font>
<font color=Black>filter</font> p <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">|</font> p x       <font color="#b2590f">=</font> x <font color="#b2590f">:</font> filter p xs
                <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font> filter p xs

<font color="#2149c1">-- Свёртка списка</font>
<font color=Black>foldr</font>            <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> b
<font color=Black>foldr</font> f z <font color=Green>[]</font>     <font color="#b2590f">=</font>  z
<font color=Black>foldr</font> f z <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font>  f x <font color=Black>(</font>foldr f z xs<font color=Black>)</font></pre>
<p>Приведём несколько примеров для функции <code><font color=Black>foldr</font></code>:</p>
<pre><font color=Black>and</font><font color=Black>,</font> or <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Bool</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>and</font> <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>&amp;&amp;</font><font color=Black>)</font> <font color=Green>True</font>
<font color=Black>or</font>  <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>||</font><font color=Black>)</font> <font color=Green>False</font>

<font color=Black>(</font><font color=Black>++</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Green>[]</font>     <font color=Black>++</font> ys <font color="#b2590f">=</font> ys
<font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color=Black>++</font> ys <font color="#b2590f">=</font> x <font color="#b2590f">:</font> <font color=Black>(</font>xs <font color=Black>++</font> ys<font color=Black>)</font>
    
<font color=Black>concat</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>concat</font> <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>++</font><font color=Black>)</font> <font color=Green>[]</font></pre>
<p>Функции <code><font color=Black>and</font></code> и <code><font color=Black>or</font></code> выполняют логические операции на списках. Так каждый конструктор <code><font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font></code> заменяется на соответствующую логическую операцию, а пустой список заменяется на значение, которое не влияет на результат выполнения данной логической операции. Имеется ввиду, что функции <code><font color=Black>(</font><font color=Black>&amp;&amp;</font> <font color=Green>True</font><font color=Black>)</font></code> и <code><font color=Black>(</font><font color=Black>||</font> <font color=Green>False</font><font color=Black>)</font></code> дают тот же результат, что и функция <code><font color=Black>id</font> x <font color="#b2590f">=</font> x</code>. Функция <code><font color=Black>(</font><font color=Black>++</font><font color=Black>)</font></code> объединяет два списка, а функция <code><font color=Black>concat</font></code> выполняет ту же операцию, но на списке списков.</p>
<p>Функция <code><font color=Black>zip</font></code> принимает два списка и смешивает их в список пар. Как только один из списков оборвётся оборвётся и список-результат. Эта функция является частным случаем более общей функции <code><font color=Black>zipWith</font></code>, которая принимает функцию двух аргументов и два списка и составляет новый список попарных применений.</p>
<pre><font color="#2149c1">-- zip-ы </font>
<font color=Black>zip</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font><font color="#b2590f">]</font>
<font color=Black>zip</font> <font color="#b2590f">=</font> zipWith <font color=Green>(,)</font>

<font color=Black>zipWith</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>c<font color="#b2590f">]</font>
<font color=Black>zipWith</font> z <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font> <font color=Black>(</font>b<font color="#b2590f">:</font>bs<font color=Black>)</font> <font color="#b2590f">=</font>  z a b <font color="#b2590f">:</font> zipWith z <font color="#b2590f">as</font> bs
<font color=Black>zipWith</font> <font color="#b2590f">_</font> <font color="#b2590f">_</font> <font color="#b2590f">_</font>           <font color="#b2590f">=</font>  <font color=Green>[]</font></pre>
<p>Посмотрим как работают эти функции в интерпретаторе:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> zip <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font> <font color=Black>"hello"</font>
<font color="#b2590f">[</font><font color=Black>(</font><font color="#0000ee">1</font><font color=Black>,</font><font color=Black>'h'</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color="#0000ee">2</font><font color=Black>,</font><font color=Black>'e'</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color="#0000ee">3</font><font color=Black>,</font><font color=Black>'l'</font><font color=Black>)</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> zipWith <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font> <font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">1</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> zipWith <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font> <font color="#b2590f">[</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">1</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">9</font><font color="#b2590f">]</font></pre>
<p>Отметим, что в <code><font color=Green>Prelude</font></code> также определена обратная функция <code><font color=Black>unzip</font></code>:</p>
<pre><font color=Black>unzip</font>   <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Black>(</font>a<font color=Black>,</font>b<font color=Black>)</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font><font color=Black>)</font> </pre>
<p>Она берёт список пар и разбивает его на два списка.</p>
<p>Пока по этим определениям кажется, что композиционный стиль совсем нигде не применяется. Он встретился нам лишь в функции <code><font color=Black>break</font></code>. Но давайте посмотрим и на функции с композиционным стилем:</p>
<pre><font color=Black>lines</font>            <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>String</font><font color="#b2590f">]</font>
<font color=Black>lines</font> <font color=Black>""</font>         <font color="#b2590f">=</font>  <font color=Green>[]</font>
<font color=Black>lines</font> s          <font color="#b2590f">=</font>  <font color="#b2590f">let</font> <font color=Black>(</font>l<font color=Black>,</font> s'<font color=Black>)</font> <font color="#b2590f">=</font> break <font color=Black>(</font><font color=Black>==</font> <font color=Black>'\n'</font><font color=Black>)</font> s
                    <font color="#b2590f">in</font>  l <font color="#b2590f">:</font> <font color="#b2590f">case</font> s' <font color="#b2590f">of</font>
                              <font color=Green>[]</font>      <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>
                              <font color=Black>(</font><font color="#b2590f">_</font><font color="#b2590f">:</font>s''<font color=Black>)</font> <font color="#b2590f">-&gt;</font> lines s''</pre>
<p>Функция <code><font color=Black>lines</font></code> разбивает строку на список строк. Эти строки были разделены в исходной строке символом переноса <code><font color=Black>'\n'</font></code>.</p>
<p>Функция <code><font color=Black>break</font></code> принимает предикат и список и возвращает два списка. В первом все элементы от начала списка, которые не удовлетворяют предикату, а во втором все остальные. Наш предикат <code><font color=Black>(</font><font color=Black>==</font> <font color=Black>'\n'</font><font color=Black>)</font></code> выделяет все символы кроме переноса каретки. В строке</p>
<pre><font color="#b2590f">let</font> <font color=Black>(</font>l<font color=Black>,</font> s'<font color=Black>)</font> <font color="#b2590f">=</font> break <font color=Black>(</font><font color=Black>==</font> <font color=Black>'\n'</font><font color=Black>)</font> s</pre>
<p>Мы сохраняем все символы до <code><font color=Black>'\n'</font></code> от начала строки в переменной <code><font color=Black>l</font></code>. Затем мы рекурсивно вызываем функцию <code><font color=Black>lines</font></code> на оставшейся части списка:</p>
<pre>                    <font color="#b2590f">in</font>  l <font color="#b2590f">:</font> <font color="#b2590f">case</font> s' <font color="#b2590f">of</font>
                              <font color=Green>[]</font>      <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>
                              <font color=Black>(</font><font color="#b2590f">_</font><font color="#b2590f">:</font>s''<font color=Black>)</font> <font color="#b2590f">-&gt;</font> lines s''</pre>
<p>При этом мы пропускаем в <code><font color=Black>s'</font></code> первый элемент, поскольку он содержит символ переноса каретки.</p>
<p>Посмотрим на ещё одну функцию для работы со строками.</p>
<pre><font color=Black>words</font>            <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>String</font><font color="#b2590f">]</font>
<font color=Black>words</font> s          <font color="#b2590f">=</font>  <font color="#b2590f">case</font> dropWhile <font color=Green>Char</font><font color=Black>.</font>isSpace s <font color="#b2590f">of</font>
                      <font color=Black>""</font> <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>
                      s' <font color="#b2590f">-&gt;</font> w <font color="#b2590f">:</font> words s''
                            <font color="#b2590f">where</font> <font color=Black>(</font>w<font color=Black>,</font> s''<font color=Black>)</font> <font color="#b2590f">=</font> break <font color=Green>Char</font><font color=Black>.</font>isSpace s'</pre>
<p>Функция <code><font color=Black>words</font></code> делает тоже самое, что и <code><font color=Black>lines</font></code>, только теперь в качестве разделителя выступает пробел. Функция <code><font color=Black>dropWhile</font></code> отбрасывает от начала списка все элементы, которые удовлетворяют предикату. В строке</p>
<pre><font color="#b2590f">case</font> dropWhile <font color=Green>Char</font><font color=Black>.</font>isSpace s <font color="#b2590f">of</font></pre>
<p>Мы одновременно отбрасываем все первые пробелы и готовим значение для декомпозиции. Дальше мы рассматриваем два возможных случая для строк.</p>
<pre>                      <font color=Black>""</font> <font color="#b2590f">-&gt;</font> <font color=Green>[]</font>  
                      s' <font color="#b2590f">-&gt;</font> w <font color="#b2590f">:</font> words s''
                            <font color="#b2590f">where</font> <font color=Black>(</font>w<font color=Black>,</font> s''<font color=Black>)</font> <font color="#b2590f">=</font> break <font color=Green>Char</font><font color=Black>.</font>isSpace s'</pre>
<p>Если строка пуста, то делать больше нечего. Если – нет, мы также как и в предыдущей функции применяем функцию <code><font color=Black>break</font></code> для того, чтобы выделить все элементы кроме пробела, а затем рекурсивно вызываем функцию <code><font color=Black>words</font></code> на оставшейся части списка.</p>
<h2 id="краткое-содержание"><a href="#краткое-содержание">Краткое содержание</a></h2>
<p>В этой главе мы узнали очень много новых синтаксических конструкций для определения функций. Они появлялись парами. Сведём их в таблицу:</p>
<table>
<col width="28%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr class="header">
<th align="left">Элемент</th>
<th align="left">Декларативный стиль</th>
<th align="left">Композиционный</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><p>Локальные переменные</p></td>
<td align="left"><p><code><font color="#b2590f">where</font></code>-выражения</p></td>
<td align="left"><p><code><font color="#b2590f">let</font></code>-выражения</p></td>
</tr>
<tr class="even">
<td align="left"><p>Декомпозиция</p></td>
<td align="left"><p>Сопоставление с образцом</p></td>
<td align="left"><p><code><font color="#b2590f">case</font></code>-выражения</p></td>
</tr>
<tr class="odd">
<td align="left"><p>Условные выражения</p></td>
<td align="left"><p>Охранные выражения</p></td>
<td align="left"><p><code><font color="#b2590f">if</font></code>-выражения</p></td>
</tr>
<tr class="even">
<td align="left"><p>Определение функций</p></td>
<td align="left"><p>Уравнения</p></td>
<td align="left"><p>лямбда-функции</p></td>
</tr>
</tbody>
</table>
<h4 id="особенности-синтаксиса"><a href="#особенности-синтаксиса">Особенности синтаксиса</a></h4>
<p>Нам встретилась новая конструкция в сопоставлении с образцом:</p>
<pre><font color=Black>beside</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Nat</font><font color=Black>,</font> <font color=Green>Nat</font><font color=Black>)</font>
<font color=Black>beside</font>  <font color=Green>Zero</font>       <font color="#b2590f">=</font> error <font color=Black>"undefined"</font>
<font color=Black>beside</font>  x<font color="#b2590f">@</font><font color=Black>(</font><font color=Green>Succ</font> y<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>y<font color=Black>,</font> <font color=Green>Succ</font> x<font color=Black>)</font></pre>
<p>Она позволяет проводить декомпозицию и давать имя всему значению одновременно. Такие выражения <code><font color=Black>x</font><font color="#b2590f">@</font><font color=Black>(</font><font color=Black>...</font><font color=Black>)</font></code> в англоязычной литературе принято называть as-patterns.</p>
<h2 id="упражнения"><a href="#упражнения">Упражнения</a></h2>
<ul>
<li><p>В этой главе нам встретилось много полезных стандартных функций, потренируйтесь с ними в интерпретаторе. Вызывайте их с различными значениями, экспериментируйте.</p></li>
<li><p>Попробуйте определить функции из предыдущих глав в чисто композиционном стиле.</p></li>
<li><p>Посмотрите на те функции, которые мы прошли и попробуйте переписать их определения шиворот на выворот. Если вы видите, что элемент написан композиционном стиле перепишите его в декларативном и наоборот. Получившиеся функции могут показаться монстрами, но это упражнение может помочь вам в закреплении новых конструкций и почувствовать сильные и слабые стороны того или иного стиля.</p></li>
<li><p>Определите модуль, который будет вычислять площади простых фигур, треугольника, окружности, прямоугольника, трапеции. Помните, что фигуры могут задаваться различными способами.</p></li>
<li><p>Поток это бесконечный список, или список, у которого нет конструктора пустого списка:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Stream</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> <font color=Green>Stream</font> a</pre>
<p>Так например мы можем составить поток из всех чисел Пеано:</p>
<pre><font color=Black>nats</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> <font color=Green>Nat</font>
<font color=Black>nats</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> nats <font color=Black>(</font><font color=Green>Succ</font> a<font color=Black>)</font> </pre>
<p>Или поток, который содержит один и тот же элемент:</p>
<pre><font color=Black>constStream</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a
<font color=Black>constStream</font> a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> constStream a </pre>
<p>Напишите модуль для потоков. В первую очередь нам понадобятся функции выделения частей потока, поскольку мы не сможем распечатать поток целиком (ведь он бесконечный):</p>
<pre><font color="#2149c1">-- Первый элемент потока</font>
<font color=Black>head</font> <font color="#b2590f">::</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> a

<font color="#2149c1">-- Хвост потока, всё кроме первого элемента</font>
<font color=Black>tail</font> <font color="#b2590f">::</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a

<font color="#2149c1">-- n-тый элемент потока</font>
<font color=Black>(</font><font color=Black>!!</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> a

<font color="#2149c1">-- Берёт из потока несколько первых элементов:</font>
<font color=Black>take</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<p>Имена этих функций будут совпадать с именами функций для списков чтобы избежать коллизий имён мы воспользуемся квалифицированным импортом функций. Делается это так:</p>
<pre><font color="#b2590f">import</font> <font color="#b2590f">qualified</font> <font color=Green>Prelude</font> <font color="#b2590f">as</font> <font color=Green>P</font><font color=Black>(</font> определения <font color=Black>)</font></pre>
<p>Слова  <code><font color="#b2590f">qualified</font></code> и <code><font color="#b2590f">as</font></code> – ключевые. Теперь для использования функций из модуля <code><font color=Green>Prelude</font></code> мы будем писать <code><font color=Green>P</font><font color=Black>.</font>имяФункции</code>. Такие имена называются квалифицированными. Для того чтобы пользоваться квалифицированными именами только для тех функций, для которых возможна коллизия имён можно поступить так:</p>
<pre><font color="#b2590f">import</font> <font color="#b2590f">qualified</font> <font color=Green>Prelude</font> <font color="#b2590f">as</font> <font color=Green>P</font>
<font color="#b2590f">import</font> <font color=Green>Prelude</font></pre>
<p>Компилятор разберётся, какую функцию мы имеем в виду.</p>
<p>Для удобства тестирования можно определить такую функцию печати потоков:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Show</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Show</font> <font color=Black>(</font><font color=Green>Stream</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    show xs <font color="#b2590f">=</font>  showInfinity <font color=Black>(</font>show <font color=Black>(</font>take <font color="#0000ee">5</font> xs<font color=Black>)</font><font color=Black>)</font>
        <font color="#b2590f">where</font> showInfinity x <font color="#b2590f">=</font> <font color=Green>P</font><font color=Black>.</font>init x  <font color=Green>P</font><font color=Black>.++</font> <font color=Black>"..."</font></pre>
<p>Функция <code><font color=Green>P</font><font color=Black>.</font>init</code> выделяет все элементы списка кроме последнего. В данном случае она откусит от строки закрывающуюся скобку. После этого мы добавляем троеточие, как символ бесконечности списка.</p>
<p>Функции преобразования потоков:</p>
<pre><font color="#2149c1">-- Преобразование потока</font>
<font color=Black>map</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> b

<font color="#2149c1">-- Фильтрация потока</font>
<font color=Black>filter</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a

<font color="#2149c1">-- zip-ы для потоков:</font>
<font color=Black>zip</font> <font color="#b2590f">::</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> b <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font>

<font color=Black>zipWith</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> b <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> c </pre>
<p>Функция генерации потока:</p>
<pre><font color=Black>iterate</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Stream</font> a</pre>
<p>Эта функция принимает два аргумента: функцию следующего элемента потока и значение первого элемента потока и возвращает поток:</p>
<pre><font color=Black>iterate</font> f a <font color="#b2590f">=</font> a <font color="#b2590f">:&amp;</font> f a <font color="#b2590f">:&amp;</font> f <font color=Black>(</font>f a<font color=Black>)</font> <font color="#b2590f">:&amp;</font> f <font color=Black>(</font>f <font color=Black>(</font>f a<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">:&amp;</font> <font color=Black>...</font></pre>
<p>Так с помощью этой функции можно создать поток всех чисел Пеано от нуля или постоянный поток:</p>
<pre><font color=Black>nats</font>            <font color="#b2590f">=</font> iterate <font color=Green>Succ</font> <font color=Green>Zero</font> 
<font color=Black>constStream</font> a   <font color="#b2590f">=</font> iterate <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x<font color=Black>)</font> a</pre>
<p>Возможно вас удивляет тот факт, что в этом упражнении мы оперируем бесконечными значениями, но пока мы не будем вдаваться в детали того как это работает, просто попробуйте определить этот модуль и посмотрите в интерпретаторе, что получится.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="3.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="5.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="3" style="list-style-type: decimal">
<li>Типы
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="5" style="list-style-type: decimal">
<li>Функции высшего порядка
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
