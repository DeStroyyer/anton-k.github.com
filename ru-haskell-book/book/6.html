<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="./style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#функторы-и-монады-теория">Функторы и монады: теория</a><ul>
<li><a href="#композиция-функций">Композиция функций</a><ul>
<li><a href="#класс-category">Класс Category</a></li>
<li><a href="#специальные-функции">Специальные функции</a></li>
<li><a href="#взаимодействие-с-внешним-миром">Взаимодействие с внешним миром</a></li>
<li><a href="#три-композиции">Три композиции</a></li>
</ul></li>
<li><a href="#примеры-специальных-функций">Примеры специальных функций</a><ul>
<li><a href="#частично-определённые-функции">Частично определённые функции</a></li>
<li><a href="#многозначные-функции">Многозначные функции</a></li>
</ul></li>
<li><a href="#применение-функций">Применение функций</a><ul>
<li><a href="#применение-функций-многих-переменных">Применение функций многих переменных</a></li>
<li><a href="#несколько-полезных-функций">Несколько полезных функций</a></li>
</ul></li>
<li><a href="#функторы-и-монады">Функторы и монады</a><ul>
<li><a href="#функторы">Функторы</a></li>
<li><a href="#аппликативные-функторы">Аппликативные функторы</a></li>
<li><a href="#монады">Монады</a></li>
<li><a href="#свойства-классов">Свойства классов</a></li>
<li><a href="#полное-определение-классов">Полное определение классов</a></li>
<li><a href="#исторические-замечания">Исторические замечания</a></li>
</ul></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="5.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="7.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="функторы-и-монады-теория"><a href="#функторы-и-монады-теория">Функторы и монады: теория</a></h1>
<p>Мы научились комбинировать функции наиболее общего типа <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> b</code>. В этой главе мы посмотрим на специальные функции и способы их комбинирования. Специальными функциями мы будем называть такие функции, результат которых имеет некоторую известную нам структуру. Среди них функции, которые могут вычислить значение или упасть, или функции, которые возвращают сразу несколько вариантов значений. Для составления таких функций из простейших в Haskell предусмотрено несколько классов типов. Это функторы и монады. Их мы и рассмотрим в этой главе.</p>
<h2 id="композиция-функций"><a href="#композиция-функций">Композиция функций</a></h2>
<p>Центральной функцией этой главы будет функция композиции. Вспомним её определение для функций общего типа:</p>
<pre><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>
<font color=Black>f</font> <font color=Black>.</font> g <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> f <font color=Black>(</font>g x<font color=Black>)</font></pre>
<p>Композиция двух функций <code><font color=Black>f</font></code> и <code><font color=Black>g</font></code> это такая функция, в которой мы сначала применяем <code><font color=Black>g</font></code>, а затем <code><font color=Black>f</font></code>. Для того чтобы тип функции стал более наглядным, мы определим эту функцию немного по-другому. Мы поменяем аргументы местами.</p>
<pre><font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>
<font color=Black>f</font> <font color=Black>&gt;&gt;</font> g <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> g <font color=Black>(</font>f x<font color=Black>)</font></pre>
<p>Мы будем изображать функции кружками, а значения – стрелками. Значения словно текут от узла к узлу по стрелкам. Поскольку тип стрелки выходящей из <code><font color=Black>f</font></code> совпадает с типом стрелки входящей в <code><font color=Black>g</font></code> мы можем соединить их и получить составную функцию <code><font color=Black>(</font>f <font color=Black>&gt;&gt;</font> g<font color=Black>)</font></code>.</p>
<div class="figure">
<img src="../pic/6/fun1.png" alt="Композиция функций" /><p class="caption">Композиция функций</p>
</div>
<h3 id="класс-category"><a href="#класс-category">Класс Category</a></h3>
<p>С помощью операции композиции можно обобщить понятие функции. Для этого существует класс  <code><font color=Green>Category</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Category</font> cat <font color="#b2590f">where</font>
    id   <font color="#b2590f">::</font> cat a a
    <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> cat a b <font color="#b2590f">-&gt;</font> cat b c <font color="#b2590f">-&gt;</font> cat a c</pre>
<p>Функция <code><font color=Black>cat</font></code> это тип с двумя параметрами, в котором выделено специальное значение <code><font color=Black>id</font></code>, которое оставляет аргумент без изменений. Также мы можем составлять из простых функций сложные с помощью композиции, если функции совпадают по типу. Здесь мы для наглядности также заменили метод <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code> на <code><font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font></code>, но суть остаётся прежней. Для любого экземпляра класса должны выполняться свойства:</p>
<pre><font color=Black>f</font>  <font color=Black>&gt;&gt;</font> id  <font color=Black>==</font> f
<font color=Black>id</font> <font color=Black>&gt;&gt;</font> f   <font color=Black>==</font> f

<font color=Black>f</font> <font color=Black>&gt;&gt;</font> <font color=Black>(</font>g <font color=Black>&gt;&gt;</font> h<font color=Black>)</font> <font color=Black>==</font> <font color=Black>(</font>f <font color=Black>&gt;&gt;</font> g<font color=Black>)</font> <font color=Black>&gt;&gt;</font> h</pre>
<p>Первые два свойства говорят о том, что <code><font color=Black>id</font></code> является нейтральным элементом для <code><font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font></code> слева и справа. Третье свойство говорит о том, что нам не важно в каком порядке проводить композицию. Можно проверить, что эти правила выполнены для функций.</p>
<h3 id="специальные-функции"><a href="#специальные-функции">Специальные функции</a></h3>
<p>Все специальные функции, которые мы рассмотрим в этой главе будут иметь один и тот же тип:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> m b</pre>
<p>Смотрите вместо произвольного типа <code><font color=Black>b</font></code> функция возвращает <code><font color=Black>m</font> b</code>. Единственное, что будет меняться от раздела к разделу это тип <code><font color=Black>m</font></code>. Добавив этот тип к результату, мы сузили область значений функции. Простым примером таких функций могут быть функции, которые возвращают списки:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font></pre>
<p>Если раньше наши функции могли возвращать произвольное значение <code><font color=Black>b</font></code>, то теперь мы знаем, что все результирующие значения таких функций будут списками.</p>
<p>При этом для каждого такого <code><font color=Black>m</font></code> мы попытаемся построить свой замкнутый мир специальных функций <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> m b</code>. Он будет жить внутри вселенной всех произвольных функций типа <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> b</code>. В этом нам поможет специальный класс типов, который называется категорией Клейсли (эта конструкция носит имя математика Хенрика Клейсли).</p>
<pre><font color="#b2590f">class</font> <font color=Green>Kleisli</font> m <font color="#b2590f">where</font>
    idK  <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font>    </pre>
<p>Этот класс является классом <code><font color=Green>Category</font></code> в мире наших специальных функций. Если мы сотрём все буквы <code><font color=Black>m</font></code>, то мы получим обычные типы для тождества и композиции. В этом мире должны выполняться те же правила:</p>
<pre><font color=Black>f</font>   <font color=Black>*&gt;</font> idK  <font color=Black>==</font> f
<font color=Black>idK</font> <font color=Black>*&gt;</font> f    <font color=Black>==</font> f

<font color=Black>f</font> <font color=Black>*&gt;</font> <font color=Black>(</font>g <font color=Black>*&gt;</font> h<font color=Black>)</font> <font color=Black>==</font> <font color=Black>(</font>f <font color=Black>*&gt;</font> g<font color=Black>)</font> <font color=Black>*&gt;</font> h</pre>
<h3 id="взаимодействие-с-внешним-миром"><a href="#взаимодействие-с-внешним-миром">Взаимодействие с внешним миром</a></h3>
<p>С помощью класса <code><font color=Green>Kleisli</font></code> мы можем составлять из одних специальных функций другие. Но как мы сможем комбинировать специальные функции с обычными?</p>
<p>Поскольку слева у нашей специальной функции обычный общий тип, то с этой стороны мы можем воспользоваться обычной функцией композиции <code><font color=Black>&gt;&gt;</font></code>. Но как быть при композиции справа? Нам нужна функция типа:</p>
<pre><font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font></pre>
<p>Оказывается мы можем составить её из методов класса <code><font color=Green>Kleisli</font></code>. Мы назовём эту функцию композиции <code><font color=Black>(</font><font color=Black>+&gt;</font><font color=Black>)</font></code>.</p>
<pre><font color=Black>(</font><font color=Black>+&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font>
<font color=Black>f</font> <font color=Black>+&gt;</font> g <font color="#b2590f">=</font> f <font color=Black>*&gt;</font> <font color=Black>(</font>g <font color=Black>&gt;&gt;</font> idK<font color=Black>)</font></pre>
<p>С помощью метода <code><font color=Black>idK</font></code> мы можем погрузить в мир специальных функций любую обычную функцию.</p>
<h3 id="три-композиции"><a href="#три-композиции">Три композиции</a></h3>
<p>У нас появилось много композиций целых три:</p>
<pre><font color=Black>аргументы</font>                           <font color="#b2590f">|</font>   результат 

<font color=Black>обычная</font>         <font color=Black>&gt;&gt;</font>  обычная         <font color=Black>==</font>  обычная
<font color=Black>специальная</font>     <font color=Black>+&gt;</font>  обычная         <font color=Black>==</font>  специальная
<font color=Black>специальная</font>     <font color=Black>*&gt;</font>  специальная     <font color=Black>==</font>  специальная</pre>
<p>При этом важно понимать, что по смыслу это три одинаковые функции. Они обозначают операцию последовательного применения функций. Разные значки отражают разные типы функций аргументов. Определим модуль <code><font color=Green>Kleisli</font><font color=Black>.</font>hs</code></p>
<pre><font color="#b2590f">module</font> <font color=Green>Kleisli</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Prelude</font> hiding <font color=Black>(</font>id<font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font><font color=Black>)</font>

<font color="#b2590f">class</font> <font color=Green>Category</font> cat <font color="#b2590f">where</font>
    id   <font color="#b2590f">::</font> cat a a
    <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> cat a b <font color="#b2590f">-&gt;</font> cat b c <font color="#b2590f">-&gt;</font> cat a c

<font color="#b2590f">class</font> <font color=Green>Kleisli</font> m <font color="#b2590f">where</font>
    idK  <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font>    

<font color=Black>(</font><font color=Black>+&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font>
<font color=Black>f</font> <font color=Black>+&gt;</font> g <font color="#b2590f">=</font> f <font color=Black>*&gt;</font> <font color=Black>(</font>g <font color=Black>&gt;&gt;</font> idK<font color=Black>)</font>

<font color="#2149c1">-- Экземпляр для функций</font>

<font color="#b2590f">instance</font> <font color=Green>Category</font> <font color=Black>(</font><font color="#b2590f">-&gt;</font><font color=Black>)</font> <font color="#b2590f">where</font>
    id      <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x
    f <font color=Black>&gt;&gt;</font> g  <font color="#b2590f">=</font> <font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> g <font color=Black>(</font>f x<font color=Black>)</font></pre>
<p>Мы не будем импортировать функцию <code><font color=Black>id</font></code>, а определим её в классе <code><font color=Green>Category</font></code>. Также в <code><font color=Green>Prelude</font></code> уже определена функция <code><font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font></code> мы спрячем её с помощью специальной директивы  <code><font color=Black>hiding</font></code> для того, чтобы она нам не мешалась. Далее мы будем дополнять этот модуль экземплярами класса <code><font color=Green>Kleisli</font></code> и примерами.</p>
<h2 id="примеры-специальных-функций"><a href="#примеры-специальных-функций">Примеры специальных функций</a></h2>
<h3 id="частично-определённые-функции"><a href="#частично-определённые-функции">Частично определённые функции</a></h3>
<p>Частично определённые функции – это такие функции, которые определены не для всех значений аргументов. Примером такой функции может быть функция поиска предыдущего числа для натуральных чисел. Поскольку числа натуральные, то для нуля такого числа нет. Для описания этого поведения мы можем воспользоваться специальным типом  <code><font color=Green>Maybe</font></code>. Посмотрим на его определение:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Maybe</font> a <font color="#b2590f">=</font> <font color=Green>Nothing</font> <font color="#b2590f">|</font> <font color=Green>Just</font> a
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>,</font> <font color=Green>Ord</font><font color=Black>)</font></pre>
<div class="figure">
<img src="../pic/6/maybe0.png" alt="Частично определённая функция" /><p class="caption">Частично определённая функция</p>
</div>
<p>Частично определённая функция имеет тип <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> b</code>, если всё в порядке и значение было вычислено, она вернёт <code><font color=Black>(</font><font color=Green>Just</font> a<font color=Black>)</font></code>, а в случае ошибки будет возвращено значение <code><font color=Green>Nothing</font></code>. Теперь мы можем определить нашу функцию так:</p>
<pre><font color=Black>pred</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Nat</font>
<font color=Black>pred</font> <font color=Green>Zero</font>       <font color="#b2590f">=</font> <font color=Green>Nothing</font>
<font color=Black>pred</font> <font color=Black>(</font><font color=Green>Succ</font> a<font color=Black>)</font>   <font color="#b2590f">=</font> <font color=Green>Just</font> a</pre>
<p>Для <code><font color=Green>Zero</font></code> предыдущий элемент не определён .</p>
<h4 id="составляем-функции-вручную"><a href="#составляем-функции-вручную">Составляем функции вручную</a></h4>
<p>Значение функции <code><font color=Black>pred</font></code> завёрнуто в упаковку <code><font color=Green>Maybe</font></code>, и для того чтобы воспользоваться им нам придётся разворачивать его каждый раз. Как будет выглядеть функция извлечения дважды предыдущего натурального числа:</p>
<pre><font color=Black>pred2</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Nat</font>
<font color=Black>pred2</font> x <font color="#b2590f">=</font> 
    <font color="#b2590f">case</font> pred x <font color="#b2590f">of</font>
        <font color=Green>Just</font> <font color=Black>(</font><font color=Green>Succ</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Just</font> a
        <font color="#b2590f">_</font>             <font color="#b2590f">-&gt;</font> <font color=Green>Nothing</font></pre>
<p>Если мы захотим определить <code><font color=Black>pred3</font></code>, мы заменим <code><font color=Black>pred</font></code> в <code><font color="#b2590f">case</font></code>-выражении на <code><font color=Black>pred2</font></code>. Не такое уж и длинное решение, но всё же мы теряем все преимущества гибких функций, все преимущества бесточечного стиля. Нам бы хотелось написать так:</p>
<pre><font color=Black>pred2</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Nat</font>
<font color=Black>pred2</font> <font color="#b2590f">=</font> pred <font color=Black>&gt;&gt;</font> pred

<font color=Black>pred3</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> <font color=Green>Nat</font>
<font color=Black>pred3</font> <font color="#b2590f">=</font> pred <font color=Black>&gt;&gt;</font> pred <font color=Black>&gt;&gt;</font> pred</pre>
<p>Но компилятор этого не допустит.</p>
<h4 id="композиция"><a href="#композиция">Композиция</a></h4>
<p>Для того чтобы понять как устроена композиция частично определённых функций изобразим её вычисление графически. Сверху изображены две частично определённых функции. Если функция <code><font color=Black>f</font></code> вернула значение, то оно подставляется в следующую частично определённую функцию. Если же первая функция не смогла вычислить результат и вернула <code><font color=Green>Nothing</font></code>, то считается что вся функция <code><font color=Black>(</font>f<font color=Black>*&gt;</font>g<font color=Black>)</font></code> вернула <code><font color=Green>Nothing</font></code>.</p>
<div class="figure">
<img src="../pic/6/maybe1.png" alt="Композиция частично определённых функций" /><p class="caption">Композиция частично определённых функций</p>
</div>
<p>Теперь давайте закодируем это определение в Haskell. При этом мы воспользуемся нашим классом <code><font color=Green>Kleisli</font></code>. Аналогом функции <code><font color=Black>id</font></code> для частично определённых функций будет функция, которая просто заворачивает значение в конструктор <code><font color=Green>Just</font></code>.</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Kleisli</font> <font color=Green>Maybe</font> <font color="#b2590f">where</font>
    idK    <font color="#b2590f">=</font> <font color=Green>Just</font>
    f <font color=Black>*&gt;</font> g <font color="#b2590f">=</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">case</font> f a <font color="#b2590f">of</font>
                        <font color=Green>Nothing</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nothing</font>
                        <font color=Green>Just</font> b  <font color="#b2590f">-&gt;</font> g b</pre>
<p>Смотрите, в <code><font color="#b2590f">case</font></code>-выражении мы возвращаем <code><font color=Green>Nothing</font></code>, если функция <code><font color=Black>f</font></code> вернула <code><font color=Green>Nothing</font></code>, а если ей удалось вычислить значение и она вернула <code><font color=Black>(</font><font color=Green>Just</font> b<font color=Black>)</font></code> мы передаём это значение в следующую функцию, то есть составляем выражение <code><font color=Black>(</font>g b<font color=Black>)</font></code>.</p>
<p>Сохраним это определение в модуле <code><font color=Green>Kleisli</font></code>, а также определение для функции <code><font color=Black>pred</font></code> и загрузим модуль в интерпретатор. Перед этим нам придётся добавить в список функций, которые мы не хотим импортировать из <code><font color=Green>Prelude</font></code> функцию <code><font color=Black>pred</font></code>, она также уже определена в <code><font color=Green>Prelude</font></code>. Для определения нашей функции нам потребуется модуль <code><font color=Green>Nat</font></code>, который мы уже определили. Скопируем файл <code><font color=Green>Nat</font><font color=Black>.</font>hs</code> в ту же директорию, в которой содержится файл <code><font color=Green>Kleisli</font><font color=Black>.</font>hs</code> и подключим этот модуль. Шапка модуля примет вид:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Kleisli</font> <font color="#b2590f">where</font>
    
<font color="#b2590f">import</font> <font color=Green>Prelude</font> hiding<font color=Black>(</font>id<font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font><font color=Black>,</font> pred<font color=Black>)</font>
<font color="#b2590f">import</font> <font color=Green>Nat</font></pre>
<p>Добавим определение экземпляра <code><font color=Green>Kleisli</font></code> для <code><font color=Green>Maybe</font></code> в модуль <code><font color=Green>Kleisli</font></code> а также определение функции <code><font color=Black>pred</font></code>. Сохраним обновлённый модуль и загрузим в интерпретатор.</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>load <font color=Green>Kleisli</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">2</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Nat</font>              <font color=Black>(</font> <font color=Green>Nat</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color="#b2590f">[</font><font color="#0000ee">2</font> <font color="#b2590f">of</font> <font color="#0000ee">2</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Kleisli</font>          <font color=Black>(</font> <font color=Green>Kleisli</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Kleisli</font><font color=Black>,</font> <font color=Green>Nat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> pred2 <font color="#b2590f">=</font> pred <font color=Black>*&gt;</font> pred
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> pred3 <font color="#b2590f">=</font> pred <font color=Black>*&gt;</font> pred <font color=Black>*&gt;</font> pred
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> two   <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> 
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> pred two
<font color=Green>Just</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> pred3 two
<font color=Green>Nothing</font></pre>
<p>Обратите внимание на то, как легко определяются производные функции. Желаемое поведение для частично определённых функций закодировано в функции <code><font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font></code> теперь нам не нужно заворачивать значения и разворачивать их из типа <code><font color=Green>Maybe</font></code>.</p>
<p>Приведём пример функции, которая составлена из частично определённой функции и обычной. Определим функцию <code><font color=Black>beside</font></code>, которая вычисляет соседей для данного числа Пеано.</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> beside <font color="#b2590f">=</font> pred <font color=Black>+&gt;</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> a <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> beside <font color=Green>Zero</font>
<font color=Green>Nothing</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> beside two
<font color=Green>Just</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>,</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color=Black>(</font>pred <font color=Black>*&gt;</font> beside<font color=Black>)</font> two
<font color=Green>Just</font> <font color=Black>(</font><font color=Green>Zero</font><font color=Black>,</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>В выражении</p>
<pre><font color=Black>pred</font> <font color=Black>+&gt;</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> a <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font></pre>
<p>Мы сначала вычисляем предыдущее число, и если оно есть составляем пару из <code><font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font></code>, в пару попадёт данное число и число, следующее за ним через одно. Поскольку сначала мы вычислили предыдущее число в итоговом кортеже окажется предыдущее число и следующее.</p>
<p>Итак с помощью функций из класса <code><font color=Green>Kleisli</font></code> мы можем составлять частично определённые функции в бесточечном стиле. Обратите внимание на то, что все функции кроме <code><font color=Black>pred</font></code> были составлены в интерпретаторе.</p>
<p>Отметим, что в <code><font color=Green>Prelude</font></code> определена специальная функция <code><font color=Black>maybe</font></code>, которая похожа на функцию <code><font color=Black>foldr</font></code> для списков, она заменяет в значении типа <code><font color=Green>Maybe</font></code> конструкторы на функции. Посмотрим на её определение:</p>
<pre><font color=Black>maybe</font>              <font color="#b2590f">::</font> b <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> a <font color="#b2590f">-&gt;</font> b
<font color=Black>maybe</font> n f <font color=Green>Nothing</font>  <font color="#b2590f">=</font>  n
<font color=Black>maybe</font> n f <font color=Black>(</font><font color=Green>Just</font> x<font color=Black>)</font> <font color="#b2590f">=</font>  f x</pre>
<p>С помощью этой функции мы можем переписать определение экземпляра <code><font color=Green>Kleisli</font></code> так:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Kleisli</font> <font color=Green>Maybe</font> <font color="#b2590f">where</font>
    idM     <font color="#b2590f">=</font> <font color=Green>Just</font>
    f <font color=Black>*&gt;</font> g  <font color="#b2590f">=</font> f <font color=Black>&gt;&gt;</font> maybe <font color=Green>Nothing</font> g</pre>
<h3 id="многозначные-функции"><a href="#многозначные-функции">Многозначные функции</a></h3>
<p> Многозначные функции ветрены и непостоянны. Для некоторых значений аргументов они возвращают одно значение, для иных десять, а для третьих и вовсе ничего. В Haskell такие функции имеют тип <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font></code>. Функция возвращает список ответов. На рисунке изображена схема многозначной функции.</p>
<div class="figure">
<img src="../pic/6/list0.png" alt="Многозначная функция" /><p class="caption">Многозначная функция</p>
</div>
<p>Приведём пример. Системы Линденмайера (или L-системы) моделируют развитие живого организма. Считается, что организм состоит из последовательности букв (или клеток). В каждый момент времени одна буква заменяется на новую последовательность букв, согласно определённым правилам. Так организм живёт и развивается. Приведём пример:</p>
<dl>
<dt>Аксиомы</dt>
<dd><table>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$a \rightarrow ab$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$b \rightarrow a$</span></td>
</tr>
</tbody>
</table>
</dd>
<dt>Вывод</dt>
<dd><table>
<tbody>
<tr class="odd">
<td align="left"><span class="LaTeX">$a$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$ab$</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="LaTeX">$aba$</span></td>
</tr>
<tr class="even">
<td align="left"><span class="LaTeX">$abaab$</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="LaTeX">$abaababa$</span></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<p>У нас есть два правила размножения клеток-букв в организме. На каждом этапе мы во всём слове заменяем букву <span class="LaTeX">$a$</span> на слово <span class="LaTeX">$ab$</span> и букву <span class="LaTeX">$b$</span> на <span class="LaTeX">$a$</span>. Начав с одной буквы <span class="LaTeX">$a$</span>, мы за несколько шагов пришли к более сложному слову.</p>
<p>Опишем этот процесс в Haskell. Для этого определим правила развития организма в виде многозначной функции:</p>
<pre><font color=Black>next</font> <font color="#b2590f">::</font> <font color=Green>Char</font> <font color="#b2590f">-&gt;</font> <font color=Green>String</font>
<font color=Black>next</font> <font color=Black>'a'</font> <font color="#b2590f">=</font> <font color=Black>"ab"</font>
<font color=Black>next</font> <font color=Black>'b'</font> <font color="#b2590f">=</font> <font color=Black>"a"</font></pre>
<p>Напомню, что строки в Haskell являются списками символов. Теперь нам нужно применить многозначную функцию к выходу многозначной функции. Для этого мы воспользуемся классом <code><font color=Green>Kleisli</font></code>.</p>
<h4 id="композиция-1"><a href="#композиция-1">Композиция</a></h4>
<div class="figure">
<img src="../pic/6/list1.png" alt="Композиция многозначных функций" /><p class="caption">Композиция многозначных функций</p>
</div>
<p>Определим экземпляр класса <code><font color=Green>Kleisli</font></code> для списков. На рисунке изображена схема композиции в случае многозначных функций. После применения первой функции <code><font color=Black>f</font></code> мы применяем функцию к каждому элементу списка, который был получен из <code><font color=Black>f</font></code>. Так у нас получится список списков. Но нам нужен список, для этого мы после применения <code><font color=Black>g</font></code> объединяем все значения в один большой список. Отметим, что функции <code><font color=Black>f</font></code> и <code><font color=Black>g</font></code> в зависимости от значений могут возвращать разное число значений, поэтому на выходе у функций <code><font color=Black>g</font></code> разное число стрелок.</p>
<p>Закодируем эту схему в Haskell:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Kleisli</font> <font color=Green>[]</font> <font color="#b2590f">where</font>
    idK     <font color="#b2590f">=</font> <font color="#b2590f">\</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
    f <font color=Black>*&gt;</font> g  <font color="#b2590f">=</font> f <font color=Black>&gt;&gt;</font> map g <font color=Black>&gt;&gt;</font> concat</pre>
<p>Функция тождества принимает одно значение и погружает его в список. В композиции мы сначала применяем <code><font color=Black>f</font></code>, затем к каждому элементу списка результата применяем <code><font color=Black>g</font></code>, так у нас получается список списков. После чего мы сворачиваем его в один список с помощью функции <code><font color=Black>concat</font></code>.</p>
<p>Вспомним тип функций <code><font color=Black>map</font></code> и <code><font color=Black>concat</font></code>:</p>
<pre><font color=Black>map</font>     <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font>
<font color=Black>concat</font>  <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<p>С помощью композиции мы можем получить n-тое поколение так:</p>
<pre><font color=Black>generate</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font>
<font color=Black>generate</font> <font color="#0000ee">0</font> f <font color="#b2590f">=</font> idK
<font color=Black>generate</font> n f <font color="#b2590f">=</font> f <font color=Black>*&gt;</font> generate <font color=Black>(</font>n <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font> f</pre>
<p>Или мы можем воспользоваться функцией <code><font color=Black>iterate</font></code> и написать это определение так:</p>
<pre><font color=Black>generate</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font><font color=Black>)</font>
<font color=Black>generate</font> n f <font color="#b2590f">=</font> iterate <font color=Black>(</font><font color=Black>*&gt;</font> f<font color=Black>)</font> idK <font color=Black>!!</font> n</pre>
<p>Функция <code><font color=Black>iterate</font></code> принимает функцию вычисления следующего элемента и начальное значение и строит бесконечный список итераций:</p>
<pre><font color=Black>iterate</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>iterate</font> f a <font color="#b2590f">=</font> <font color="#b2590f">[</font>a<font color=Black>,</font> f a<font color=Black>,</font> f <font color=Black>(</font>f a<font color=Black>)</font><font color=Black>,</font> f <font color=Black>(</font>f <font color=Black>(</font>f a<font color=Black>)</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>...</font><font color="#b2590f">]</font></pre>
<p>Если мы подставим наши аргументы то мы получим список:</p>
<pre><font color="#b2590f">[</font>id<font color=Black>,</font> f<font color=Black>,</font> f<font color=Black>*&gt;</font>f<font color=Black>,</font> f<font color=Black>*&gt;</font>f<font color=Black>*&gt;</font>f<font color=Black>,</font> f<font color=Black>*&gt;</font>f<font color=Black>*&gt;</font>f<font color=Black>*&gt;</font>f<font color=Black>,</font> <font color=Black>...</font><font color="#b2590f">]</font></pre>
<p>Проверим как работает эта функция в интерпретаторе. Для этого мы сначала дополним наш модуль <code><font color=Green>Kleisli</font></code> определением экземпляра для списков и функциями <code><font color=Black>next</font></code> и <code><font color=Black>generate</font></code>:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>reload
<font color="#b2590f">[</font><font color="#0000ee">2</font> <font color="#b2590f">of</font> <font color="#0000ee">2</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Kleisli</font>          <font color=Black>(</font> <font color=Green>Kleisli</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Kleisli</font><font color=Black>,</font> <font color=Green>Nat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> gen n <font color="#b2590f">=</font> generate n next <font color=Black>'a'</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> gen <font color="#0000ee">0</font>
<font color=Black>"a"</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> gen <font color="#0000ee">1</font>
<font color=Black>"ab"</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> gen <font color="#0000ee">2</font>
<font color=Black>"aba"</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> gen <font color="#0000ee">3</font>
<font color=Black>"abaab"</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> gen <font color="#0000ee">4</font>
<font color=Black>"abaababa"</font></pre>
<p>Правила L-системы задаются многозначной функцией. Функция <code><font color=Black>generate</font></code> позволяет по такой функции строить произвольное поколение развития буквенного организма.</p>
<h2 id="применение-функций"><a href="#применение-функций">Применение функций</a></h2>
<p>Давайте определим в терминах композиции ещё одну полезную функцию. А именно функцию применения. Вспомним её тип:</p>
<pre><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> b</pre>
<p>Эту функцию можно определить через композицию, если у нас есть в наличии постоянная функция и единичный тип. Мы будем считать, что константа это функция из единичного типа в значение. Превратив константу в функцию мы можем составить композицию:</p>
<pre><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> b
<font color=Black>f</font> <font color=Black>$</font> a <font color="#b2590f">=</font> <font color=Black>(</font>const a <font color=Black>&gt;&gt;</font> f<font color=Black>)</font> <font color=Green>()</font></pre>
<p>В самом конце мы подставляем специальное значение <code><font color=Green>()</font></code>. Это значение единичного типа (unit type) или кортежа с нулём элементов. Единичный тип имеет всего одно значение, которым мы и воспользовались в этом определении. Зачем такое запутанное определение, вместо привычного <code><font color=Black>(</font>f a<font color=Black>)</font></code>? Оказывается точно таким же способом мы можем определить применение в нашем мире специальных функций <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> m b</code>.</p>
<p>Применение в этом мире происходит особенным образом. Необходимо помнить о том, что второй аргумент функции применения, значение, которое мы подставляем в функцию, также было получено из какой-то другой функции. Поэтому оно будет иметь такую же форму, что и значения справа от стрелки. В нашем случае это <code><font color=Black>m</font> b</code>.</p>
<p>Посмотрим на типы специальных функций применения:</p>
<pre><font color=Black>(</font><font color=Black>*$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b
<font color=Black>(</font><font color=Black>+$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>   <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b</pre>
<p>Функция <code><font color=Black>*$</font></code> применяет специальную функцию к специальному значению, а функция <code><font color=Black>+$</font></code> применяет обычную функцию к специальному значению. Определения выглядят также как и в случае обычной функции применения, мы только меняем знаки для композиции:</p>
<pre><font color=Black>f</font>  <font color=Black>$</font> a <font color="#b2590f">=</font> <font color=Black>(</font>const a <font color=Black>&gt;&gt;</font> f<font color=Black>)</font> <font color=Green>()</font>
<font color=Black>f</font> <font color=Black>*$</font> a <font color="#b2590f">=</font> <font color=Black>(</font>const a <font color=Black>*&gt;</font> f<font color=Black>)</font> <font color=Green>()</font>
<font color=Black>f</font> <font color=Black>+$</font> a <font color="#b2590f">=</font> <font color=Black>(</font>const a <font color=Black>+&gt;</font> f<font color=Black>)</font> <font color=Green>()</font></pre>
<p>Теперь мы можем не только нанизывать специальные функции друг на друга но и применять их к значениям. Добавим эти определения в модуль <code><font color=Green>Kleisli</font></code> и посмотрим как происходит применение в интерпретаторе. Одна тонкость заключается в том, что мы определяли применение в терминах класса <code><font color=Green>Kleisli</font></code>, поэтому правильно было написать типы новых функций так:</p>
<pre><font color="#b2590f">infixr</font> <font color="#0000ee">0</font> <font color=Black>+$</font><font color=Black>,</font> <font color=Black>*$</font>

<font color=Black>(</font><font color=Black>*$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b
<font color=Black>(</font><font color=Black>+$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>   <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b</pre>
<p>Также мы определили приоритет выполнения операций.</p>
<p>Загрузим в интерпретатор:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> three <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> pred <font color=Black>*$</font> pred <font color=Black>*$</font> idK three
<font color=Green>Just</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> pred <font color=Black>*$</font> pred <font color=Black>*$</font> idK <font color=Green>Zero</font>
<font color=Green>Nothing</font></pre>
<p>Обратите внимание на то как мы погружаем в мир специальных функций обычное значение с помощью функции <code><font color=Black>idK</font></code>.</p>
<p>Вычислим третье поколение L-системы:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> next <font color=Black>*$</font> next <font color=Black>*$</font> next <font color=Black>*$</font> idK <font color=Black>'a'</font>
<font color=Black>"abaab"</font></pre>
<p>Мы можем использовать и другие функции на списках:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> next <font color=Black>*$</font> tail <font color=Black>$</font> next <font color=Black>*$</font> reverse <font color=Black>$</font> next <font color=Black>*$</font> idK <font color=Black>'a'</font>
<font color=Black>"aba"</font></pre>
<h3 id="применение-функций-многих-переменных"><a href="#применение-функций-многих-переменных">Применение функций многих переменных</a></h3>
<p>С помощью функции <code><font color=Black>+$</font></code> мы можем применять к специальным значениям обычные функции одного аргумента. А что если нам захочется применить функцию двух аргументов?</p>
<p>Например если мы захотим сложить два частично определённых числа:</p>
<pre><font color=Black>??</font> <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Just</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Just</font> <font color="#0000ee">2</font><font color=Black>)</font></pre>
<p>На месте <code><font color=Black>??</font></code> должна стоять функция типа:</p>
<pre><font color=Black>??</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c</pre>
<p>Оказывается с помощью методов класса <code><font color=Green>Kleisli</font></code> мы можем определить такую функцию для любой обычной функции, а не только для функции двух аргументов. Мы будем называть такие функции словом <code><font color=Black>liftN</font></code>, где <code><font color=Green>N</font></code> – число, указывающее на арность функции. Функция <code><font color=Black>(</font>liftN f<font color=Black>)</font></code> “поднимает” (от англ. lift) обычную функцию <code><font color=Black>f</font></code> в мир специальных функций.</p>
<p>Функция <code><font color=Black>lift1</font></code> у нас уже есть, это просто функция <code><font color=Black>+$</font></code>. Теперь давайте определим функцию <code><font color=Black>lift2</font></code>:</p>
<pre><font color=Black>lift2</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c
<font color=Black>lift2</font> f a b <font color="#b2590f">=</font> <font color=Black>...</font></pre>
<p>Поскольку функция двух аргументов на самом деле является функцией одного аргумента мы можем применить первый аргумент с помощью функции <code><font color=Black>lift1</font></code>, посмотрим что у нас получится:</p>
<pre><font color=Black>lift1</font>       <font color="#b2590f">::</font> <font color=Black>(</font>a' <font color="#b2590f">-&gt;</font> b'<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m' a' <font color="#b2590f">-&gt;</font> m' b'
<font color=Black>f</font>           <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>
<font color=Black>a</font>           <font color="#b2590f">::</font> m a

<font color=Black>lift1</font> f a   <font color="#b2590f">::</font> m <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>  <font color="#2149c1">-- m' == m, a' == a, b' == b -&gt; c</font></pre>
<p>Теперь в нашем определении для <code><font color=Black>lift2</font></code> появится новое слагаемое <code><font color=Black>g</font></code>:</p>
<pre><font color=Black>lift2</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c
<font color=Black>lift2</font> f a b <font color="#b2590f">=</font> <font color=Black>...</font>
    <font color="#b2590f">where</font> g <font color="#b2590f">=</font> lift1 f a</pre>
<p>Один аргумент мы применили, осталось применить второй. Нам нужно составить выражение <code><font color=Black>(</font>g b<font color=Black>)</font></code>, но для этого нам нужна функция типа:</p>
<pre><font color=Black>m</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c</pre>
<p>Эта функция применяет к специальному значению функцию, которая завёрнута в тип <code><font color=Black>m</font></code>. Посмотрим на определение этой функции, мы назовём её <code><font color=Black>$$</font></code>:</p>
<pre><font color=Black>(</font><font color=Black>$$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> m <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b
<font color=Black>mf</font> <font color=Black>$$</font> ma <font color="#b2590f">=</font> <font color=Black>(</font> <font color=Black>+$</font> ma<font color=Black>)</font> <font color=Black>*$</font> mf</pre>
<p>Вы можете убедиться в том, что это определение проходит проверку типов. Посмотрим как эта функция работает в интерпретаторе на примере частично определённых и многозначных функций, для этого давайте добавим в модуль <code><font color=Green>Kleisli</font></code> это определение и загрузим его в интерпретатор:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>reload <font color=Green>Kleisli</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Kleisli</font><font color=Black>,</font> <font color=Green>Nat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color=Green>Just</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>$$</font> <font color=Green>Just</font> <font color="#0000ee">2</font>
<font color=Green>Just</font> <font color="#0000ee">4</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color=Green>Nothing</font> <font color=Black>$$</font> <font color=Green>Just</font> <font color="#0000ee">2</font>
<font color=Green>Nothing</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color="#b2590f">]</font> <font color=Black>$$</font> <font color="#b2590f">[</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">20</font><font color=Black>,</font><font color="#0000ee">30</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">11</font><font color=Black>,</font><font color="#0000ee">21</font><font color=Black>,</font><font color="#0000ee">31</font><font color=Black>,</font><font color="#0000ee">12</font><font color=Black>,</font><font color="#0000ee">22</font><font color=Black>,</font><font color="#0000ee">32</font><font color=Black>,</font><font color="#0000ee">13</font><font color=Black>,</font><font color="#0000ee">23</font><font color=Black>,</font><font color="#0000ee">33</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color=Black>(</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color="#b2590f">]</font> <font color=Black>$$</font> <font color=Green>[]</font>
<font color=Green>[]</font></pre>
<p>Обратите внимание на то, что в случае списков были составлены все возможные комбинации применений. Мы применили первую функцию из списка ко всем аргументам, потом вторую функцию, третью и объединили все результаты в список.</p>
<p>Теперь мы можем закончить наше определение для <code><font color=Black>lift2</font></code>:</p>
<pre><font color=Black>lift2</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c
<font color=Black>lift2</font> f a b <font color="#b2590f">=</font> f' <font color=Black>$$</font> b
    <font color="#b2590f">where</font> f' <font color="#b2590f">=</font> lift1 f a</pre>
<p>Мы можем записать это определение более кратко:</p>
<pre><font color=Black>lift2</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c
<font color=Black>lift2</font> f a b <font color="#b2590f">=</font> lift1 f a <font color=Black>$$</font> b</pre>
<p>Теперь давайте добавим это определение в модуль <code><font color=Green>Kleisli</font></code> и посмотрим в интерпретаторе как работает эта функция:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>reload
<font color="#b2590f">[</font><font color="#0000ee">2</font> <font color="#b2590f">of</font> <font color="#0000ee">2</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Kleisli</font>          <font color=Black>(</font> <font color=Green>Kleisli</font><font color=Black>.</font>hs<font color=Black>,</font> interpreted <font color=Black>)</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Kleisli</font><font color=Black>,</font> <font color=Green>Nat</font><font color=Black>.</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> lift2 <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Just</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Just</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color=Green>Just</font> <font color="#0000ee">4</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> lift2 <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Just</font> <font color="#0000ee">2</font><font color=Black>)</font> <font color=Green>Nothing</font>
<font color=Green>Nothing</font></pre>
<p>Как на счёт функций трёх и более аргументов? У нас уже есть функции <code><font color=Black>lift1</font></code> и <code><font color=Black>lift2</font></code> определим функцию <code><font color=Black>lift3</font></code>:</p>
<pre><font color=Black>lift3</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c <font color="#b2590f">-&gt;</font> d<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c <font color="#b2590f">-&gt;</font> m d
<font color=Black>lift3</font> f a b c <font color="#b2590f">=</font> <font color=Black>...</font></pre>
<p>Первые два аргумента мы можем применить с помощью функции <code><font color=Black>lift2</font></code>. Посмотрим на тип получившегося выражения:</p>
<pre><font color=Black>lift2</font>       <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a' <font color="#b2590f">-&gt;</font> b' <font color="#b2590f">-&gt;</font> c'<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a' <font color="#b2590f">-&gt;</font> m b' <font color="#b2590f">-&gt;</font> m c'
<font color=Black>f</font>           <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c <font color="#b2590f">-&gt;</font> d

<font color=Black>lift2</font> f a b <font color="#b2590f">::</font> m <font color=Black>(</font>c <font color="#b2590f">-&gt;</font> d<font color=Black>)</font>   <font color="#2149c1">-- a' == a, b' == b, c' == c -&gt; d</font></pre>
<p>У нас опять появился тип <code><font color=Black>m</font> <font color=Black>(</font>c <font color="#b2590f">-&gt;</font> d<font color=Black>)</font></code> и к нему нам нужно применить значение <code><font color=Black>m</font> c</code>, чтобы получить <code><font color=Black>m</font> d</code>. Этим как раз и занимается функция <code><font color=Black>$$</font></code>. Итак итоговое определение примет вид:</p>
<pre><font color=Black>lift3</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c <font color="#b2590f">-&gt;</font> d<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m c <font color="#b2590f">-&gt;</font> m d
<font color=Black>lift3</font> f a b c <font color="#b2590f">=</font> lift2 f a b <font color=Black>$$</font> c</pre>
<p>Так мы можем определить любую функцию <code><font color=Black>liftN</font></code> через функции <code><font color=Black>liftN</font><font color="#2149c1">-</font><font color="#0000ee">1</font></code> и <code><font color=Black>$$</font></code>.</p>
<h3 id="несколько-полезных-функций"><a href="#несколько-полезных-функций">Несколько полезных функций</a></h3>
<p>Теперь мы умеем применять к специальным значениям произвольные обычные функции. Определим ещё несколько полезных функций. Первая функция принимает список специальных значений и собирает их в специальный список:</p>
<pre><font color="#b2590f">import</font> <font color=Green>Prelude</font> hiding <font color=Black>(</font>id<font color=Black>,</font> <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font><font color=Black>,</font> pred<font color=Black>,</font> sequence<font color=Black>)</font>

<font color=Black>sequence</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>m a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> m <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>sequence</font> <font color="#b2590f">=</font> foldr <font color=Black>(</font>lift2 <font color=Black>(</font><font color="#b2590f">:</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>(</font>idK <font color=Green>[]</font><font color=Black>)</font> </pre>
<p>Мы “спрячем” из <code><font color=Green>Prelude</font></code> одноимённую функцию <code><font color=Black>sequence</font></code>. Посмотрим на примеры:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> sequence <font color="#b2590f">[</font><font color=Green>Just</font> <font color="#0000ee">1</font><font color=Black>,</font> <font color=Green>Just</font> <font color="#0000ee">2</font><font color=Black>,</font> <font color=Green>Just</font> <font color="#0000ee">3</font><font color="#b2590f">]</font>
<font color=Green>Just</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> sequence <font color="#b2590f">[</font><font color=Green>Just</font> <font color="#0000ee">1</font><font color=Black>,</font> <font color=Green>Nothing</font><font color=Black>,</font> <font color=Green>Just</font> <font color="#0000ee">3</font><font color="#b2590f">]</font>
<font color=Green>Nothing</font></pre>
<p>Во второй команде вся функция вернула <code><font color=Green>Nothing</font></code> потому что при объединении списка встретилось значение <code><font color=Green>Nothing</font></code>, это равносильно тому, что мы объединяем в один список, значения полученные из функций, которые могут не вычислить результат. Поскольку значение одного из элементов не определено, весь список не определён.</p>
<p>Посмотрим как работает эта функция на списках:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> sequence <font color="#b2590f">[</font><font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font><font color=Black>,</font> <font color="#b2590f">[</font><font color="#0000ee">11</font><font color=Black>,</font><font color="#0000ee">22</font><font color="#b2590f">]</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">11</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">22</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">11</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">22</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">11</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">22</font><font color="#b2590f">]</font><font color="#b2590f">]</font></pre>
<p>Она составляет список всех комбинаций элементов из всех подсписков.</p>
<p>С помощью этой функции мы можем определить функцию <code><font color=Black>mapK</font></code>. Эта функция является аналогом обычной функции <code><font color=Black>map</font></code>, но она применяет специальную функцию к списку значений.</p>
<pre><font color=Black>mapK</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> m <font color="#b2590f">[</font>b<font color="#b2590f">]</font>
<font color=Black>mapK</font> f <font color="#b2590f">=</font> sequence <font color=Black>.</font> map f</pre>
<h2 id="функторы-и-монады"><a href="#функторы-и-монады">Функторы и монады</a></h2>
<p>В этой главе мы выписали вручную все определения для класса <code><font color=Green>Kleisli</font></code>. Мы сделали это потому, что на самом деле в арсенале стандартных средств Haskell такого класса нет. Класс <code><font color=Green>Kleisli</font></code> строит замкнутый мир специальных функций <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> m b</code>. Его цель построить язык в языке и сделать программирование со специальными функциями таким же удобным как и с обычными функциями. Мы пользовались классом <code><font color=Green>Kleisli</font></code> исключительно в целях облегчения понимания этого мира. Впрочем никто не мешает нам определить этот класс и пользоваться им в наших программах.</p>
<p>А пока посмотрим, что есть в Haskell и как это соотносится с тем, что мы уже увидели. С помощью класса <code><font color=Green>Kleisli</font></code><br />мы научились делать три различных операции применения:</p>
<p>Применение:</p>
<ul>
<li><p>обычных функций одного аргумента к специальным значениям (функция <code><font color=Black>+$</font></code>).</p></li>
<li><p>обычных функций произвольного числа аргументов к специальным значениям (функции <code><font color=Black>+$</font></code> и <code><font color=Black>$$</font></code>)</p></li>
<li><p>специальных функций к специальным значениям (функция <code><font color=Black>*$</font></code>).</p></li>
</ul>
<p>В Haskell для решения этих задач предназначены три отдельных класса. Это функторы, аппликативные функторы и монады.</p>
<h3 id="функторы"><a href="#функторы">Функторы</a></h3>
<p>Посмотрим на определение класса  <code><font color=Green>Functor</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">where</font>
    fmap <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b</pre>
<p>Тип метода <code><font color=Black>fmap</font></code> совпадает с типом для функции <code><font color=Black>+$</font></code>:</p>
<pre><font color=Black>(</font><font color=Black>+$</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b</pre>
<p>Нам только нужно заменить <code><font color=Black>m</font></code> на <code><font color=Black>f</font></code> и зависимость от <code><font color=Green>Kleisli</font></code> на зависимость от <code><font color=Green>Functor</font></code>:</p>
<p>Итак в Haskell у нас есть базовая операция <code><font color=Black>fmap</font></code> применения обычной функции к значению из мира специальных функций. В модуле <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font></code> определён инфиксный синоним <code><font color=Black>&lt;$&gt;</font></code> для этой функции.</p>
<h3 id="аппликативные-функторы"><a href="#аппликативные-функторы">Аппликативные функторы</a></h3>
<p>Посмотрим на определение класса  <code><font color=Green>Applicative</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">=&gt;</font> <font color=Green>Applicative</font> f <font color="#b2590f">where</font>
        pure    <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> f a
        <font color=Black>(</font><font color=Black>&lt;*&gt;</font><font color=Black>)</font>   <font color="#b2590f">::</font> f <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b</pre>
<p>Если присмотреться к типам методов этого класса, то мы заметим, что это наши старые знакомые <code><font color=Black>idK</font></code> и <code><font color=Black>$$</font></code>. Если для данного типа <code><font color=Black>f</font></code> определён экземпляр класса <code><font color=Green>Applicative</font></code>, то из контекста следует, что для него также определён и экземпляр класса <code><font color=Green>Functor</font></code>.</p>
<p>Значит у нас есть функции <code><font color=Black>fmap</font></code> (или <code><font color=Black>lift1</font></code>) и <code><font color=Black>&lt;*&gt;</font></code> (или <code><font color=Black>$$</font></code>). С их помощью мы можем составить функции <code><font color=Black>liftN</font></code>, которые поднимают обычные функции произвольного числа аргументов в мир специальных значений.</p>
<p>Класс <code><font color=Green>Applicative</font></code> определён в модуле <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font></code>, там же мы сможем найти и функции <code><font color=Black>liftA</font></code>, <code><font color=Black>liftA2</font></code>, <code><font color=Black>liftA3</font></code> и символьный синоним <code><font color=Black>&lt;$&gt;</font></code> для функции <code><font color=Black>fmap</font></code>. Функции <code><font color=Black>liftAn</font></code> определены так:</p>
<pre><font color=Black>liftA2</font> f a b   <font color="#b2590f">=</font> f <font color=Black>&lt;$&gt;</font> a <font color=Black>&lt;*&gt;</font> b
<font color=Black>liftA3</font> f a b c <font color="#b2590f">=</font> f <font color=Black>&lt;$&gt;</font> a <font color=Black>&lt;*&gt;</font> b <font color=Black>&lt;*&gt;</font> c</pre>
<p>Видно что эти определения с точностью до обозначений совпадают с теми, что мы уже писали для класса <code><font color=Green>Kleisli</font></code>.</p>
<h3 id="монады"><a href="#монады">Монады</a></h3>
<p>Посмотрим на определение класса  <code><font color=Green>Monad</font></code></p>
<pre><font color="#b2590f">class</font> <font color=Green>Monad</font> m <font color="#b2590f">where</font>
  return <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
  <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font>  <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b</pre>
<p>Присмотримся к типам методов этого класса:</p>
<pre><font color=Black>return</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a</pre>
<p>Их типа видно, что это ни что иное как функция <code><font color=Black>idK</font></code>. В классе <code><font color=Green>Monad</font></code> у неё точно такой же смысл. Теперь функция <code><font color=Black>&gt;&gt;=</font></code>, она читается как функция <em>связывания</em> (bind).</p>
<pre><font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font>  <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b</pre>
<p>Так возможно совпадение не заметно, но давайте “перевернём” эту функцию:</p>
<pre><font color=Black>(</font><font color=Black>=&lt;&lt;</font><font color=Black>)</font>  <font color="#b2590f">::</font> <font color=Green>Monad</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b
<font color=Black>(</font><font color=Black>=&lt;&lt;</font><font color=Black>)</font> <font color="#b2590f">=</font> flip <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font></pre>
<p>Поменяв аргументы местами, мы получили знакомую функцию <code><font color=Black>*$</font></code>. Итак функция связывания это функция применения специальной функции к специальному значению. У неё как раз такой смысл.</p>
<p>В <code><font color=Green>Prelude</font></code> определены экземпляры класса <code><font color=Green>Monad</font></code> для типов <code><font color=Green>Maybe</font></code> и <code><font color=Green>[]</font></code>.<br />Они определены по такому же принципу, что и наши определения для <code><font color=Green>Kleisli</font></code> только не для композиции, а для применения.</p>
<p>Отметим, что в модуле <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font></code> определены функции <code><font color=Black>sequence</font></code> и <code><font color=Black>mapM</font></code>, они несут тот же смысл, что и функции <code><font color=Black>sequence</font></code> и <code><font color=Black>mapК</font></code>, которые мы определяли для класса <code><font color=Green>Kleisli</font></code>.</p>
<h3 id="свойства-классов"><a href="#свойства-классов">Свойства классов</a></h3>
<p>Посмотрим на свойства функторов и аппликативных функторов.</p>
<h4 id="свойства-класса-functor"><a href="#свойства-класса-functor">Свойства класса Functor</a></h4>
<pre><font color=Black>fmap</font> id x           <font color=Black>==</font> x                <font color="#2149c1">-- тождество</font>
<font color=Black>fmap</font> f <font color=Black>.</font> fmap g     <font color=Black>==</font> fmap <font color=Black>(</font>f <font color=Black>.</font> g<font color=Black>)</font>     <font color="#2149c1">-- композиция</font></pre>
<p>Первое свойство говорит о том, что если мы применяем <code><font color=Black>fmap</font></code> к функции тождества, то мы должны снова получить функцию тождества, или по другому можно сказать, что применение функции тождества к специальному значению не изменяет это значение. Второе свойство говорит о том, что последовательное применение к специальному значению двух обычных функций можно записать в виде применения композиции двух обычных функций к специальному значению.</p>
<p>Если всё это звучит туманно, попробуем переписать эти свойства в терминах композиции:</p>
<pre><font color=Black>mf</font> <font color=Black>+&gt;</font> id         <font color=Black>==</font> mf
<font color=Black>(</font>mf <font color=Black>+&gt;</font> g<font color=Black>)</font> <font color=Black>+&gt;</font> h   <font color=Black>==</font> mf <font color=Black>+&gt;</font> <font color=Black>(</font>g <font color=Black>&gt;&gt;</font> h<font color=Black>)</font></pre>
<p>Первое свойство говорит о том, что тождественная функция не изменяет значение при композиции. Второе свойство указывает на ассоциативность композиции одной специальной функции <code><font color=Black>mf</font></code> и двух обычных функций <code><font color=Black>g</font></code> и <code><font color=Black>h</font></code>.</p>
<h4 id="свойства-класса-applicative"><a href="#свойства-класса-applicative">Свойства класса Applicative</a></h4>
<p>Свойства класса <code><font color=Green>Applicative</font></code>, для наглядности они сформулированы не через методы класса, а через производные функции.</p>
<pre><font color=Black>fmap</font> f x            <font color=Black>==</font> liftA f x             <font color="#2149c1">-- связь с Functor</font>

<font color=Black>liftA</font>  id x         <font color=Black>==</font> x                     <font color="#2149c1">-- тождество</font>
<font color=Black>liftA3</font> <font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> f g x    <font color=Black>==</font> f <font color=Black>&lt;*&gt;</font> <font color=Black>(</font>g <font color=Black>&lt;*&gt;</font> x<font color=Black>)</font>       <font color="#2149c1">-- композиция </font>
<font color=Black>liftA</font>  f <font color=Black>(</font>pure x<font color=Black>)</font>   <font color=Black>==</font> pure <font color=Black>(</font>f x<font color=Black>)</font>            <font color="#2149c1">-- гомоморфизм</font></pre>
<p>Первое свойство говорит о том, что применение специальной функции одного аргумента совпадает с методом <code><font color=Black>fmap</font></code> из класса <code><font color=Green>Functor</font></code>. Свойство тождества идентично аналогичному свойству для класса <code><font color=Green>Functor</font></code>.</p>
<p>Свойство композиции сформулировано хитро, но давайте посмотрим на типы аргументов:</p>
<pre><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>
<font color=Black>f</font>   <font color="#b2590f">::</font> m <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>
<font color=Black>g</font>   <font color="#b2590f">::</font> m <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>    
<font color=Black>x</font>   <font color="#b2590f">::</font> m a

<font color=Black>liftA3</font> <font color=Black>(</font><font color=Black>.</font><font color=Black>)</font> f g x <font color="#b2590f">::</font> m c

<font color=Black>g</font> <font color=Black>&lt;*&gt;</font> x      <font color="#b2590f">::</font> m b
<font color=Black>f</font> <font color=Black>(</font>g <font color=Black>&lt;*&gt;</font> x<font color=Black>)</font>  <font color="#b2590f">::</font> m c</pre>
<p>Слева в свойстве стоит <code><font color=Black>liftA3</font></code>, а не <code><font color=Black>liftA2</font></code>, потому что мы сначала применяем композицию <code><font color=Black>(</font><font color=Black>.</font><font color=Black>)</font></code> к двум функциям <code><font color=Black>f</font></code> и <code><font color=Black>g</font></code>, а затем применяем составную функцию к значению <code><font color=Black>x</font></code>.</p>
<p>Последнее свойство говорит о том, что если мы возьмём обычную функцию и обычное значение и поднимем их в мир специальных значений с помощью <code><font color=Black>lift</font></code> и <code><font color=Black>pure</font></code>, то это тоже самое если бы мы просто применили бы функцию <code><font color=Black>f</font></code> к значению в мире обычных значений и затем подняли бы результат в мир специальных значений.</p>
<h3 id="полное-определение-классов"><a href="#полное-определение-классов">Полное определение классов</a></h3>
<p>На самом деле я немного схитрил. Я рассказал вам только об основных методах классов <code><font color=Green>Applicative</font></code> и <code><font color=Green>Monad</font></code>. Но они содержат ещё несколько дополнительных методов, которые выражаются через остальные. Посмотрим на них, начнём с класса <code><font color=Green>Applicative</font></code>.</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">=&gt;</font> <font color=Green>Applicative</font> f <font color="#b2590f">where</font>
        <font color="#2149c1">-- | Поднимаем значение в мир специальных значений.</font>
        pure <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> f a

        <font color="#2149c1">-- | Применение специального значения-функции.</font>
        <font color=Black>(</font><font color=Black>&lt;*&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> f <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

        <font color="#2149c1">-- | Константная функция. Отбрасываем первое значение.</font>
        <font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f b
        <font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font> <font color="#b2590f">=</font> liftA2 <font color=Black>(</font>const id<font color=Black>)</font>
        
        <font color="#2149c1">-- | Константная функция, Отбрасываем второе значение.</font>
        <font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font> <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f a
        <font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font> <font color="#b2590f">=</font> liftA2 const</pre>
<p>Два новых метода <code><font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font></code> и <code><font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font></code> имеют смысл константных функций. Первая функция игнорирует значение слева, а вторая функция игнорирует значение справа. Посмотрим как они работают в интерпретаторе:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font><font color=Black>&gt;</font> <font color=Green>Just</font> <font color="#0000ee">2</font> <font color=Black>*&gt;</font> <font color=Green>Just</font> <font color="#0000ee">3</font>
<font color=Green>Just</font> <font color="#0000ee">3</font>
<font color=Green>Prelude</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font><font color=Black>&gt;</font> <font color=Green>Nothing</font> <font color=Black>*&gt;</font> <font color=Green>Just</font> <font color="#0000ee">3</font>
<font color=Green>Nothing</font>
<font color=Green>Prelude</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font><font color=Black>&gt;</font> <font color=Black>(</font>const id<font color=Black>)</font> <font color=Green>Nothing</font>  <font color=Green>Just</font> <font color="#0000ee">3</font>
<font color=Green>Just</font> <font color="#0000ee">3</font>
<font color=Green>Prelude</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color="#b2590f">]</font> <font color=Black>&lt;*</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">2</font><font color="#b2590f">]</font></pre>
<p>Значение игнорируется, но способ комбинирования специальных функций учитывается. Так во втором выражении не смотря на то, что мы не учитываем конкретное значение <code><font color=Green>Nothing</font></code>, мы учитываем, что если один из аргументов частично определённой функции не определён, то не определено всё значение. Сравните с результатом выполнения следующего выражения.</p>
<p>По той же причине в последнем выражении мы получили три копии первого списка. Так произошло потому, что второй список содержал три элемента. К каждому из элементов была применена функция <code><font color=Black>const</font> x</code>, где <code><font color=Black>x</font></code> пробегает по элементам списка слева от <code><font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font></code>.</p>
<p>Аналогичный метод есть и в классе <code><font color=Green>Monad</font></code>:</p>
<pre><font color="#b2590f">class</font>  <font color=Green>Monad</font> m  <font color="#b2590f">where</font>
    return  <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font>   <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b
    
    <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font>    <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> m b <font color="#b2590f">-&gt;</font> m b
    fail    <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> m a

    m <font color=Black>&gt;&gt;</font> k  <font color="#b2590f">=</font> m <font color=Black>&gt;&gt;=</font> const k
    fail s  <font color="#b2590f">=</font> error s</pre>
<p>Функция <code><font color=Black>&gt;&gt;</font></code> в классе <code><font color=Green>Monad</font></code>, которую мы прятали из-за символа композиции, является аналогом постоянной функции в классе <code><font color=Green>Monad</font></code>. Она работает так же как и <code><font color=Black>*&gt;</font></code>. Функция <code><font color=Black>fail</font></code> используется для служебных нужд Haskell при выводе ошибок. Поэтому мы её здесь не рассматриваем. Для определения экземпляра класса <code><font color=Green>Monad</font></code> достаточно определить методы <code><font color=Black>return</font></code> и <code><font color=Black>&gt;&gt;=</font></code>.</p>
<h3 id="исторические-замечания"><a href="#исторические-замечания">Исторические замечания</a></h3>
<p>Напрашивается вопрос. Зачем нам функции <code><font color=Black>return</font></code> и <code><font color=Black>pure</font></code> или <code><font color=Black>*&gt;</font></code> и <code><font color=Black>&gt;&gt;</font></code>? Если вы заглянете в документацию к модулю <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font></code>, то там вы найдёте функции <code><font color=Black>liftM</font></code>, <code><font color=Black>liftM2</font></code>, <code><font color=Black>liftM3</font></code>, которые выполняют те же операции, что и аналогичные функции из модуля <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font></code>.</p>
<p>Стандартные библиотеки устроены так, потому что класс <code><font color=Green>Applicative</font></code> появился гораздо позже класса <code><font color=Green>Monad</font></code>. И к появлению этого нового класса уже накопилось огромное число библиотек, которые рассчитаны на прежние имена. Но в будущем возможно прежние классы будут заменены на такие классы:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">where</font>
    fmap <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

<font color="#b2590f">class</font> <font color=Green>Pointed</font> f <font color="#b2590f">where</font>
    pure <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> f a

<font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>Functor</font> f<font color=Black>,</font> <font color=Green>Pointed</font> f<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>Applicative</font> f <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>&lt;*&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> f <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

    <font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font>  <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f b
    <font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font>  <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f a

<font color="#b2590f">class</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Green>Monad</font> f <font color="#b2590f">where</font>
    <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font> <font color="#b2590f">::</font> f a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> f b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f b</pre>
<h2 id="краткое-содержание"><a href="#краткое-содержание">Краткое содержание</a></h2>
<p>В этой главе мы долгой обходной дорогой шли к понятию монады и функтора. Эти классы служат для облегчения работы в мире специальных функций вида <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> m b</code>, в категории Клейсли</p>
<p>С помощью класса <code><font color=Green>Functor</font></code> можно применять специальные значения к обычным функциям одного аргумента:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">where</font>
    fmap <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b</pre>
<p>С помощью класса <code><font color=Green>Applicative</font></code> можно применять специальные значения к обычным функциям любого числа аргументов:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">=&gt;</font> <font color=Green>Applicative</font> f <font color="#b2590f">where</font>
    pure    <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> f a
    <font color=Black>&lt;*&gt;</font>     <font color="#b2590f">::</font> f <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

<font color=Black>liftA</font>  <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b
<font color=Black>liftA2</font> <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f c
<font color=Black>liftA3</font> <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c <font color="#b2590f">-&gt;</font> d<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f c <font color="#b2590f">-&gt;</font> f d
<font color=Black>...</font></pre>
<p>С помощью класса <code><font color=Green>Monad</font></code> можно применять специальные значения к специальным функциям.</p>
<pre><font color="#b2590f">class</font> <font color=Green>Monad</font> m <font color="#b2590f">where</font>
    return  <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font>   <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b</pre>
<p>Функция <code><font color=Black>return</font></code> является функцией <code><font color=Black>id</font></code> в мире специальных функций, а функция <code><font color=Black>&gt;&gt;=</font></code> является функцией применения <code><font color=Black>(</font><font color=Black>$</font><font color=Black>)</font></code>, с обратным порядком следования аргументов. Вспомним также класс <code><font color=Green>Kleisli</font></code>, на примере котором мы узнали много нового из жизни специальных функций:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Kleisli</font> m <font color="#b2590f">where</font>
    idK     <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font>    <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font></pre>
<p>Мы узнали несколько стандартных специальных функций:</p>
<h4 id="частично-определённые-функции-1"><a href="#частично-определённые-функции-1">Частично определённые функции</a></h4>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> b
<font color="#b2590f">data</font> <font color=Green>Maybe</font> a <font color="#b2590f">=</font> <font color=Green>Nothing</font> <font color="#b2590f">|</font> <font color=Green>Just</font> a</pre>
<h4 id="многозначные-функции-1"><a href="#многозначные-функции-1">Многозначные функции</a></h4>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font>
<font color="#b2590f">data</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">=</font> <font color=Green>[]</font> <font color="#b2590f">|</font> a <font color="#b2590f">:</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<h2 id="упражнения"><a href="#упражнения">Упражнения</a></h2>
<p>В первых упражнениях вам предлагается по картинке специальной функции написать экземпляр классов <code><font color=Green>Kleisli</font></code> и <code><font color=Green>Monad</font></code>.</p>
<h4 id="функции-с-состоянием"><a href="#функции-с-состоянием">Функции с состоянием</a></h4>
<div class="figure">
<img src="../pic/6/state0.png" alt="Функция с состоянием" /><p class="caption">Функция с состоянием</p>
</div>
<p> В Haskell нельзя изменять значения. Новые сложные значения описываются в терминах базовых значений. Но как же тогда мы сможем описать функцию с состоянием? Функцию, которая принимает на вход значение, составляет результат на основе внутреннего состояния и значения аргумента и обновляет состояние. Поскольку мы не можем изменять состояние единственное, что нам остаётся – это принимать значение состояния на вход вместе с аргументом и возвращать обновлённое состояние на выходе. У нас получится такой тип:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> s<font color=Black>)</font></pre>
<p>Функция принимает одно значение типа <code><font color=Black>a</font></code> и состояние типа <code><font color=Black>s</font></code>, а возвращает пару, которая состоит из результата типа <code><font color=Black>b</font></code> и обновлённого состояния. Если мы введём синоним:</p>
<pre><font color="#b2590f">type</font> <font color=Green>State</font> s b <font color="#b2590f">=</font> s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> s<font color=Black>)</font></pre>
<p>И вспомним о частичном применении, то мы сможем записать тип функции с состоянием так:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>State</font> s b </pre>
<p>В Haskell пошли дальше и выделили для таких функций специальный тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>State</font> s a <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>(</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font><font color=Black>)</font>

<font color=Black>runState</font> <font color="#b2590f">::</font> <font color=Green>State</font> s a <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font>
<font color=Black>runState</font> <font color=Black>(</font><font color=Green>State</font> f<font color=Black>)</font> <font color="#b2590f">=</font> f</pre>
<div class="figure">
<img src="../pic/6/state1.png" alt="Композиция функций с состоянием" /><p class="caption">Композиция функций с состоянием</p>
</div>
<p>Функция <code><font color=Black>runState</font></code> просто извлекает функцию из оболочки <code><font color=Green>State</font></code>.</p>
<p>На рисунке изображена схема функции с состоянием. В сравнении с обычной функцией у такой функции один дополнительный выход и один дополнительный вход типа <code><font color=Black>s</font></code>. По ним течёт и изменяется состояние.</p>
<p>Попробуйте по схеме композиции для функций с состоянием написать экземпляры для классов <code><font color=Green>Kleisli</font></code> и <code><font color=Green>Monad</font></code> для типа <code><font color=Green>State</font> s</code>.</p>
<p>Подсказка: В этом определении есть одна хитрость, в отличае от типов <code><font color=Green>Maybe</font></code> и <code><font color="#b2590f">[</font>a<font color="#b2590f">]</font></code> у типа <code><font color=Green>State</font></code> два параметра, это параметр состояния и параметр значения. Но мы делаем экземпляр не для <code><font color=Green>State</font></code>, а для <code><font color=Green>State</font> s</code>, то есть мы свяжем тип с некоторым произвольным типом <code><font color=Black>s</font></code>.</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Kleisli</font> <font color=Black>(</font><font color=Green>State</font> s<font color=Black>)</font> <font color="#b2590f">where</font>
	<font color=Black>...</font></pre>
<h4 id="функции-с-окружением"><a href="#функции-с-окружением">Функции с окружением</a></h4>
<p> Сначала мы рассмотрим функции с окружением. Функции с окружением – это такие функции, у которых есть некоторое хранилище данных или окружение, из которых они могут читать информацию. Но в отличие от функций с состоянием они не могут это окружение изменять. Функция с окружением похожа на функцию с состоянием без одного выхода для состояния.</p>
<div class="figure">
<img src="../pic/6/reader0.png" alt="Функция с окружением" /><p class="caption">Функция с окружением</p>
</div>
<p>Функция с окружением принимает аргумент <code><font color=Black>a</font></code> и окружение <code><font color=Black>env</font></code> и возвращает результат <code><font color=Black>b</font></code>:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> env <font color="#b2590f">-&gt;</font> b</pre>
<p>Как и в случае функций с состоянием выделим для функции с окружением отдельный тип. В Haskell он называется <code><font color=Green>Reader</font></code> (от англ. чтец). Все функции с окружением имеют возможность читать из общего хранилища данных. Например они могут иметь доступ на чтение к общей базе данных.</p>
<pre><font color="#b2590f">data</font> <font color=Green>Reader</font> env b <font color="#b2590f">=</font> <font color=Green>Reader</font> <font color=Black>(</font>env <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>

<font color=Black>runReader</font> <font color="#b2590f">::</font> <font color=Green>Reader</font> env b <font color="#b2590f">-&gt;</font> <font color=Black>(</font>env <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>
<font color=Black>runReader</font> <font color=Black>(</font><font color=Green>Reader</font> f<font color=Black>)</font> <font color="#b2590f">=</font> f</pre>
<p>Теперь функция с окружением примет вид:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Reader</font> env b</pre>
<p>Определите для функций с окружением экземпляр класса <code><font color=Green>Kleisli</font></code>. У нас возникнет цепочка функций, каждая из которых будет нуждаться в значении окружения. Поскольку окружение общее для всех функций мы всем функциям передадим одно и то же значение.</p>
<div class="figure">
<img src="../pic/6/reader1.png" alt="Функция с окружением" /><p class="caption">Функция с окружением</p>
</div>
<h4 id="функции-накопители"><a href="#функции-накопители">Функции-накопители</a></h4>
<p> Функции-накопители при вычислении за ширмой накапливают некоторое значение. Функция-накопитель похожа на функцию с состоянием но без стрелки, по которой состояние подаётся в функцию. Функция-накопитель имеет тип: <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> msg<font color=Black>)</font></code></p>
<div class="figure">
<img src="../pic/6/writer0.png" alt="Функция-накопитель" /><p class="caption">Функция-накопитель</p>
</div>
<p>Выделим результат функции в отдельный тип с именем <code><font color=Green>Writer</font></code>.</p>
<pre><font color="#b2590f">data</font> <font color=Green>Writer</font> msg b <font color="#b2590f">=</font> <font color=Green>Writer</font> <font color=Black>(</font>b<font color=Black>,</font> msg<font color=Black>)</font>

<font color=Black>runWriter</font> <font color="#b2590f">::</font> <font color=Green>Writer</font> msg b <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b<font color=Black>,</font> msg<font color=Black>)</font>
<font color=Black>runWriter</font> <font color=Black>(</font><font color=Green>Writer</font> a<font color=Black>)</font> <font color="#b2590f">=</font> a</pre>
<p>Тип функции примет вид:</p>
<pre><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Writer</font> msg b</pre>
<p>Значения типа <code><font color=Black>msg</font></code> мы будем называть сообщениями. Смысл функций <code><font color=Black>a</font> <font color="#b2590f">-&gt;</font> <font color=Green>Writer</font> msg b</code> заключается в том, что при вычислении они накапливают в значении <code><font color=Black>msg</font></code> какую-нибудь информацию. Это могут быть отладочные сообщения. Или база данных, которая открыта для всех функций на запись.</p>
<h4 id="класс-monoid"><a href="#класс-monoid">Класс Monoid</a></h4>
<p>Как мы будем накапливать результат? Пока мы умеем лишь возвращать из функции пару значений. Одно из них нам нужно передать в следующую функцию, а что делать с другим?</p>
<p>На помощь нам придёт класс  <code><font color=Green>Monoid</font></code>, он определён в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Monoid</font> a <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">::</font> a
    mappend <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a</pre>
<p>В этом классе определено пустое значение <code><font color=Black>mempty</font></code> и бинарная функция соединения двух значений в одно. Этот класс очень похож на класс <code><font color=Green>Category</font></code> и <code><font color=Green>Kleisli</font></code>. Там тоже было значение, которое ничего не делает и операция составления нового значения из двух простейших значений. Даже свойства класса похожи:</p>
<pre><font color=Black>mempty</font>  <font color=Black>`mappend`</font> f         <font color="#b2590f">=</font> f
<font color=Black>f</font>       <font color=Black>`mappend`</font> mempty    <font color="#b2590f">=</font> f

<font color=Black>f</font> <font color=Black>`mappend`</font> <font color=Black>(</font>g <font color=Black>`mappend`</font> h<font color=Black>)</font> <font color="#b2590f">=</font>  <font color=Black>(</font>f <font color=Black>`mappend`</font> g<font color=Black>)</font> <font color=Black>`mappend`</font> h </pre>
<div class="figure">
<img src="../pic/6/writer1.png" alt="Композиция функций-накопителей" /><p class="caption">Композиция функций-накопителей</p>
</div>
<p>Первые два свойства говорят о том, что значение <code><font color=Black>mempty</font></code> и вправду является пустым элементом относительно операции <code><font color=Black>mappend</font></code>. А третье свойство говорит о том, что порядок при объединении элементов не важен.</p>
<p>Посмотрим на определение экземпляра для списков:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Monoid</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">=</font> <font color=Green>[]</font>
    mappend <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>++</font><font color=Black>)</font></pre>
<p>Итак пустой элемент это пустой список, а объединение это операция конкатенации списков. Проверим в интерпретаторе:</p>
<pre><font color=Black>*</font><font color=Green>Kleisli</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font><font color=Black>&gt;</font> <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">4</font><font color="#b2590f">]</font> <font color=Black>`mappend`</font> <font color="#b2590f">[</font><font color="#0000ee">4</font><font color=Black>,</font> <font color="#0000ee">3</font> <font color="#b2590f">..</font> <font color="#0000ee">1</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">1</font><font color="#b2590f">]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font><font color=Black>&gt;</font> <font color=Black>"Hello"</font> <font color=Black>`mappend`</font> <font color=Black>" World"</font> <font color=Black>`mappend`</font> mempty
<font color=Black>"Hello World"</font></pre>
<p>Напишите экземпляр класса <code><font color=Green>Kleisli</font></code> для функций накопителей по рисунку. При этом будем считать, что тип <code><font color=Black>msg</font></code> является экземпляром класса <code><font color=Green>Monoid</font></code>.</p>
<h4 id="экземпляры-для-функторов-и-монад"><a href="#экземпляры-для-функторов-и-монад">Экземпляры для функторов и монад</a></h4>
<p>Представьте, что у нас нет класса <code><font color=Green>Kleisli</font></code>, а есть лишь <code><font color=Green>Functor</font></code>, <code><font color=Green>Applicative</font></code> и <code><font color=Green>Monad</font></code>. Напишите экземпляры для этих классов для всех рассмотренных в этой главе специальных функций (в том числе и для <code><font color=Green>Reader</font></code> и <code><font color=Green>Writer</font></code>). Экземпляры <code><font color=Green>Functor</font></code> и <code><font color=Green>Applicative</font></code> могут быть определены через <code><font color=Green>Monad</font></code>. Но для тренировки определите экземпляры полностью. Сначала <code><font color=Green>Functor</font></code>, затем <code><font color=Green>Applicative</font></code> и в последнюю очередь <code><font color=Green>Monad</font></code>.</p>
<h4 id="деревья"><a href="#деревья">Деревья</a></h4>
<p>Напишите экземпляры классов <code><font color=Green>Kleisli</font></code> и <code><font color=Green>Monad</font></code> для двух типов, которые описывают деревья. Бинарные деревья:</p>
<pre><font color="#b2590f">data</font> <font color=Green>BTree</font> a <font color="#b2590f">=</font> <font color=Green>BList</font> a <font color="#b2590f">|</font> <font color=Green>BNode</font> a <font color=Black>(</font><font color=Green>BTree</font> a<font color=Black>)</font> <font color=Black>(</font><font color=Green>BTree</font> a<font color=Black>)</font></pre>
<p>Деревья с несколькими узлами:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Tree</font> a <font color="#b2590f">=</font> <font color=Green>Node</font> a <font color="#b2590f">[</font><font color=Green>Tree</font> a<font color="#b2590f">]</font></pre>
<p>Считайте, что списки являются частными случаями деревьев. В этом смысле деревья будут описывать многозначные функции, которые возвращают несколько значений, организованных в иерархическую структуру.</p>
<h4 id="стандартные-функции"><a href="#стандартные-функции">Стандартные функции</a></h4>
<p>Почитайте документацию к модулям <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font></code> и <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font></code>. Присмотритесь к функциям, попробуйте применить их в интерпретаторе.</p>
<h4 id="эквивалентность-классов-kleisli-и-monad"><a href="#эквивалентность-классов-kleisli-и-monad">Эквивалентность классов Kleisli и Monad</a></h4>
<p>Покажите, что классы <code><font color=Green>Kleisli</font></code> и <code><font color=Green>Monad</font></code> эквивалентны. Для этого нужно для произвольного типа c с одним параметром <code><font color=Black>m</font></code> определить два экземпляра:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Kleisli</font> m <font color="#b2590f">=&gt;</font> <font color=Green>Monad</font>   m <font color="#b2590f">where</font>
<font color="#b2590f">instance</font> <font color=Green>Monad</font>   m <font color="#b2590f">=&gt;</font> <font color=Green>Kelisli</font> m <font color="#b2590f">where</font></pre>
<p>Нужно определить экземпляр одного класса с помощью методов другого.</p>
<h4 id="свойства-класса-monad"><a href="#свойства-класса-monad">Свойства класса Monad</a></h4>
<p>Если класс <code><font color=Green>Monad</font></code> эквивалентен <code><font color=Green>Kleisli</font></code>, то в нём должны выполнятся точно такие же свойства. Запишите свойства класса <code><font color=Green>Kleisli</font></code> через методы класса <code><font color=Green>Monad</font></code></p>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="5.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="7.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="5" style="list-style-type: decimal">
<li>Функции высшего порядка
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="7" style="list-style-type: decimal">
<li>Функторы и монады: примеры
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
