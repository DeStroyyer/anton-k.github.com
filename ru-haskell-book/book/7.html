<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="./style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#функторы-и-монады-примеры">Функторы и монады: примеры</a><ul>
<li><a href="#случайные-числа">Случайные числа</a></li>
<li><a href="#конечные-автоматы">Конечные автоматы</a></li>
<li><a href="#отложенное-вычисление-выражений">Отложенное вычисление выражений</a><ul>
<li><a href="#тип-map">Тип Map</a></li>
</ul></li>
<li><a href="#накопление-результата">Накопление результата</a><ul>
<li><a href="#тип-обёртка-newtype">Тип-обёртка newtype</a></li>
<li><a href="#записи">Записи</a></li>
<li><a href="#накопление-чисел">Накопление чисел</a></li>
<li><a href="#накопление-логических-значений">Накопление логических значений</a></li>
<li><a href="#накопление-списков">Накопление списков</a></li>
</ul></li>
<li><a href="#монада-изменяемых-значений-st">Монада изменяемых значений ST</a><ul>
<li><a href="#тип-st">Тип ST</a></li>
<li><a href="#императивные-циклы">Императивные циклы</a></li>
<li><a href="#быстрая-сортировка">Быстрая сортировка</a></li>
</ul></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="6.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="8.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<h1 id="функторы-и-монады-примеры"><a href="#TOC">Функторы и монады: примеры</a></h1>
<p>В этой главе мы закрепим на примерах то, что мы узнали о монадах и функторах. Напомню, что с помощью монад и функторов мы можем комбинировать специальные функции вида <code><font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font></code> с другими специальными функциями.</p>
<p>У нас есть функции тождества и применения:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">where</font>
    fmap <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

<font color="#b2590f">class</font> <font color=Green>Functor</font> f <font color="#b2590f">=&gt;</font> <font color=Green>Applicative</font> f <font color="#b2590f">where</font>
    pure    <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> f a
    <font color=Black>(</font><font color=Black>&lt;*&gt;</font><font color=Black>)</font>   <font color="#b2590f">::</font> f <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

<font color="#b2590f">class</font> <font color=Green>Monad</font> m <font color="#b2590f">where</font>
    return  <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> m a
    <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font>   <font color="#b2590f">::</font> m a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m b

<font color=Black>(</font><font color=Black>=&lt;&lt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m a <font color="#b2590f">-&gt;</font> m b
<font color=Black>(</font><font color=Black>=&lt;&lt;</font><font color=Black>)</font> <font color="#b2590f">=</font> flip <font color=Black>(</font><font color=Black>&gt;&gt;=</font><font color=Black>)</font></pre>
<p>Вспомним основные производные функции для этих классов:</p>
<p>Или в терминах класса <code><font color=Green>Kleisli</font></code>:</p>
<pre><font color="#2149c1">-- Композиция</font>
<font color=Black>(</font><font color=Black>&gt;=&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Monad</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font>
<font color=Black>(</font><font color=Black>&lt;=&lt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Monad</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>b <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m c<font color=Black>)</font>

<font color="#2149c1">-- Константные функции</font>
<font color=Black>(</font><font color=Black>*&gt;</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f b
<font color=Black>(</font><font color=Black>&lt;*</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f a

<font color="#2149c1">-- Применение обычных функций к специальным значениям</font>
<font color=Black>(</font><font color=Black>&lt;$&gt;</font><font color=Black>)</font>  <font color="#b2590f">::</font> <font color=Green>Functor</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b

<font color=Black>liftA</font>  <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font>           <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b
<font color=Black>liftA2</font> <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font>      <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f c
<font color=Black>liftA3</font> <font color="#b2590f">::</font> <font color=Green>Applicative</font> f <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c <font color="#b2590f">-&gt;</font> d<font color=Black>)</font> <font color="#b2590f">-&gt;</font> f a <font color="#b2590f">-&gt;</font> f b <font color="#b2590f">-&gt;</font> f c <font color="#b2590f">-&gt;</font> f d

<font color="#2149c1">-- Преобразование элементов списка специальной функцией</font>
<font color=Black>mapM</font>   <font color="#b2590f">::</font> <font color=Green>Monad</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> m <font color="#b2590f">[</font>b<font color="#b2590f">]</font></pre>
<p>Нам понадобится модуль с определениями типов и экземпляров монад для всех типов, которые мы рассмотрели в предыдущей главе. Экземпляры для <code><font color=Green>[]</font></code> и <code><font color=Green>Maybe</font></code> уже определены в <code><font color=Green>Prelude</font></code>, а типы <code><font color=Green>State</font></code>, <code><font color=Green>Reader</font></code> и <code><font color=Green>Writer</font></code> можно найти в библиотеках <code><font color=Black>mtl</font></code> и <code><font color=Black>transformers</font></code>. Пока мы не знаем как устанавливать библиотеки определим эти типы и экземпляры для <code><font color=Green>Monad</font></code> самостоятельно. Возможно вы уже определили их, выполняя одно из упражнений предыдущей главы, если это так сейчас вы можете сверить ответы. Определим модуль <code><font color=Green>Types</font></code>:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Types</font><font color=Black>(</font>
    <font color=Green>State</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Reader</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font> <font color=Green>Writer</font><font color=Black>(</font><font color="#b2590f">..</font><font color=Black>)</font><font color=Black>,</font>
    runState<font color=Black>,</font> runWriter<font color=Black>,</font> runReader<font color=Black>,</font>
    <font color="#b2590f">module</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font><font color=Black>,</font>
    <font color="#b2590f">module</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font><font color=Black>,</font>
    <font color="#b2590f">module</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font><font color=Black>)</font>    
<font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font>
<font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font>
<font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font>

<font color="#2149c1">-------------------------------------------------</font>
<font color="#2149c1">-- Функции с состоянием</font>
<font color="#2149c1">--</font>
<font color="#2149c1">--      a -&gt; State s b</font>

<font color="#b2590f">data</font> <font color=Green>State</font> s a <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>(</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font><font color=Black>)</font>

<font color=Black>runState</font> <font color="#b2590f">::</font> <font color=Green>State</font> s a <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font>
<font color=Black>runState</font> <font color=Black>(</font><font color=Green>State</font> f<font color=Black>)</font> <font color="#b2590f">=</font> f

<font color="#b2590f">instance</font> <font color=Green>Monad</font> <font color=Black>(</font><font color=Green>State</font> s<font color=Black>)</font> <font color="#b2590f">where</font>
    return a  <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>$</font> <font color="#b2590f">\</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font>
    ma <font color=Black>&gt;&gt;=</font> mf <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>$</font> <font color="#b2590f">\</font>s0 <font color="#b2590f">-&gt;</font> 
                    <font color="#b2590f">let</font> <font color=Black>(</font>b<font color=Black>,</font> s1<font color=Black>)</font> <font color="#b2590f">=</font> runState ma s0
                    <font color="#b2590f">in</font>   runState <font color=Black>(</font>mf b<font color=Black>)</font> s1

<font color="#2149c1">---------------------------------------------------</font>
<font color="#2149c1">-- Функции с окружением</font>
<font color="#2149c1">--</font>
<font color="#2149c1">--      a -&gt; Reader env b</font>

<font color="#b2590f">data</font> <font color=Green>Reader</font> env a <font color="#b2590f">=</font> <font color=Green>Reader</font> <font color=Black>(</font>env <font color="#b2590f">-&gt;</font> a<font color=Black>)</font>

<font color=Black>runReader</font> <font color="#b2590f">::</font> <font color=Green>Reader</font> env a <font color="#b2590f">-&gt;</font> env <font color="#b2590f">-&gt;</font> a
<font color=Black>runReader</font> <font color=Black>(</font><font color=Green>Reader</font> f<font color=Black>)</font> <font color="#b2590f">=</font> f

<font color="#b2590f">instance</font> <font color=Green>Monad</font> <font color=Black>(</font><font color=Green>Reader</font> env<font color=Black>)</font> <font color="#b2590f">where</font>
    return a    <font color="#b2590f">=</font> <font color=Green>Reader</font> <font color=Black>$</font> const a
    ma <font color=Black>&gt;&gt;=</font> mf   <font color="#b2590f">=</font> <font color=Green>Reader</font> <font color=Black>$</font> <font color="#b2590f">\</font>env <font color="#b2590f">-&gt;</font> 
                    <font color="#b2590f">let</font> b <font color="#b2590f">=</font> runReader ma env
                    <font color="#b2590f">in</font>  runReader <font color=Black>(</font>mf b<font color=Black>)</font> env 
                    
<font color="#2149c1">---------------------------------------------------</font>
<font color="#2149c1">-- Функции-накопители</font>
<font color="#2149c1">--</font>
<font color="#2149c1">--      Monoid msg =&gt; a -&gt; Writer msg b</font>

<font color="#b2590f">data</font> <font color=Green>Writer</font> msg a <font color="#b2590f">=</font> <font color=Green>Writer</font> <font color=Black>(</font>a<font color=Black>,</font> msg<font color=Black>)</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>)</font>

<font color=Black>runWriter</font> <font color="#b2590f">::</font> <font color=Green>Writer</font> msg a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> msg<font color=Black>)</font>
<font color=Black>runWriter</font> <font color=Black>(</font><font color=Green>Writer</font> f<font color=Black>)</font> <font color="#b2590f">=</font> f

<font color="#b2590f">instance</font> <font color=Green>Monoid</font> msg <font color="#b2590f">=&gt;</font> <font color=Green>Monad</font> <font color=Black>(</font><font color=Green>Writer</font> msg<font color=Black>)</font> <font color="#b2590f">where</font>
    return a    <font color="#b2590f">=</font> <font color=Green>Writer</font> <font color=Black>(</font>a<font color=Black>,</font> mempty<font color=Black>)</font>
    ma <font color=Black>&gt;&gt;=</font> mf   <font color="#b2590f">=</font> <font color=Green>Writer</font> <font color=Black>(</font>c<font color=Black>,</font> msgA <font color=Black>`mappend`</font> msgF<font color=Black>)</font>
        <font color="#b2590f">where</font> <font color=Black>(</font>b<font color=Black>,</font> msgA<font color=Black>)</font> <font color="#b2590f">=</font> runWriter ma
              <font color=Black>(</font>c<font color=Black>,</font> msgF<font color=Black>)</font> <font color="#b2590f">=</font> runWriter <font color=Black>$</font> mf b</pre>
<p>Я пропустил определения для экземпляров классов <code><font color=Green>Functor</font></code> и <code><font color=Green>Applicative</font></code>, их можно получить из экземпляра для класса <code><font color=Green>Monad</font></code> с помощью стандартных функций <code><font color=Black>liftM</font></code>, <code><font color=Black>return</font></code> и <code><font color=Black>ap</font></code> из модуля <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font></code>.</p>
<p>Нам встретилась новая запись в экспорте модуля. Для удобства мы экспортируем модули <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Applicative</font></code>, <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font></code> и <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font></code> целиком. Для этого мы написали ключевое слово <code><font color="#b2590f">module</font></code> перед экспортируемым модулем. Теперь если мы в каком-нибудь другом модуле импортируем модуль <code><font color=Green>Types</font></code> нам станут доступными все функции из этих модулей.</p>
<p>Мы определили экземпляры для <code><font color=Green>Functor</font></code> и <code><font color=Green>Applicative</font></code> с помощью производных функций класса <code><font color=Green>Monad</font></code>.</p>
<h2 id="случайные-числа"><a href="#TOC">Случайные числа</a></h2>
<p>С помощью монады <code><font color=Green>State</font></code> можно имитировать случайные числа. Мы будем генерировать случайные числа из интервала от 0 до 1 с помощью алгоритма:</p>
<pre><font color=Black>nextRandom</font> <font color="#b2590f">::</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Black>nextRandom</font> <font color="#b2590f">=</font> snd <font color=Black>.</font> properFraction <font color=Black>.</font> <font color=Black>(</font><font color="#0000ee">105.947</font> <font color=Black>*</font> <font color=Black>)</font></pre>
<p>Функция <code><font color=Black>properFraction</font></code> возвращает пару, которая состоит из целой части и остатка числа. Взяв второй элемент пары с помощью <code><font color=Black>snd</font></code>, мы выделяем остаток. Функция <code><font color=Black>nextRandom</font></code> представляет собой генератор случайных чисел, который принимает значение с предыдущего шага и строит по нему следующее значение.</p>
<p>Построим тип для случайных чисел:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Random</font> a <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Green>Double</font> a

<font color=Black>next</font> <font color="#b2590f">::</font> <font color=Green>Random</font> <font color=Green>Double</font>
<font color=Black>next</font> <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>$</font> <font color="#b2590f">\</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>s<font color=Black>,</font> nextRandom s<font color=Black>)</font></pre>
<p>Теперь определим функцию, которая прибавляет к данному числу случайное число из интервала от 0 до 1:</p>
<pre><font color=Black>addRandom</font> <font color="#b2590f">::</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>Random</font> <font color=Green>Double</font>
<font color=Black>addRandom</font> x <font color="#b2590f">=</font> fmap <font color=Black>(</font><font color=Black>+</font>x<font color=Black>)</font> next </pre>
<p>Посмотрим как эта функция работает в интерпретаторе:</p>
<pre><font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState <font color=Black>(</font>addRandom <font color="#0000ee">5</font><font color=Black>)</font> <font color="#0000ee">0.5</font>
<font color=Black>(</font><font color="#0000ee">5.5</font><font color=Black>,</font><font color="#0000ee">0.9735000000000014</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState <font color=Black>(</font>addRandom <font color="#0000ee">5</font><font color=Black>)</font> <font color="#0000ee">0.7</font>
<font color=Black>(</font><font color="#0000ee">5.7</font><font color=Black>,</font><font color="#0000ee">0.16289999999999338</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState <font color=Black>(</font>mapM addRandom <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">5</font><font color="#b2590f">]</font><font color=Black>)</font> <font color="#0000ee">0.5</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color="#0000ee">1.5</font><font color=Black>,</font><font color="#0000ee">2.9735000000000014</font><font color=Black>,</font><font color="#0000ee">3.139404500000154</font><font color=Black>,</font><font color="#0000ee">4.769488561516319</font><font color=Black>,</font>
 <font color="#0000ee">5.5250046269694195</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#0000ee">0.6226652135290891</font><font color=Black>)</font></pre>
<p>В последней строчке мы с помощью функции <code><font color=Black>mapM</font></code> прибавили ко всем элементам списка разные случайные числа, обновление счётчика происходило за кадром, с помощью функции <code><font color=Black>mapM</font></code> и экземпляра <code><font color=Green>Monad</font></code> для <code><font color=Green>State</font></code>.</p>
<p>Также мы можем определить функцию, которая складывает два случайных числа, одно из интервала <code><font color="#b2590f">[</font><font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>+</font>a<font color=Black>,</font> <font color="#0000ee">1</font><font color=Black>+</font>a<font color="#b2590f">]</font></code>, а другое из интервала <code><font color="#b2590f">[</font><font color="#2149c1">-</font><font color="#0000ee">2</font><font color=Black>+</font>b<font color=Black>,</font><font color="#0000ee">2</font><font color=Black>+</font>b<font color="#b2590f">]</font></code>:</p>
<pre><font color=Black>addRandom2</font> <font color="#b2590f">::</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font> <font color="#b2590f">-&gt;</font> <font color=Green>Random</font> <font color=Green>Double</font>
<font color=Black>addRandom2</font> a b <font color="#b2590f">=</font> liftA2 add next next
    <font color="#b2590f">where</font> add  a b <font color="#b2590f">=</font> <font color="#b2590f">\</font>x y <font color="#b2590f">-&gt;</font> diap a <font color="#0000ee">1</font> x <font color=Black>+</font> diap b <font color="#0000ee">1</font> y
          diap c r <font color="#b2590f">=</font> <font color="#b2590f">\</font>x   <font color="#b2590f">-&gt;</font> x <font color=Black>*</font> <font color="#0000ee">2</font> <font color=Black>*</font> r <font color="#2149c1">-</font> r <font color=Black>+</font> c</pre>
<p>Функция <code><font color=Black>diap</font></code> перемещает интервал от 0 до 1 в интервал от <code><font color=Black>c</font><font color="#2149c1">-</font>r</code> до <code><font color=Black>c</font><font color=Black>+</font>r</code>. Обратите внимание на то как мы сначала составили обычную функцию <code><font color=Black>add</font></code>, которая перемещает значения из интервала от 0 до 1 в нужный диапазон и складывает. И только в самый последний момент мы применили к этой функции случайные значения. Посмотрим как работает эта функция:</p>
<pre><font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState <font color=Black>(</font>addRandom2 <font color="#0000ee">0</font> <font color="#0000ee">10</font><font color=Black>)</font> <font color="#0000ee">0.5</font>
<font color=Black>(</font><font color="#0000ee">10.947000000000003</font><font color=Black>,</font><font color="#0000ee">0.13940450000015403</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState <font color=Black>(</font>addRandom2 <font color="#0000ee">0</font> <font color="#0000ee">10</font><font color=Black>)</font> <font color="#0000ee">0.7</font>
<font color=Black>(</font><font color="#0000ee">9.725799999999987</font><font color=Black>,</font><font color="#0000ee">0.2587662999992979</font><font color=Black>)</font></pre>
<p>Прибавим два списка и получим сумму:</p>
<pre><font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> res <font color="#b2590f">=</font> fmap sum <font color=Black>$</font> zipWithM addRandom2 <font color="#b2590f">[</font><font color="#0000ee">1</font><font color="#b2590f">..</font><font color="#0000ee">3</font><font color="#b2590f">]</font> <font color="#b2590f">[</font><font color="#0000ee">11</font> <font color="#b2590f">..</font> <font color="#0000ee">13</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState res <font color="#0000ee">0.5</font>
<font color=Black>(</font><font color="#0000ee">43.060125804029965</font><font color=Black>,</font><font color="#0000ee">0.969511377766409</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState res <font color="#0000ee">0.7</font>
<font color=Black>(</font><font color="#0000ee">39.86034841613788</font><font color=Black>,</font><font color="#0000ee">0.26599261421101517</font><font color=Black>)</font></pre>
<p>Функция <code><font color=Black>zipWithM</font></code> является аналогом функции <code><font color=Black>zipWith</font></code>. Она устроена также как и функция <code><font color=Black>mapM</font></code>, сначала применяется обычная функция <code><font color=Black>zipWith</font></code>, а затем функция <code><font color=Black>sequence</font></code>.</p>
<p>С помощью типа <code><font color=Green>Random</font></code> мы можем определить функцию подбрасывания монетки:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Coin</font> <font color="#b2590f">=</font> <font color=Green>Heads</font> <font color="#b2590f">|</font> <font color=Green>Tails</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>)</font>

<font color=Black>dropCoin</font> <font color="#b2590f">::</font> <font color=Green>Random</font> <font color=Green>Coin</font>
<font color=Black>dropCoin</font> <font color="#b2590f">=</font> fmap drop' next
    <font color="#b2590f">where</font> drop' x 
            <font color="#b2590f">|</font> x <font color=Black>&lt;</font> <font color="#0000ee">0.5</font>   <font color="#b2590f">=</font> <font color=Green>Heads</font>
            <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font> <font color=Green>Tails</font>                    </pre>
<p>У монетки две стороны орёл (<code><font color=Green>Heads</font></code>) и решка (<code><font color=Green>Tails</font></code>). Поскольку шансы на выпадание той или иной стороны равны, мы для определения стороны разделяем интервал от 0 до 1 в равных пропорциях.</p>
<p>Подбросим монетку пять раз:</p>
<pre><font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> res <font color="#b2590f">=</font> sequence <font color=Black>$</font> replicate <font color="#0000ee">5</font> dropCoin</pre>
<p>Функция <code><font color=Black>replicate</font> n a</code> составляет список из <code><font color=Black>n</font></code> повторяющихся элементов <code><font color=Black>a</font></code>. Посмотрим что у нас получилось:</p>
<pre><font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState res <font color="#0000ee">0.4</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color=Green>Heads</font><font color=Black>,</font><font color=Green>Heads</font><font color=Black>,</font><font color=Green>Heads</font><font color=Black>,</font><font color=Green>Heads</font><font color=Black>,</font><font color=Green>Tails</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#0000ee">0.5184926967068364</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Random</font><font color=Black>&gt;</font> runState res <font color="#0000ee">0.5</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color=Green>Tails</font><font color=Black>,</font><font color=Green>Tails</font><font color=Black>,</font><font color=Green>Heads</font><font color=Black>,</font><font color=Green>Tails</font><font color=Black>,</font><font color=Green>Tails</font><font color="#b2590f">]</font><font color=Black>,</font><font color="#0000ee">0.6226652135290891</font><font color=Black>)</font></pre>
<h2 id="конечные-автоматы"><a href="#TOC">Конечные автоматы</a></h2>
<p>С помощью монады <code><font color=Green>State</font></code> можно описывать конечные автоматы (finite-state machine). Конечный автомат находится в каком-то начальном состоянии. Он принимает на вход ленту событий. Одно событие происходит за другим. На каждое событие автомат реагирует переходом из одного состояния в другое.</p>
<pre><font color="#b2590f">type</font> <font color=Green>FSM</font> s <font color="#b2590f">=</font> <font color=Green>State</font> s s

<font color=Black>fsm</font> <font color="#b2590f">::</font> <font color=Black>(</font>ev <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> s<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>ev <font color="#b2590f">-&gt;</font> <font color=Green>FSM</font> s<font color=Black>)</font>
<font color=Black>fsm</font> transition <font color="#b2590f">=</font> <font color="#b2590f">\</font>e <font color="#b2590f">-&gt;</font> <font color=Green>State</font> <font color=Black>$</font> <font color="#b2590f">\</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>s<font color=Black>,</font> transition e s<font color=Black>)</font></pre>
<p>Функция <code><font color=Black>fsm</font></code> принимает функцию переходов состояний <code><font color=Black>transition</font></code> и возвращает функцию, которая принимает состояние и возвращает конечный автомат. В качестве значения конечный автомат <code><font color=Green>FSM</font></code> будет возвращать текущее состояние.</p>
<p>С помощью конечных автоматов можно описывать различные устройства. Лентой событий будет ввод пользователя (нажатие на кнопки, включение/выключение питания).</p>
<p>Приведём простой пример. Рассмотрим колонки, у них есть розетка, кнопка вкл/выкл и регулятор громкости. Возможные состояния:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Speaker</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>SpeakerState</font><font color=Black>,</font> <font color=Green>Level</font><font color=Black>)</font>

<font color="#b2590f">data</font> <font color=Green>SpeakerState</font> <font color="#b2590f">=</font> <font color=Green>Sleep</font> <font color="#b2590f">|</font> <font color=Green>Work</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>)</font>

<font color="#b2590f">data</font> <font color=Green>Level</font>  <font color="#b2590f">=</font> <font color=Green>Level</font> <font color=Green>Int</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>)</font></pre>
<p>Тип колонок складывается из двух значений: состояния и уровня громкости. Колонки могут быть выключенными (<code><font color=Green>Sleep</font></code>) или работать на определённой громкости (<code><font color=Green>Work</font></code>). Считаем, что максимальный уровень громкости составляет 10 единиц, а минимальный ноль единиц. Границы диапазона громкости описываются такими функциями:</p>
<pre><font color=Black>quieter</font> <font color="#b2590f">::</font> <font color=Green>Level</font> <font color="#b2590f">-&gt;</font> <font color=Green>Level</font>
<font color=Black>quieter</font> <font color=Black>(</font><font color=Green>Level</font> n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Level</font> <font color=Black>$</font> max <font color="#0000ee">0</font> <font color=Black>(</font>n<font color="#2149c1">-</font><font color="#0000ee">1</font><font color=Black>)</font>

<font color=Black>louder</font> <font color="#b2590f">::</font> <font color=Green>Level</font> <font color="#b2590f">-&gt;</font> <font color=Green>Level</font>
<font color=Black>louder</font> <font color=Black>(</font><font color=Green>Level</font> n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Level</font> <font color=Black>$</font> min <font color="#0000ee">10</font> <font color=Black>(</font>n<font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font></pre>
<p>Мы будем обновлять значения уровня громкости не напрямую, а с помощью вспомогательных функций <code><font color=Black>louder</font></code> и <code><font color=Black>quieter</font></code>. Так мы не сможем выйти за пределы заданного диапазона.</p>
<p>Возможные события:</p>
<pre><font color="#b2590f">data</font> <font color=Green>User</font> <font color="#b2590f">=</font> <font color=Green>Button</font> <font color="#b2590f">|</font> <font color=Green>Quieter</font> <font color="#b2590f">|</font> <font color=Green>Louder</font>
    <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>)</font></pre>
<p>Пользователь может либо нажать на кнопку вкл/выкл или повернуть реле громкости влево, чтобы приглушить звук (<code><font color=Green>Quieter</font></code>) или вправо, чтобы сделать погромче (<code><font color=Green>Louder</font></code>). Будем считать, что колонки всегда включены в розетку.</p>
<p>Составим функцию переходов:</p>
<pre><font color=Black>speaker</font> <font color="#b2590f">::</font> <font color=Green>User</font> <font color="#b2590f">-&gt;</font> <font color=Green>FSM</font> <font color=Green>Speaker</font>
<font color=Black>speaker</font> <font color="#b2590f">=</font> fsm <font color=Black>$</font> trans
    <font color="#b2590f">where</font> trans <font color=Green>Button</font>    <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font> n<font color=Black>)</font>
          trans <font color=Green>Button</font>    <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> n<font color=Black>)</font>
          trans <font color=Green>Louder</font>    <font color=Black>(</font>s<font color=Black>,</font>     n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>s<font color=Black>,</font> louder n<font color=Black>)</font>
          trans <font color=Green>Quieter</font>   <font color=Black>(</font>s<font color=Black>,</font>     n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font>s<font color=Black>,</font> quieter n<font color=Black>)</font></pre>
<p>Мы считаем, что при выключении колонок реле остаётся некотором положении, так что при следующем включении они будут работать на той же громкости. Реле можно крутить и в состоянии <code><font color=Green>Sleep</font></code>. Посмотрим на типичную сессию работы колонок:</p>
<pre><font color=Black>*</font><font color=Green>FSM</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> res <font color="#b2590f">=</font> mapM speaker <font color="#b2590f">[</font><font color=Green>Button</font><font color=Black>,</font> <font color=Green>Louder</font><font color=Black>,</font> <font color=Green>Quieter</font><font color=Black>,</font> <font color=Green>Quieter</font><font color=Black>,</font> <font color=Green>Button</font><font color="#b2590f">]</font> </pre>
<p>Сначала мы включаем колонки, затем прибавляем громкость, затем дважды делаем тише и в конце выключаем. Посмотрим что получилось:</p>
<pre><font color=Black>*</font><font color=Green>FSM</font><font color=Black>&gt;</font> runState res <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> <font color=Green>Level</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">2</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">2</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">3</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">2</font><font color=Black>)</font><font color=Black>,</font>
 <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">1</font><font color=Black>)</font><font color="#b2590f">]</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">1</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>FSM</font><font color=Black>&gt;</font> runState res <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> <font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">1</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font>
 <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color="#b2590f">]</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Смотрите, изменив начальное значение, мы изменили весь список значений. Обратите внимание на то, что во втором прогоне мы не ушли в минус по громкости, не смотря на то, что пытались крутить реле за установленный предел.</p>
<p>Определим колонки другого типа. Наши новые колонки будут безопаснее предыдущих. Представьте ситуацию, что мы выключили колонки на высоком уровне громкости. Мы слушали домашнюю запись с низким уровнем звука. Мы выключили и забыли. Потом мы решили послушать другую мелодию, которая записана с нормальным уровнем звука. При включении колонок нас оглушил шквал звука. Чтобы этого избежать мы решили воспользоваться другими колонками.</p>
<p>Колонки при выключении будут выставлять уровень громкости на ноль и реле можно будет крутить только если колонки включены.</p>
<pre><font color=Black>safeSpeaker</font> <font color="#b2590f">::</font> <font color=Green>User</font> <font color="#b2590f">-&gt;</font> <font color=Green>FSM</font> <font color=Green>Speaker</font>
<font color=Black>safeSpeaker</font> <font color="#b2590f">=</font> fsm <font color=Black>$</font> trans
    <font color="#b2590f">where</font> trans <font color=Green>Button</font>  <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> <font color="#b2590f">_</font><font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  <font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font>
          trans <font color=Green>Button</font>  <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  <font color="#b2590f">_</font><font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> <font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font>
          trans <font color=Green>Quieter</font> <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  quieter n<font color=Black>)</font>
          trans <font color=Green>Louder</font>  <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font>  louder n<font color=Black>)</font>
          trans <font color="#b2590f">_</font>       <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> n<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> n<font color=Black>)</font></pre>
<p>При нажатии на кнопку вкл/выкл уровень громкости выводится в положение 0. Колонки реагируют на запросы изменения уровня громкости только в состоянии <code><font color=Green>Work</font></code>. Посмотрим как работают наши новые колонки:</p>
<pre><font color=Black>*</font><font color=Green>FSM</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> res <font color="#b2590f">=</font> mapM safeSpeaker <font color="#b2590f">[</font><font color=Green>Button</font><font color=Black>,</font> <font color=Green>Louder</font><font color=Black>,</font> <font color=Green>Quieter</font><font color=Black>,</font> <font color=Green>Button</font><font color=Black>,</font> <font color=Green>Louder</font><font color="#b2590f">]</font></pre>
<p>Мы включаем колонки, делаем по-громче, затем по-тише, затем выключаем и пытаемся изменить громкость после выключения. Посмотрим как они сработают, представим, что мы выключили колонки на уровне громкости <code><font color="#0000ee">10</font></code>:</p>
<pre><font color=Black>*</font><font color=Green>FSM</font><font color=Black>&gt;</font> runState res <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font> <font color=Green>Level</font> <font color="#0000ee">10</font><font color=Black>)</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">10</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">1</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font>
 <font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color="#b2590f">]</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Первое значение в списке является стартовым состоянием, которое мы задали. После этого колонки включаются и мы видим, что уровень громкости переключился на ноль. Затем мы увеличиваем громкость, сбавляем её и выключаем. Попытка изменить громкость выключенных колонок не проходит. Это видно по последнему элементу списка и итоговому состоянию колонок, которое находится во втором элементе пары.</p>
<p>Предположим, что колонки работают с самого начала, тогда первым действием мы выключаем их. Посмотрим, что случится дальше:</p>
<pre><font color=Black>*</font><font color=Green>FSM</font><font color=Black>&gt;</font> runState res <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font> <font color=Green>Level</font> <font color="#0000ee">10</font><font color=Black>)</font>
<font color=Black>(</font><font color="#b2590f">[</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">10</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Sleep</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color=Black>,</font>
 <font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">0</font><font color=Black>)</font><font color="#b2590f">]</font><font color=Black>,</font><font color=Black>(</font><font color=Green>Work</font><font color=Black>,</font><font color=Green>Level</font> <font color="#0000ee">1</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Дальше мы пытаемся изменить громкость но у нас ничего не выходит.</p>
<h2 id="отложенное-вычисление-выражений"><a href="#TOC">Отложенное вычисление выражений</a></h2>
<p>В этом примере мы будем выполнять арифметические операции на целых числах. Мы будем их складывать, вычитать и умножать. Но вместо того, чтобы сразу вычислять выражения мы будем составлять их описание. Мы будем кодировать операции конструкторами.</p>
<pre><font color="#b2590f">data</font> <font color=Green>Exp</font>    <font color="#b2590f">=</font> <font color=Green>Var</font> <font color=Green>String</font>
            <font color="#b2590f">|</font> <font color=Green>Lit</font> <font color=Green>Int</font>
            <font color="#b2590f">|</font> <font color=Green>Neg</font> <font color=Green>Exp</font>
            <font color="#b2590f">|</font> <font color=Green>Add</font> <font color=Green>Exp</font> <font color=Green>Exp</font>
            <font color="#b2590f">|</font> <font color=Green>Mul</font> <font color=Green>Exp</font> <font color=Green>Exp</font>
            <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font></pre>
<p>У нас есть тип <code><font color=Green>Exp</font></code>, который может быть либо переменной <code><font color=Green>Var</font></code> с данным строчным именем, либо целочисленной константой <code><font color=Green>Lit</font></code>, либо одной из трёх операций: вычитанием (<code><font color=Green>Neg</font></code>), сложением (<code><font color=Green>Add</font></code>) или умножением (<code><font color=Green>Mul</font></code>).</p>
<p>Такие типы называют <em>абстрактными синтаксическими деревьями</em> (abstract syntax tree, AST). Они содержат описание выражений. Теперь вместо того чтобы сразу проводить вычисления мы будем собирать выражения в значении типа <code><font color=Green>Exp</font></code>. Сделаем экземпляр для <code><font color=Green>Num</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> <font color=Green>Exp</font> <font color="#b2590f">where</font>
    negate  <font color="#b2590f">=</font> <font color=Green>Neg</font>
    <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font>     <font color="#b2590f">=</font> <font color=Green>Add</font>
    <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font>     <font color="#b2590f">=</font> <font color=Green>Mul</font>

    fromInteger <font color="#b2590f">=</font> <font color=Green>Lit</font> <font color=Black>.</font> fromInteger

    abs     <font color="#b2590f">=</font> undefined
    signum  <font color="#b2590f">=</font> undefined</pre>
<p>Также определим вспомогательные функции для обозначения переменных:</p>
<pre><font color=Black>var</font> <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font>
<font color=Black>var</font> <font color="#b2590f">=</font> <font color=Green>Var</font>

<font color=Black>n</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font>
<font color=Black>n</font> <font color="#b2590f">=</font> var <font color=Black>.</font> show</pre>
<p>Функция <code><font color=Black>var</font></code> составляет переменную с данным именем, а функция <code><font color=Black>n</font></code> составляет переменную, у которой имя является целым числом. Сохраним эти определения в модуле <code><font color=Green>Exp</font></code>. Теперь у нас всё готово для составления выражений:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> n <font color="#0000ee">1</font>
<font color=Green>Var</font> <font color=Black>"1"</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> n <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font>
<font color=Green>Add</font> <font color=Black>(</font><font color=Green>Var</font> <font color=Black>"1"</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Lit</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#0000ee">3</font> <font color=Black>*</font> <font color=Black>(</font>n <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color=Green>Mul</font> <font color=Black>(</font><font color=Green>Lit</font> <font color="#0000ee">3</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Add</font> <font color=Black>(</font><font color=Green>Var</font> <font color=Black>"1"</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Lit</font> <font color="#0000ee">2</font><font color=Black>)</font><font color=Black>)</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#2149c1">-</font> n <font color="#0000ee">2</font> <font color=Black>*</font> <font color="#0000ee">3</font> <font color=Black>*</font> <font color=Black>(</font>n <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color=Green>Neg</font> <font color=Black>(</font><font color=Green>Mul</font> <font color=Black>(</font><font color=Green>Mul</font> <font color=Black>(</font><font color=Green>Var</font> <font color=Black>"2"</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Lit</font> <font color="#0000ee">3</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Add</font> <font color=Black>(</font><font color=Green>Var</font> <font color=Black>"1"</font><font color=Black>)</font> <font color=Black>(</font><font color=Green>Lit</font> <font color="#0000ee">2</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Теперь давайте создадим функцию для вычисления таких выражений. Она будет принимать выражение и возвращать целое число.</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Lit</font> n<font color=Black>)</font>    <font color="#b2590f">=</font> n
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Neg</font> n<font color=Black>)</font>    <font color="#b2590f">=</font> negate <font color=Black>$</font> eval n
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Add</font> a b<font color=Black>)</font>  <font color="#b2590f">=</font> eval a <font color=Black>+</font> eval b
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Mul</font> a b<font color=Black>)</font>  <font color="#b2590f">=</font> eval a <font color=Black>*</font> eval b
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Var</font> name<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Black>???</font></pre>
<p>Как быть с конструктором <code><font color=Green>Var</font></code>? Нам нужно откуда-то узнать какое значение связано с переменной. Функция <code><font color=Black>eval</font></code> должна также принимать набор значений для всех переменных, которые используются в выражении. Этот набор значений мы будем называть окружением.</p>
<p>Обратите внимание на то, что в каждом составном конструкторе мы рекурсивно вызываем функцию <code><font color=Black>eval</font></code>, мы словно обходим всё дерево выражения. Спускаемся вниз, до самых листьев в которых расположены либо значения (<code><font color=Green>Lit</font></code>), либо переменные (<code><font color=Green>Var</font></code>). Нам было бы удобно иметь возможность пользоваться окружением из любого узла дерева. В этом нам поможет тип <code><font color=Green>Reader</font></code>.</p>
<p>Представим что у нас есть значение типа <code><font color=Green>Env</font></code> и функция, которая позволяет читать значения переменных по имени:</p>
<pre><font color=Black>value</font> <font color="#b2590f">::</font> <font color=Green>Env</font> <font color="#b2590f">-&gt;</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font></pre>
<p>Теперь определим функцию <code><font color=Black>eval</font></code>:</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Reader</font> <font color=Green>Env</font> <font color=Green>Int</font>
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Lit</font> n<font color=Black>)</font>    <font color="#b2590f">=</font> pure n
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Neg</font> n<font color=Black>)</font>    <font color="#b2590f">=</font> liftA  negate <font color=Black>$</font> eval n
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Add</font> a b<font color=Black>)</font>  <font color="#b2590f">=</font> liftA2 <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color=Black>(</font>eval a<font color=Black>)</font> <font color=Black>(</font>eval b<font color=Black>)</font>
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Mul</font> a b<font color=Black>)</font>  <font color="#b2590f">=</font> liftA2 <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color=Black>(</font>eval a<font color=Black>)</font> <font color=Black>(</font>eval b<font color=Black>)</font>
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Var</font> name<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Reader</font> <font color=Black>$</font> <font color="#b2590f">\</font>env <font color="#b2590f">-&gt;</font> value env name </pre>
<p>Определение сильно изменилось, оно стало не таким наглядным. Теперь значение <code><font color=Black>eval</font></code> стало специальным, поэтому при рекурсивном вызове функции <code><font color=Black>eval</font></code> нам приходится поднимать в мир специальных функций обычные функции вычитания, сложения и умножения. Мы можем записать это выражение<br />немного по другому:</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Reader</font> <font color=Green>Env</font> <font color=Green>Int</font>
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Lit</font> n<font color=Black>)</font>    <font color="#b2590f">=</font> pure n
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Neg</font> n<font color=Black>)</font>    <font color="#b2590f">=</font> negateA <font color=Black>$</font> eval n
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Add</font> a b<font color=Black>)</font>  <font color="#b2590f">=</font> eval a <font color=Black>`addA`</font> eval b
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Mul</font> a b<font color=Black>)</font>  <font color="#b2590f">=</font> eval a <font color=Black>`mulA`</font> eval b
<font color=Black>eval</font> <font color=Black>(</font><font color=Green>Var</font> name<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Reader</font> <font color=Black>$</font> <font color="#b2590f">\</font>env <font color="#b2590f">-&gt;</font> value env name    
   
<font color=Black>addA</font>      <font color="#b2590f">=</font> liftA2 <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font>
<font color=Black>mulA</font>      <font color="#b2590f">=</font> liftA2 <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font>  
<font color=Black>negateA</font>   <font color="#b2590f">=</font> liftA negate  </pre>
<h3 id="тип-map"><a href="#TOC">Тип Map</a></h3>
<p> Для того чтобы закончить определение функции <code><font color=Black>eval</font></code> нам нужно определить тип <code><font color=Green>Env</font></code> и функцию <code><font color=Black>value</font></code>. Для этого мы воспользуемся типом <code><font color=Green>Map</font></code>, он предназначен для хранения значений по ключу.</p>
<p>Этот тип живёт в стандартном модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font></code>. Посмотрим на его описание:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Map</font> k a <font color="#b2590f">=</font> <font color="#b2590f">..</font></pre>
<p>Первый параметр типа <code><font color=Black>k</font></code> это ключ, а второй это значение. Мы можем создать значение типа <code><font color=Green>Map</font></code> из списка пар ключ значение с помощью функции <code><font color=Black>fromList</font></code>.</p>
<p>Посмотрим на основные функции:</p>
<pre><font color="#2149c1">-- Создаём значения типа Map                    -- создаём  </font>
<font color=Black>empty</font> <font color="#b2590f">::</font> <font color=Green>Map</font> k a                                <font color="#2149c1">-- пустой Map</font>
<font color=Black>fromList</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> k <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font><font color=Black>(</font>k<font color=Black>,</font> a<font color=Black>)</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Map</font> k a        <font color="#2149c1">-- по списку (ключ, значение)</font>

<font color="#2149c1">-- Узнаём значение по ключу</font>
<font color=Black>(</font><font color=Black>!</font><font color=Black>)</font>     <font color="#b2590f">::</font> <font color=Green>Ord</font> k <font color="#b2590f">=&gt;</font> <font color=Green>Map</font> k a <font color="#b2590f">-&gt;</font> k <font color="#b2590f">-&gt;</font> a           
<font color=Black>lookup</font>  <font color="#b2590f">::</font> <font color=Green>Ord</font> k <font color="#b2590f">=&gt;</font> k <font color="#b2590f">-&gt;</font> <font color=Green>Map</font> k a <font color="#b2590f">-&gt;</font> <font color=Green>Maybe</font> a

<font color="#2149c1">-- Добавляем элементы</font>
<font color=Black>insert</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> k <font color="#b2590f">=&gt;</font> k <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Map</font> k a <font color="#b2590f">-&gt;</font> <font color=Green>Map</font> k a

<font color="#2149c1">-- Удаляем элементы</font>
<font color=Black>delete</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> k <font color="#b2590f">=&gt;</font> k <font color="#b2590f">-&gt;</font> <font color=Green>Map</font> k a <font color="#b2590f">-&gt;</font> <font color=Green>Map</font> k a</pre>
<p>Обратите внимание на ограничение <code><font color=Green>Ord</font> k</code> в этих функциях, ключ должен быть экземпляром класса <code><font color=Green>Ord</font></code>. Посмотрим как эти функции работают:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Black>+</font><font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font>
<font color=Black>*</font><font color=Green>Exp</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color="#2149c1">-</font><font color=Green>Exp</font>
<font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> v <font color="#b2590f">=</font> fromList <font color="#b2590f">[</font><font color=Black>(</font><font color="#0000ee">1</font><font color=Black>,</font> <font color=Black>"Hello"</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color="#0000ee">2</font><font color=Black>,</font> <font color=Black>"Bye"</font><font color=Black>)</font><font color="#b2590f">]</font>
<font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font><font color=Black>&gt;</font> v <font color=Black>!</font> <font color="#0000ee">1</font>
<font color=Black>"Hello"</font>
<font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font><font color=Black>&gt;</font> v <font color=Black>!</font> <font color="#0000ee">3</font>
<font color=Black>"*** Exception: Map.find: element not in the map
Data.Map&gt; lookup 3 v
Nothing
Data.Map&gt; let v1 = insert 3 "</font><font color=Green>Yo</font><font color=Black>" v
Data.Map&gt; v1 ! 3
"</font><font color=Green>Yo</font><font color=Black>"</font></pre>
<p>Функция <code><font color=Black>lookup</font></code> является стабильным аналогом функции <code><font color=Black>!</font></code>. В том смысле, что она определена с помощью <code><font color=Green>Maybe</font></code>. Она не приведёт к падению программы, если для данного ключа не найдётся значение.</p>
<p>Теперь мы можем определить функцию <code><font color=Black>value</font></code>:</p>
<pre><font color="#b2590f">import</font> <font color="#b2590f">qualified</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font> <font color="#b2590f">as</font> <font color=Green>M</font><font color=Black>(</font><font color=Green>Map</font><font color=Black>,</font> lookup<font color=Black>,</font> fromList<font color=Black>)</font>

<font color=Black>...</font>

<font color="#b2590f">type</font> <font color=Green>Env</font> <font color="#b2590f">=</font> <font color=Green>M</font><font color=Black>.</font><font color=Green>Map</font> <font color=Green>String</font> <font color=Green>Int</font>

<font color=Black>value</font> <font color="#b2590f">::</font> <font color=Green>Env</font> <font color="#b2590f">-&gt;</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>value</font> env name <font color="#b2590f">=</font> maybe errorMsg <font color=Black>$</font> <font color=Green>M</font><font color=Black>.</font>lookup env name 
    <font color="#b2590f">where</font> errorMsg <font color="#b2590f">=</font> error <font color=Black>$</font> <font color=Black>"value is undefined for "</font> <font color=Black>++</font> name</pre>
<p>Обычно функции из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font></code> включаются с директивой <code><font color="#b2590f">qualified</font></code>, поскольку имена многих функций из этого модуля совпадают с именами из модуля <code><font color=Green>Prelude</font></code>. Теперь все определения из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font></code> пишутся с приставкой <code><font color=Green>M</font><font color=Black>.</font></code>.</p>
<p>Создадим вспомогательную функцию, которая упростит вычисление выражений:</p>
<pre><font color=Black>runExp</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Black>(</font><font color=Green>String</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>runExp</font> a env <font color="#b2590f">=</font> runReader <font color=Black>(</font>eval a<font color=Black>)</font> <font color=Black>$</font> <font color=Green>M</font><font color=Black>.</font>fromList env</pre>
<p>Сохраним определение новых функций в модуле <code><font color=Green>Exp</font></code>. И посмотрим что у нас получилось:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> env a b <font color="#b2590f">=</font> <font color="#b2590f">[</font><font color=Black>(</font><font color=Black>"1"</font><font color=Black>,</font> a<font color=Black>)</font><font color=Black>,</font> <font color=Black>(</font><font color=Black>"2"</font><font color=Black>,</font> b<font color=Black>)</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> exp <font color="#b2590f">=</font> <font color="#0000ee">2</font> <font color=Black>*</font> <font color=Black>(</font>n <font color="#0000ee">1</font> <font color=Black>+</font> n <font color="#0000ee">2</font><font color=Black>)</font> <font color="#2149c1">-</font> n <font color="#0000ee">1</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> runExp exp <font color=Black>(</font>env <font color="#0000ee">1</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color="#0000ee">5</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> runExp exp <font color=Black>(</font>env <font color="#0000ee">10</font> <font color="#0000ee">5</font><font color=Black>)</font>
<font color="#0000ee">20</font></pre>
<p>Так мы можем пользоваться функциями с окружением для того, чтобы читать значения из общего источника. Впрочем мы можем просто передавать окружение дополнительным аргументом и не пользоваться монадами:</p>
<pre><font color=Black>eval</font> <font color="#b2590f">::</font> <font color=Green>Env</font> <font color="#b2590f">-&gt;</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>eval</font> env x <font color="#b2590f">=</font> <font color="#b2590f">case</font> x <font color="#b2590f">of</font>
    <font color=Green>Lit</font> n       <font color="#b2590f">-&gt;</font> n
    <font color=Green>Neg</font> n       <font color="#b2590f">-&gt;</font> negate <font color=Black>$</font> eval' n
    <font color=Green>Add</font> a b     <font color="#b2590f">-&gt;</font> eval' a <font color=Black>+</font> eval' b
    <font color=Green>Mul</font> a b     <font color="#b2590f">-&gt;</font> eval' a <font color=Black>+</font> eval' b
    <font color=Green>Var</font> name    <font color="#b2590f">-&gt;</font> value env name
    <font color="#b2590f">where</font> eval' <font color="#b2590f">=</font> eval env</pre>
<h2 id="накопление-результата"><a href="#TOC">Накопление результата</a></h2>
<p>Рассмотрим по-подробнее тип <code><font color=Green>Writer</font></code>. Он выполняет задачу обратную к типу <code><font color=Green>Reader</font></code>. Когда мы пользовались типом <code><font color=Green>Reader</font></code>, мы могли в любом месте функции извлекать данные из окружения. Теперь же мы будем не извлекать данные из окружения, а записывать их.</p>
<p>Рассмотрим такую задачу нам нужно обойти дерево типа <code><font color=Green>Exp</font></code> и подсчитать все бинарные операции. Мы прибавляем к накопителю результата единицу за каждый конструктор <code><font color=Green>Add</font></code> или <code><font color=Green>Mul</font></code>. Тип сообщений будет числом. Нам нужно сделать экземпляр класса <code><font color=Green>Monoid</font></code> для чисел.</p>
<p>Напомню, что тип накопителя должен быть экземпляром класса <code><font color=Green>Monoid</font></code>:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Monoid</font> a <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">::</font> a
    mappend <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> a

    mconcat <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
    mconcat <font color="#b2590f">=</font> foldr mappend mempty</pre>
<p>Но для чисел возможно несколько вариантов, которые удовлетворяют свойствам. Для сложения:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Monoid</font> a <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">=</font> <font color="#0000ee">0</font>
    mappend <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font></pre>
<p>И умножения:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Monoid</font> a <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">=</font> <font color="#0000ee">1</font>
    mappend <font color="#b2590f">=</font> <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font></pre>
<p>Для нашей задачи подойдёт первый вариант, но не исключена возможность того, что для другой задачи нам понадобится второй. Но тогда мы уже не сможем определить такой экземпляр. Для решения этой проблемы в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font></code> определено два типа обёртки:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Sum</font>  a <font color="#b2590f">=</font> <font color=Green>Sum</font>  <font color=Black>{</font> getSum  <font color="#b2590f">::</font> a <font color=Black>}</font>
<font color="#b2590f">newtype</font> <font color=Green>Prod</font> a <font color="#b2590f">=</font> <font color=Green>Prod</font> <font color=Black>{</font> getProd <font color="#b2590f">::</font> a <font color=Black>}</font></pre>
<p>В этом определении есть два новых элемента. Первый это ключевое слово  <code><font color="#b2590f">newtype</font></code>, а второй это фигурные скобки. Что всё это значит?</p>
<h3 id="тип-обёртка-newtype"><a href="#TOC">Тип-обёртка newtype</a></h3>
<p>Ключевое слово <code><font color="#b2590f">newtype</font></code> вводит новый тип-обёртку. Тип-обёртка может иметь только один конструктор, у которого лишь одни аргумент. Запись:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Sum</font> a <font color="#b2590f">=</font> <font color=Green>Sum</font> a</pre>
<p>Это тоже самое, что и</p>
<pre><font color="#b2590f">data</font> <font color=Green>Sum</font> a <font color="#b2590f">=</font> <font color=Green>Sum</font> a</pre>
<p>Единственное отличие заключается в том, что в случае <code><font color="#b2590f">newtype</font></code> вычислитель не видит разницы между <code><font color=Green>Sum</font> a</code> и <code><font color=Black>a</font></code>. Её видит лишь компилятор. Это означает, что на разворачивание и заворачивание такого значения в тип обёртку не тратится никаких усилий. Такие типы подходят для решения двух задач:</p>
<ul>
<li><p>Более точная проверка типов.</p>
<p>Например у нас есть типы, которые описывают физические величины, все они являются числами, но у них также есть и размерности. Мы можем написать:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Velocity</font>   <font color="#b2590f">=</font> <font color=Green>Double</font>
<font color="#b2590f">type</font> <font color=Green>Time</font>       <font color="#b2590f">=</font> <font color=Green>Double</font>
<font color="#b2590f">type</font> <font color=Green>Length</font>     <font color="#b2590f">=</font> <font color=Green>Double</font>

<font color=Black>velocity</font> <font color="#b2590f">::</font> <font color=Green>Length</font> <font color="#b2590f">-&gt;</font> <font color=Green>Time</font> <font color="#b2590f">-&gt;</font> <font color=Green>Velocity</font>
<font color=Black>velocity</font> leng time <font color="#b2590f">=</font> leng <font color=Black>/</font> time</pre>
<p>В этом случае мы спокойно можем подставить на место времени путь и наоборот. Но с помощью типов обёрток мы можем исключить эти случаи:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Velocity</font>   <font color="#b2590f">=</font> <font color=Green>Velocity</font>   <font color=Green>Double</font>
<font color="#b2590f">newtype</font> <font color=Green>Time</font>       <font color="#b2590f">=</font> <font color=Green>Time</font>       <font color=Green>Double</font>
<font color="#b2590f">newtype</font> <font color=Green>Length</font>     <font color="#b2590f">=</font> <font color=Green>Length</font>     <font color=Green>Double</font>

<font color=Black>velocity</font> <font color="#b2590f">::</font> <font color=Green>Length</font> <font color="#b2590f">-&gt;</font> <font color=Green>Time</font> <font color="#b2590f">-&gt;</font> <font color=Green>Velocity</font>
<font color=Black>velocity</font> <font color=Black>(</font><font color=Green>Length</font> leng<font color=Black>)</font> <font color=Black>(</font><font color=Green>Time</font> time<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Velocity</font> <font color=Black>$</font> leng <font color=Black>/</font> time</pre>
<p>В этом случае мы проводим проверку по размерностям, компилятор не допустит смешивания данных.</p></li>
<li><p>Определение нескольких экземпляров одного класса для одного типа. Этот случай мы как раз и рассматриваем для класса <code><font color=Green>Monoid</font></code>. Нам нужно сделать два экземпляра для одного и того же типа <code><font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> a</code>.</p>
<p>Сделаем две обёртки!</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Sum</font>  a <font color="#b2590f">=</font> <font color=Green>Sum</font>  a
<font color="#b2590f">newtype</font> <font color=Green>Prod</font> a <font color="#b2590f">=</font> <font color=Green>Prod</font> a</pre>
<p>Тогда мы можем определить два экземпляра для двух разных типов:</p>
<p>Один для <code><font color=Green>Sum</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Monoid</font> <font color=Black>(</font><font color=Green>Sum</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">=</font> <font color=Green>Sum</font> <font color="#0000ee">0</font>
    mappend <font color=Black>(</font><font color=Green>Sum</font> a<font color=Black>)</font> <font color=Black>(</font><font color=Green>Sum</font> b<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Sum</font> <font color=Black>(</font>a <font color=Black>+</font> b<font color=Black>)</font></pre>
<p>А другой для <code><font color=Green>Prod</font></code>:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Monoid</font> <font color=Black>(</font><font color=Green>Prod</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
    mempty  <font color="#b2590f">=</font> <font color=Green>Prod</font> <font color="#0000ee">1</font>
    mappend <font color=Black>(</font><font color=Green>Prod</font> a<font color=Black>)</font> <font color=Black>(</font><font color=Green>Prod</font> b<font color=Black>)</font> <font color="#b2590f">=</font> <font color=Green>Prod</font> <font color=Black>(</font>a <font color=Black>*</font> b<font color=Black>)</font></pre></li>
</ul>
<h3 id="записи"><a href="#TOC">Записи</a></h3>
<p>Вторая новинка заключалась в фигурных скобках. С помощью фигурных скобок в Haskell обозначаются <em>записи</em> (records). Запись это произведение типа, но с выделенными именами для полей.</p>
<p>Например мы можем сделать тип для описания паспорта:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Passport</font>   <font color="#b2590f">=</font> <font color=Green>Person</font> <font color=Black>{</font>
    surname         <font color="#b2590f">::</font> <font color=Green>String</font><font color=Black>,</font>      <font color="#2149c1">-- Фамилия</font>
    givenName       <font color="#b2590f">::</font> <font color=Green>String</font><font color=Black>,</font>      <font color="#2149c1">-- Имя</font>
    nationality     <font color="#b2590f">::</font> <font color=Green>String</font><font color=Black>,</font>      <font color="#2149c1">-- Национальность</font>
    dateOfBirth     <font color="#b2590f">::</font> <font color=Green>Date</font><font color=Black>,</font>        <font color="#2149c1">-- Дата рождения</font>
    sex             <font color="#b2590f">::</font> <font color=Green>Bool</font><font color=Black>,</font>        <font color="#2149c1">-- Пол</font>
    placeOfBirth    <font color="#b2590f">::</font> <font color=Green>String</font><font color=Black>,</font>      <font color="#2149c1">-- Место рождения</font>
    authority       <font color="#b2590f">::</font> <font color=Green>String</font><font color=Black>,</font>      <font color="#2149c1">-- Место выдачи документа</font>
    dateOfIssue     <font color="#b2590f">::</font> <font color=Green>Date</font><font color=Black>,</font>        <font color="#2149c1">-- Дата выдачи</font>
    dateOfExpiry    <font color="#b2590f">::</font> <font color=Green>Date</font>         <font color="#2149c1">-- Дата окончания срока</font>
    <font color=Black>}</font> <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Eq</font><font color=Black>,</font> <font color=Green>Show</font><font color=Black>)</font>           <font color="#2149c1">--      действия</font>

<font color="#b2590f">data</font> <font color=Green>Date</font>   <font color="#b2590f">=</font> <font color=Green>Date</font> <font color=Black>{</font>
                day     <font color="#b2590f">::</font> <font color=Green>Int</font><font color=Black>,</font>
                month   <font color="#b2590f">::</font> <font color=Green>Int</font><font color=Black>,</font>
                year    <font color="#b2590f">::</font> <font color=Green>Int</font>
              <font color=Black>}</font> <font color="#b2590f">deriving</font> <font color=Black>(</font><font color=Green>Show</font><font color=Black>,</font> <font color=Green>Eq</font><font color=Black>)</font></pre>
<p>В фигурных скобках через запятую мы указываем поля. Поле состоит из имени и типа. Теперь нам доступны две операции:</p>
<ul>
<li><p>Чтение полей</p>
<pre><font color=Black>hello</font> <font color="#b2590f">::</font> <font color=Green>Passport</font> <font color="#b2590f">-&gt;</font> <font color=Green>String</font>
<font color=Black>hello</font> p <font color="#b2590f">=</font> <font color=Black>"Hello, "</font> <font color=Black>++</font> givenName p <font color=Black>++</font> <font color=Black>"!"</font></pre>
<p>Для чтения мы просто подставляем в имя поля данное значение. В этой функции мы приветствуем человека и обращаемся к нему по имени. Для того, чтобы узнать его имя мы подсмотрели в паспорт, в поле <code><font color=Black>givenName</font></code>.</p></li>
<li><p>Обновление полей. Для обновления полей мы пользуемся таким синтаксисом:</p>
<pre><font color=Black>value</font> <font color=Black>{</font> fieldName1 <font color="#b2590f">=</font> newValue1<font color=Black>,</font> fieldName2 <font color="#b2590f">=</font> newValue2<font color=Black>,</font> <font color=Black>...</font> <font color=Black>}</font></pre>
<p>Мы присваиваем в значении <code><font color=Black>value</font></code> полю с именем <code><font color=Black>fieldName</font></code> новое значение <code><font color=Black>newFieldValue</font></code>. К примеру продлим срок действия паспорта на десять лет:</p>
<pre><font color=Black>prolongate</font> <font color="#b2590f">::</font> <font color=Green>Passport</font> <font color="#b2590f">-&gt;</font> <font color=Green>Passport</font> 
<font color=Black>prolongate</font> p <font color="#b2590f">=</font> p<font color=Black>{</font> dateOfExpiry <font color="#b2590f">=</font> newDate <font color=Black>}</font>
    <font color="#b2590f">where</font> newDate <font color="#b2590f">=</font> oldDate <font color=Black>{</font> year <font color="#b2590f">=</font> year oldDate <font color=Black>+</font> <font color="#0000ee">10</font> <font color=Black>}</font>
          oldDate <font color="#b2590f">=</font> dateOfExpiry p      </pre></li>
</ul>
<p>Вернёмся к типам <code><font color=Green>Sum</font></code> и <code><font color=Green>Prod</font></code>:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Sum</font>  a <font color="#b2590f">=</font> <font color=Green>Sum</font>  <font color=Black>{</font> getSum  <font color="#b2590f">::</font> a <font color=Black>}</font>
<font color="#b2590f">newtype</font> <font color=Green>Prod</font> a <font color="#b2590f">=</font> <font color=Green>Prod</font> <font color=Black>{</font> getProd <font color="#b2590f">::</font> a <font color=Black>}</font></pre>
<p>Этой записью мы определили два типа-обёртки. У нас есть две функции, которые заворачивают обычное значение, это <code><font color=Green>Sum</font></code> и <code><font color=Green>Prod</font></code>. С помощью записей мы тут же в определении типа определили функции которые разворачивают значения, это <code><font color=Black>getSum</font></code> и <code><font color=Black>getProd</font></code>.</p>
<p>Вспомним определение для типа <code><font color=Green>State</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>State</font> s a <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>(</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font><font color=Black>)</font>

<font color=Black>runState</font> <font color="#b2590f">::</font> <font color=Green>State</font> s a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font><font color=Black>)</font>
<font color=Black>runState</font> <font color=Black>(</font><font color=Green>State</font> f<font color=Black>)</font> <font color="#b2590f">=</font> f</pre>
<p>Было бы гораздо лучше определить его так:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>State</font> s a <font color="#b2590f">=</font> <font color=Green>State</font><font color=Black>{</font> runState <font color="#b2590f">::</font> s <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a<font color=Black>,</font> s<font color=Black>)</font> <font color=Black>}</font></pre>
<h3 id="накопление-чисел"><a href="#TOC">Накопление чисел</a></h3>
<p>Но вернёмся к нашей задаче. Мы будем накапливать сумму в значении типа <code><font color=Green>Sum</font></code>. Поскольку нас интересует лишь значение накопителя, наша функция будет возвращать значение единичного типа <code><font color=Green>()</font></code>.</p>
<pre><font color=Black>countBiFuns</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>countBiFuns</font> <font color="#b2590f">=</font> getSum <font color=Black>.</font> execWriter <font color=Black>.</font> countBiFuns'

<font color=Black>countBiFuns'</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Writer</font> <font color=Black>(</font><font color=Green>Sum</font> <font color=Green>Int</font><font color=Black>)</font> <font color=Green>()</font>
<font color=Black>countBiFuns'</font> x <font color="#b2590f">=</font> <font color="#b2590f">case</font> x <font color="#b2590f">of</font>
    <font color=Green>Add</font> a b <font color="#b2590f">-&gt;</font> tell <font color=Black>(</font><font color=Green>Sum</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>*&gt;</font> bi a b
    <font color=Green>Mul</font> a b <font color="#b2590f">-&gt;</font> tell <font color=Black>(</font><font color=Green>Sum</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>*&gt;</font> bi a b
    <font color=Green>Neg</font> a   <font color="#b2590f">-&gt;</font> un a
    <font color="#b2590f">_</font>       <font color="#b2590f">-&gt;</font> pure <font color=Green>()</font>
    <font color="#b2590f">where</font> bi a b <font color="#b2590f">=</font> countBiFuns' a <font color=Black>*&gt;</font> countBiFuns' b  
          un     <font color="#b2590f">=</font> countBiFuns'

<font color=Black>tell</font> <font color="#b2590f">::</font> <font color=Green>Monoid</font> a <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Writer</font> a <font color=Green>()</font> 
<font color=Black>tell</font> a <font color="#b2590f">=</font> <font color=Green>Writer</font> <font color=Black>(</font><font color=Green>()</font><font color=Black>,</font> a<font color=Black>)</font>

<font color=Black>execWriter</font> <font color="#b2590f">::</font> <font color=Green>Writer</font> msg a <font color="#b2590f">-&gt;</font> msg
<font color=Black>execWriter</font> <font color=Black>(</font><font color=Green>Writer</font> <font color=Black>(</font>a<font color=Black>,</font> msg<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">=</font> msg</pre>
<p>Первая функция <code><font color=Black>countBiFuns</font></code> извлекает значение из типов <code><font color=Green>Writer</font></code> и <code><font color=Green>Sum</font></code>. А вторая функция <code><font color=Black>countBiFuns'</font></code> вычисляет значение.</p>
<p>Мы определили две вспомогательные функции <code><font color=Black>tell</font></code>, которая записывает сообщение в накопитель и <code><font color=Black>execWriter</font></code>, которая возвращает лишь сообщение. Это стандартные для <code><font color=Green>Writer</font></code> функции.</p>
<p>Посмотрим как работает эта функция:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> countBiFuns <font color=Black>(</font>n <font color="#0000ee">2</font><font color=Black>)</font>
<font color="#0000ee">0</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> countBiFuns <font color=Black>(</font>n <font color="#0000ee">2</font> <font color=Black>+</font> n <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font><font color=Black>)</font>
<font color="#0000ee">3</font></pre>
<h3 id="накопление-логических-значений"><a href="#TOC">Накопление логических значений</a></h3>
<p>В модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font></code> определены два типа для накопления логических значений. Это типы <code><font color=Green>All</font></code> и <code><font color=Green>Any</font></code>. С помощью типа <code><font color=Green>All</font></code> мы можем проверить выполняется ли некоторое свойство для всех значений. А с помощью типа <code><font color=Green>Any</font></code> мы можем узнать, что существует хотя бы один элемент, для которых это свойство выполнено.</p>
<p>Посмотрим на определение экземпляров класса <code><font color=Green>Monoid</font></code> для этих типов:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>All</font> <font color="#b2590f">=</font> <font color=Green>All</font> <font color=Black>{</font> getAll <font color="#b2590f">::</font> <font color=Green>Bool</font> <font color=Black>}</font>

<font color="#b2590f">instance</font> <font color=Green>Monoid</font> <font color=Green>All</font> <font color="#b2590f">where</font>
        mempty <font color="#b2590f">=</font> <font color=Green>All</font> <font color=Green>True</font>
        <font color=Green>All</font> x <font color=Black>`mappend`</font> <font color=Green>All</font> y <font color="#b2590f">=</font> <font color=Green>All</font> <font color=Black>(</font>x <font color=Black>&amp;&amp;</font> y<font color=Black>)</font></pre>
<p>В типе <code><font color=Green>All</font></code> мы накапливаем значения с помощью логического “и”. Нейтральным элементом является конструктор <code><font color=Green>True</font></code>. Итоговое значение накопителя будет равно <code><font color=Green>True</font></code> только в том случае, если все накапливаемые сообщения были равны <code><font color=Green>True</font></code>.</p>
<p>В типе <code><font color=Green>Any</font></code> всё наоборот:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Monoid</font> <font color=Green>Any</font> <font color="#b2590f">where</font>
        mempty <font color="#b2590f">=</font> <font color=Green>Any</font> <font color=Green>False</font>
        <font color=Green>Any</font> x <font color=Black>`mappend`</font> <font color=Green>Any</font> y <font color="#b2590f">=</font> <font color=Green>Any</font> <font color=Black>(</font>x <font color=Black>||</font> y<font color=Black>)</font></pre>
<p>Посмотрим как работают эти типы. Составим функцию, которая проверяет отсутствие оператора минус в выражении:</p>
<pre><font color=Black>noNeg</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>noNeg</font> <font color="#b2590f">=</font> not <font color=Black>.</font> getAny <font color=Black>.</font> execWriter <font color=Black>.</font> anyNeg

<font color=Black>anyNeg</font> <font color="#b2590f">::</font> <font color=Green>Exp</font> <font color="#b2590f">-&gt;</font> <font color=Green>Writer</font> <font color=Green>Any</font> <font color=Green>()</font>
<font color=Black>anyNeg</font> x <font color="#b2590f">=</font> <font color="#b2590f">case</font> x <font color="#b2590f">of</font>
    <font color=Green>Neg</font> <font color="#b2590f">_</font>   <font color="#b2590f">-&gt;</font> tell <font color=Black>(</font><font color=Green>Any</font> <font color=Green>True</font><font color=Black>)</font>
    <font color=Green>Add</font> a b <font color="#b2590f">-&gt;</font> bi a b
    <font color=Green>Mul</font> a b <font color="#b2590f">-&gt;</font> bi a b
    <font color="#b2590f">_</font>       <font color="#b2590f">-&gt;</font> pure <font color=Green>()</font>
    <font color="#b2590f">where</font> bi a b <font color="#b2590f">=</font> anyNeg a <font color=Black>*&gt;</font> anyNeg b            </pre>
<p>Функция <code><font color=Black>anyNeg</font></code> проверяет есть ли в выражении хотя бы один конструктор <code><font color=Green>Neg</font></code>. В функции <code><font color=Black>noNeg</font></code> мы извлекаем результат и берём его отрицание, чтобы убедиться в том что в выражении не встретилось ни одного конструктора <code><font color=Green>Neg</font></code>.</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> noNeg <font color=Black>(</font>n <font color="#0000ee">2</font> <font color=Black>+</font> n <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font><font color=Black>)</font>
<font color=Green>True</font>
<font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> noNeg <font color=Black>(</font>n <font color="#0000ee">2</font> <font color="#2149c1">-</font> n <font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font> <font color=Black>+</font> <font color="#0000ee">3</font><font color=Black>)</font>
<font color=Green>False</font></pre>
<h3 id="накопление-списков"><a href="#TOC">Накопление списков</a></h3>
<p>Экземпляр класса <code><font color=Green>Monoid</font></code> определён и для списков. Предположим у нас есть дерево, в каждом узле которого находятся числа, давайте соберём все числа больше 5, но меньше 10. Деревья мы возьмём из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Tree</font> a   <font color="#b2590f">=</font> <font color=Green>Node</font> 
        <font color=Black>{</font> rootLabel <font color="#b2590f">::</font> a           <font color="#2149c1">-- значение метки</font>
        <font color=Black>,</font> subForest <font color="#b2590f">::</font> <font color=Green>Forest</font> a    <font color="#2149c1">-- ноль или несколько дочерних деревьев</font>
        <font color=Black>}</font>

<font color="#b2590f">type</font> <font color=Green>Forest</font> a <font color="#b2590f">=</font> <font color="#b2590f">[</font><font color=Green>Tree</font> a<font color="#b2590f">]</font></pre>
<p>Интересный тип. Тип <code><font color=Green>Tree</font></code> определён через <code><font color=Green>Forest</font></code>, а <code><font color=Green>Forest</font></code> определён через <code><font color=Green>Tree</font></code>. По этому типу мы видим, что каждый узел содержит некоторое значение типа <code><font color=Black>a</font></code>, и список дочерних деревьев.</p>
<p>Составим дерево:</p>
<pre><font color=Black>*</font><font color=Green>Exp</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>m <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> t a <font color="#b2590f">=</font> <font color=Green>Node</font> a <font color=Green>[]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> list a <font color="#b2590f">=</font> <font color=Green>Node</font> a <font color=Green>[]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> bi v a b <font color="#b2590f">=</font> <font color=Green>Node</font> v <font color="#b2590f">[</font>a<font color=Black>,</font> b<font color="#b2590f">]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> un v a   <font color="#b2590f">=</font> <font color=Green>Node</font> v <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> 
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> tree1 <font color="#b2590f">=</font> bi <font color="#0000ee">10</font> <font color=Black>(</font>un <font color="#0000ee">2</font> <font color=Black>$</font> un <font color="#0000ee">6</font> <font color=Black>$</font> list <font color="#0000ee">7</font><font color=Black>)</font> <font color=Black>(</font>list <font color="#0000ee">5</font><font color=Black>)</font>
<font color=Green>Prelude</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> tree2 <font color="#b2590f">=</font> bi <font color="#0000ee">12</font> tree1 <font color=Black>(</font>bi <font color="#0000ee">8</font> tree1 tree1<font color=Black>)</font></pre>
<p>Теперь составим функцию, которая будет обходить дерево, и собирать числа из заданного диапазона:</p>
<pre><font color="#b2590f">type</font> <font color=Green>Diap</font> a <font color="#b2590f">=</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font>

<font color=Black>inDiap</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Diap</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Tree</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>inDiap</font> d <font color="#b2590f">=</font> execWriter <font color=Black>.</font> inDiap' d

<font color=Black>inDiap'</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Diap</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Tree</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Writer</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color=Green>()</font>
<font color=Black>inDiap'</font> d <font color=Black>(</font><font color=Green>Node</font> v xs<font color=Black>)</font> <font color="#b2590f">=</font> pick d v <font color=Black>*&gt;</font> mapM_ <font color=Black>(</font>inDiap' d<font color=Black>)</font> xs 
    <font color="#b2590f">where</font> pick <font color=Black>(</font>a<font color=Black>,</font> b<font color=Black>)</font> v
            <font color="#b2590f">|</font> <font color=Black>(</font>a <font color=Black>&lt;=</font> v<font color=Black>)</font> <font color=Black>&amp;&amp;</font> <font color=Black>(</font>v <font color=Black>&lt;=</font> b<font color=Black>)</font>  <font color="#b2590f">=</font> tell <font color="#b2590f">[</font>v<font color="#b2590f">]</font>
            <font color="#b2590f">|</font> otherwise             <font color="#b2590f">=</font> pure <font color=Green>()</font></pre>
<p>Как и раньше у нас две функции, одна выполняет вычисления, другая извлекает результат из <code><font color=Green>Writer</font></code>. В функции <code><font color=Black>pick</font></code> мы проверяем число на принадлежность интервалу, если это так мы добавляем число к результату, а если нет пропускаем его, добавляя нейтральный элемент (в функции <code><font color=Black>pure</font></code>). Обратите внимание на то как мы обрабатываем список дочерних поддеревьев. Функция <code><font color=Black>mapM_</font></code> является аналогом функции <code><font color=Black>mapM</font></code>, Она используется, если результат функции не важен, а важны те действия, которые происходят при преобразовании списка. В нашем случае это накопление результата. Посмотрим на определение этой функции:</p>
<pre><font color=Black>mapM_</font> <font color="#b2590f">::</font> <font color=Green>Monad</font> m <font color="#b2590f">=&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> m b<font color=Black>)</font> <font color="#b2590f">-&gt;</font>  <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> m <font color=Green>()</font>
<font color=Black>mapM_</font> f <font color="#b2590f">=</font> sequence_ <font color=Black>.</font> map f

<font color=Black>sequence_</font> <font color="#b2590f">::</font> <font color=Green>Monad</font> m <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>m a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> m <font color=Green>()</font>
<font color=Black>sequence_</font> <font color="#b2590f">=</font> foldr <font color=Black>(</font><font color=Black>&gt;&gt;</font><font color=Black>)</font> <font color=Black>(</font>return <font color=Green>()</font><font color=Black>)</font></pre>
<p>Основное отличие состоит в функции <code><font color=Black>sequence_</font></code>. Раньше мы собирали значения в список, а теперь отбрасываем их с помощью константной функции <code><font color=Black>&gt;&gt;</font></code>. В конце мы возвращаем значение единичного типа <code><font color=Green>()</font></code>.</p>
<p>Теперь сохраним в модуле <code><font color=Green>Tree</font></code> определение функции и вспомогательные функции создания деревьев <code><font color=Black>un</font></code>, <code><font color=Black>bi</font></code>, и <code><font color=Black>list</font></code> и посмотрим как наша функция работает:</p>
<pre><font color=Black>*</font><font color=Green>Tree</font><font color=Black>&gt;</font> inDiap <font color=Black>(</font><font color="#0000ee">4</font><font color=Black>,</font> <font color="#0000ee">10</font><font color=Black>)</font> tree2
<font color="#b2590f">[</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">10</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Tree</font><font color=Black>&gt;</font> inDiap <font color=Black>(</font><font color="#0000ee">5</font><font color=Black>,</font> <font color="#0000ee">8</font><font color=Black>)</font> tree2
<font color="#b2590f">[</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">8</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">5</font><font color=Black>,</font><font color="#0000ee">6</font><font color=Black>,</font><font color="#0000ee">7</font><font color=Black>,</font><font color="#0000ee">5</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Tree</font><font color=Black>&gt;</font> inDiap <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">3</font><font color=Black>)</font> tree2
<font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">2</font><font color="#b2590f">]</font></pre>
<h2 id="монада-изменяемых-значений-st"><a href="#TOC">Монада изменяемых значений ST</a></h2>
<p>Возможно читатели, для которых “родным” является один из императивных языков, немного заскучали по изменяемым значениям. Мы говорили, что в Haskell ничего не изменяется, мы даём всё более и более сложные имена статическим значениям, а потом вычислитель редуцирует имена к настоящим значениям. Но есть алгоритмы, которые очень элегантно описываются в терминах изменяемых значений. Примером такого алгоритма может быть быстрая сортировка. Задача состоит в перестановке элементов массива так, чтобы на выходе любой последующий элемент массива был больше предыдущего (для списков эту задачу решают функции <code><font color=Black>sort</font></code> и <code><font color=Black>sortBy</font></code>).</p>
<p>Само по себе явление обновления значения является побочным эффектом. Оно ломает представление о статичности мира, у нас появляются фазы: до обновления и после обновления. Но представьте, что обновление происходит локально, мы постоянно меняем только одно значение, при этом за время обновления ни одна другая переменная <em>не может</em> пользоваться промежуточными значениями и обновления происходят с помощью <em>чистых</em> функций. Представьте функцию, которая принимает значение, выделяет внутри себя память, и при построении результата начинает обновлять значение внутри этой памяти (с помощью чистых функций) и считать что-то ещё полезное на основе этих обновлений, как только вычисления закончатся, память стирается, и возвращается значение. Будет ли такая функция чистой? Интуиция подсказывает, что да. Это было доказано, но для реализации этого требуется небольшой трюк на уровне типов. Получается, что не смотря на то, что функция содержит побочные эффекты, она является чистой, поскольку все побочные эффекты локальны, они происходят только внутри вызова функции и только в самой функции.</p>
<p>Для симуляции обновления значения в Haskell нам нужно решить две проблемы. Как упорядочить обновление значения? И как локализовать его? В императивных языках порядок вычисления выражений строго связан с порядком следования выражений, на примитивном уровне, грубо упрощая, можно сказать, что вычислитель читает код как ленту и выполняет выражение за выражением. В Haskell всё совсем по-другому. Мы можем писать функции в любом порядке, также в любом порядке мы можем объявлять локальные переменные в <code><font color="#b2590f">where</font></code> или <code><font color="#b2590f">let</font></code>-выражениях. Компилятор определяет порядок редукции синонимов по функциональным зависимостям. Синоним <code><font color=Black>f</font></code> не будет раскрыт раньше синонима <code><font color=Black>g</font></code> только в том случае, если результат <code><font color=Black>g</font></code> требуется в <code><font color=Black>f</font></code>. Но с обновлением значения этот вариант не пройдёт, посмотрим на выражение:</p>
<pre><font color=Black>fun</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>fun</font> arg <font color="#b2590f">=</font> 
    <font color="#b2590f">let</font> mem <font color="#b2590f">=</font> new arg
        x   <font color="#b2590f">=</font> read mem
        y   <font color="#b2590f">=</font> x <font color=Black>+</font> <font color="#0000ee">1</font>
        <font color=Black>??</font>  <font color="#b2590f">=</font> write mem y
        z   <font color="#b2590f">=</font> read mem
    <font color="#b2590f">in</font> z</pre>
<p>Предполагается, что в этой функции мы получаем значение <code><font color=Black>arg</font></code>, выделяем память <code><font color=Black>mem</font></code> c помощью специальной функции <code><font color=Black>new</font></code>, которая принимает начальное значение, которое будет храниться в памяти. Затем читаем из памяти, прибавляем к значению единицу, снова записываем в память, потом опять читаем из памяти, сохранив значение в переменной <code><font color=Black>z</font></code>, и в самом конце возвращаем ответ. Налицо две проблемы: <code><font color=Black>z</font></code> не зависит от <code><font color=Black>y</font></code>, поэтому мы можем считать значение <code><font color=Black>z</font></code> в любой момент после инициализации памяти и вторая проблема: что должна возвращать функция <code><font color=Black>write</font></code>?</p>
<p>Для того чтобы упорядочить эти вычисления мы воспользуемся типом <code><font color=Green>State</font></code>. Каждое выражение будет принимать фиктивное состояние и возвращать его. Тогда функция <code><font color=Black>fun</font></code> запишется так:</p>
<pre><font color=Black>fun</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>State</font> s <font color=Green>Int</font>
<font color=Black>fun</font> arg <font color="#b2590f">=</font> <font color=Green>State</font> <font color=Black>$</font> <font color="#b2590f">\</font>s0 <font color="#b2590f">-&gt;</font> 
    <font color="#b2590f">let</font> <font color=Black>(</font>mem<font color=Black>,</font> s1<font color=Black>)</font>   <font color="#b2590f">=</font> runState <font color=Black>(</font>new arg<font color=Black>)</font>          s0
        <font color=Black>(</font><font color=Green>()</font><font color=Black>,</font>  s2<font color=Black>)</font>   <font color="#b2590f">=</font> runState <font color=Black>(</font>write mem arg<font color=Black>)</font>    s1
        <font color=Black>(</font>x<font color=Black>,</font>   s3<font color=Black>)</font>   <font color="#b2590f">=</font> runState <font color=Black>(</font>read mem<font color=Black>)</font>         s2
        y           <font color="#b2590f">=</font> x <font color=Black>+</font> <font color="#0000ee">1</font>
        <font color=Black>(</font><font color=Green>()</font><font color=Black>,</font>  s4<font color=Black>)</font>   <font color="#b2590f">=</font> runState <font color=Black>(</font>write mem y<font color=Black>)</font>      s3
        <font color=Black>(</font>z<font color=Black>,</font>   s5<font color=Black>)</font>   <font color="#b2590f">=</font> runState <font color=Black>(</font>read mem<font color=Black>)</font>         s4
    <font color="#b2590f">in</font> <font color=Black>(</font>z<font color=Black>,</font> s5<font color=Black>)</font>

<font color=Black>new</font>     <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>State</font> s <font color=Black>(</font><font color=Green>Mem</font> a<font color=Black>)</font>
<font color=Black>write</font>   <font color="#b2590f">::</font> <font color=Green>Mem</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>State</font> s <font color=Green>()</font>
<font color=Black>read</font>    <font color="#b2590f">::</font> <font color=Green>Mem</font> a <font color="#b2590f">-&gt;</font> <font color=Green>State</font> s a</pre>
<p>Тип <code><font color=Green>Mem</font></code> параметризован типом значения, которое хранится в памяти. В этом варианте мы не можем изменить порядок следования выражений, поскольку нам приходится передавать состояние. Мы могли бы записать это выражение гораздо короче с помощью методов класса <code><font color=Green>Monad</font></code>, но мне хотелось подчеркнуть как передача состояния навязывает порядок вычисления. Функция <code><font color=Black>write</font></code> теперь возвращает пустой кортеж. Но порядок не теряется за счёт состояния. Пустой кортеж намекает на то, что единственное назначение функции <code><font color=Black>write</font></code> – это обновление состояния.</p>
<p>Однако этого не достаточно. Мы хотим, чтобы обновление значения было скрыто от пользователя в <em>чистой</em> функции. Мы хотим, чтобы тип функции <code><font color=Black>fun</font></code> не содержал типа <code><font color=Green>State</font></code>. Для этого нам откуда-то нужно взять начальное значение состояния. Мы можем решить эту проблему, зафиксировав тип <code><font color=Black>s</font></code>. Пусть это будет тип <code><font color=Green>FakeState</font></code>, скрытый от пользователя.</p>
<pre><font color="#b2590f">module</font> <font color=Green>Mutable</font><font color=Black>(</font>
    <font color=Green>Mutable</font><font color=Black>,</font> <font color=Green>Mem</font><font color=Black>,</font> purge<font color=Black>,</font> 
    new<font color=Black>,</font> read<font color=Black>,</font> write<font color=Black>)</font>
<font color="#b2590f">where</font>

<font color="#b2590f">newtype</font> <font color=Green>Mutable</font> a <font color="#b2590f">=</font> <font color=Green>Mutable</font> <font color=Black>(</font><font color=Green>State</font> <font color=Green>FakeState</font> a<font color=Black>)</font>

<font color="#b2590f">data</font> <font color=Green>FakeState</font> <font color="#b2590f">=</font> <font color=Green>FakeState</font>

<font color=Black>purge</font> <font color="#b2590f">::</font> <font color=Green>Mutable</font> a <font color="#b2590f">-&gt;</font> a
<font color=Black>purge</font> <font color=Black>(</font><font color=Green>Mutable</font> a<font color=Black>)</font> <font color="#b2590f">=</font> fst <font color=Black>$</font> runState a <font color=Green>FakeState</font>

<font color=Black>new</font>     <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Mutable</font> <font color=Black>(</font><font color=Green>Mem</font> a<font color=Black>)</font>
<font color=Black>read</font>    <font color="#b2590f">::</font> <font color=Green>Mem</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Mutable</font> a
<font color=Black>write</font>   <font color="#b2590f">::</font> <font color=Green>Mem</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Mutable</font> <font color=Green>()</font></pre>
<p>Мы предоставим пользователю лишь тип <code><font color=Green>Mutable</font></code> без конструктора и функцию <code><font color=Black>purge</font></code>, которая “очищает” значение от побочных эффектов и примитивные функции для работы с памятью. Также мы определим экземпляры классов типа <code><font color=Green>State</font></code> для <code><font color=Green>Mutable</font></code>, сделать это будет совсем не трудно, ведь <code><font color=Green>Mutable</font></code> – это просто обёртка. С помощью этих экземпляров пользователь сможет комбинировать вычисления, которые связаны с изменением памяти. Пока вроде всё хорошо, но обеспечиваем ли мы локальность изменения значений? Нам важно, чтобы, один раз начав работать с памятью типа <code><font color=Green>Mem</font></code>, мы не смогли бы нигде воспользоваться этой памятью после выполнения функции <code><font color=Black>purge</font></code>. Оказывается, что мы можем разрушить локальность. Посмотрите на пример:</p>
<pre><font color="#b2590f">let</font> mem <font color="#b2590f">=</font> purge allocate
<font color="#b2590f">in</font>  purge <font color=Black>(</font>read mem<font color=Black>)</font></pre>
<p>Мы возвращаем из функции <code><font color=Black>purge</font></code> ссылку на память и спокойно пользуемся ею в другой ветке <code><font color=Green>Mutable</font></code>-вычислений. Можно ли этого избежать? Оказывается, что можно. Причём решение весьма элегантно. Мы можем построить типы <code><font color=Green>Mem</font></code> и <code><font color=Green>Mutable</font></code> так, чтобы ссылке на память не удалось просочиться через функцию <code><font color=Black>purge</font></code>. Для этого мы вернёмся к общему типу <code><font color=Green>State</font></code> c двумя параметрами. Причём первый параметр мы прицепим и к <code><font color=Green>Mem</font></code>:</p>
<pre><font color="#b2590f">data</font>    <font color=Green>Mem</font>     s a <font color="#b2590f">=</font> <font color="#b2590f">..</font>
<font color="#b2590f">newtype</font> <font color=Green>Mutable</font> s a <font color="#b2590f">=</font> <font color="#b2590f">..</font>

<font color=Black>new</font>     <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Mutable</font> s <font color=Black>(</font><font color=Green>Mem</font> s a<font color=Black>)</font>
<font color=Black>write</font>   <font color="#b2590f">::</font> <font color=Green>Mem</font> s a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Mutable</font> s <font color=Green>()</font>
<font color=Black>read</font>    <font color="#b2590f">::</font> <font color=Green>Mem</font> s a <font color="#b2590f">-&gt;</font> <font color=Green>Mutable</font> s a</pre>
<p>Теперь при создании типы <code><font color=Green>Mem</font></code> и <code><font color=Green>Mutable</font></code> связаны общим параметром <code><font color=Black>s</font></code>. Посмотрим на тип функции <code><font color=Black>purge</font></code></p>
<pre><font color=Black>purge</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color="#b2590f">forall</font> s<font color=Black>.</font> <font color=Green>Mutable</font> s a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>Она имеет необычный тип. Слово <code><font color="#b2590f">forall</font></code> означает “для любых”. Это слово называют квантором всеобщности. Этим мы говорим, что функция извлечения значения не может делать никаких предположений о типе фиктивного состояния. Как дополнительный <code><font color="#b2590f">forall</font></code> может нам помочь? Функция <code><font color=Black>purge</font></code> забывает тип фиктивного состояния <code><font color=Black>s</font></code> из типа <code><font color=Green>Mutable</font></code>, но в случае типа <code><font color=Green>Mem</font></code>, этот параметр продолжает своё путешествие по программе в типе значения <code><font color=Black>v</font> <font color="#b2590f">::</font> <font color=Green>Mem</font> s a</code>. По типу <code><font color=Black>v</font></code> компилятор может сказать, что существует такое <code><font color=Black>s</font></code>, для которого значение <code><font color=Black>v</font></code> имеет смысл (правильно типизировано). Но оно не любое! Функцию <code><font color=Black>purge</font></code> с трюком интересует не некоторый тип, а все возможные типы <code><font color=Black>s</font></code>, поэтому пример не пройдёт проверку типов. Компилятор будет следить за “чистотой” наших обновлений.</p>
<p>При таком подходе остаётся вопрос: откуда мы возьмём начальное значение, ведь теперь у нас нет типа <code><font color=Green>FakeState</font></code>? В Haskell специально для этого типа было сделано исключение. Мы возьмём его из воздуха. Это чисто фиктивный параметр, нам главное, что он скрыт от пользователя, и он нигде не может им воспользоваться. Поскольку у нас нет конструктора <code><font color=Green>Mutable</font></code> мы никогда не сможем добраться до внутренней функции типа <code><font color=Green>State</font></code> и извлечь состояние. Состояние скрыто за интерфейсом класса <code><font color=Green>Monad</font></code> и отбрасывается в функции <code><font color=Black>purge</font></code>.</p>
<h3 id="тип-st"><a href="#TOC">Тип ST</a></h3>
<p>Выше я пользовался вымышленными типами для упрощения объяснений, на самом деле в Haskell за обновление значений отвечает тип <code><font color=Green>ST</font></code> (сокращение от state transformer). Он живёт в модуле <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font><font color=Black>.</font><font color=Green>ST</font></code>. Из документации видно, что у него два параметра, и нет конструкторов:</p>
<pre><font color="#b2590f">data</font> <font color=Green>ST</font> s a</pre>
<p>Это наш тип <code><font color=Green>Mutable</font></code>, теперь посмотрим на тип <code><font color=Green>Mem</font></code>. Он называется <code><font color=Green>ST</font></code>-ссылкой и определён в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>STRef</font></code> (сокращение от ST reference). Посмотрим на основные функции:</p>
<pre><font color=Black>newSTRef</font>    <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Green>ST</font> s <font color=Black>(</font><font color=Green>STRef</font> s a<font color=Black>)</font>
<font color=Black>readSTRef</font>   <font color="#b2590f">::</font> <font color=Green>STRef</font> s a <font color="#b2590f">-&gt;</font> <font color=Green>ST</font> s a
<font color=Black>writeSTRef</font>  <font color="#b2590f">::</font> <font color=Green>STRef</font> s a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>ST</font> s <font color=Green>()</font></pre>
<p>Такие функции иногда называют <em>смышлёными конструкторами</em> (smart constructors) они позволяют строить значение, но скрывают от пользователя реализацию за счёт скрытия конструкторов типа (модуль экспортирует лишь имя типа <code><font color=Green>STRef</font></code>).</p>
<p>Для иллюстрации этих функций реализуем одну вспомогательную функцию из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>STRef</font></code>, функцию обновления значения по ссылке:</p>
<pre><font color=Black>modifySTRef</font> <font color="#b2590f">::</font> <font color=Green>STRef</font> s a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>ST</font> s <font color=Green>()</font>
<font color=Black>modifySTRef</font> ref f <font color="#b2590f">=</font> writeSTRef <font color=Black>.</font> f <font color=Black>=&lt;&lt;</font> readSTRef ref </pre>
<p>Мы воспользовались тем, что <code><font color=Green>ST</font></code> является экземпляром <code><font color=Green>Monad</font></code>. Также как и для <code><font color=Green>State</font></code> для <code><font color=Green>ST</font></code> определены экземпляры классов <code><font color=Green>Functor</font></code>, <code><font color=Green>Applicative</font></code> и <code><font color=Green>Monad</font></code>. Какое совпадение! Посмотрим на функцию <code><font color=Black>purge</font></code>:</p>
<pre><font color=Black>runST</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color="#b2590f">forall</font> s<font color=Black>.</font> <font color=Green>ST</font> s a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a</pre>
<h3 id="императивные-циклы"><a href="#TOC">Императивные циклы</a></h3>
<p>Реализуем <code><font color=Black>for</font></code> цикл из языка C:</p>
<pre class="sourceCode c"><code class="sourceCode c">Result s;

<span class="kw">for</span> (i = <span class="dv">0</span> ; i &lt; n; i++)
    update(i, s);

<span class="kw">return</span> s;</code></pre>
<p>У нас есть стартовое значение счётчика и результата, функция обновления счётчика, предикат останова и функция обновления результата. Мы инициализируем счётчик и затем обновляем счётчик и состояние до тех пор пока предикат счётчика не станет ложным. Напишем чистую функцию, которая реализует этот процесс. В этой функции мы воспользуемся специальным синтаксическим сахаром, который называется <code><font color="#b2590f">do</font></code>-нотация, не пугайтесь это всё ещё Haskell, для понимания этого примера загляните в раздел “сахар для монад” главы~17.</p>
<pre><font color="#b2590f">module</font> <font color=Green>Loop</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font>

<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>STRef</font>
<font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font><font color=Black>.</font><font color=Green>ST</font>

<font color=Black>forLoop</font> <font color="#b2590f">::</font>  i <font color="#b2590f">-&gt;</font> <font color=Black>(</font>i <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>i <font color="#b2590f">-&gt;</font> i<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>i <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> s<font color=Black>)</font> <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> s
<font color=Black>forLoop</font> i0 pred next update s0 <font color="#b2590f">=</font> runST <font color=Black>$</font> <font color="#b2590f">do</font>
    refI <font color="#b2590f">&lt;-</font> newSTRef i0
    refS <font color="#b2590f">&lt;-</font> newSTRef s0
    iter refI refS
    readSTRef refS
    <font color="#b2590f">where</font> iter refI refS <font color="#b2590f">=</font> <font color="#b2590f">do</font>
            i <font color="#b2590f">&lt;-</font> readSTRef refI
            s <font color="#b2590f">&lt;-</font> readSTRef refS
            when <font color=Black>(</font>pred i<font color=Black>)</font> <font color=Black>$</font> <font color="#b2590f">do</font>
                writeSTRef refI <font color=Black>$</font> next i
                writeSTRef refS <font color=Black>$</font> update i s
                iter refI refS</pre>
<p>Впрочем код выше можно понять если читать его как обычный императивный код. Выражения <code><font color="#b2590f">do</font></code>-блока выполняются последовательно, одно за другим. Сначала мы инициализируем два изменяемых значения, для счётчика цикла и для состояния. Затем в функции <code><font color=Black>iter</font></code> мы читаем значения и выполняем проверку предиката <code><font color=Black>pred</font></code>. Функция <code><font color=Black>when</font></code> – это стандартная функция из модуля <code><font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font></code>. Она проверяет предикат, и если он возвращает <code><font color=Green>True</font></code> выполняет серию действий, в которых мы записываем обновлённые значения. Обратите внимание на то, что связка <code><font color=Black>when</font><font color="#2149c1">-</font><font color="#b2590f">do</font></code> это не специальная конструкция языка. Как было сказано <code><font color=Black>when</font></code> – это просто функция, но она ожидает одно действие, а мы хотим выполнить сразу несколько. Следующее за ней <code><font color="#b2590f">do</font></code> начинает блок действий (границы блока определяются по отступам), который будет интерпретироваться как одно действие. В настоящем императивном цикле в обновлении и предикате счётчика может участвовать переменная результата, но это считается признаком дурного стиля, поэтому наши функции определены на типе счётчика. Решим типичную задачу, посчитаем числа от одного до десяти:</p>
<pre><font color=Black>*</font><font color=Green>Loop</font><font color=Black>&gt;</font> forLoop <font color="#0000ee">1</font> <font color=Black>(</font><font color=Black>&lt;=</font><font color="#0000ee">10</font><font color=Black>)</font> succ <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#0000ee">0</font>
<font color="#0000ee">55</font></pre>
<p>Посчитаем факториал:</p>
<pre><font color=Black>*</font><font color=Green>Loop</font><font color=Black>&gt;</font> forLoop <font color="#0000ee">1</font> <font color=Black>(</font><font color=Black>&lt;=</font><font color="#0000ee">10</font><font color=Black>)</font> succ <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#0000ee">1</font>
<font color="#0000ee">3628800</font>
<font color=Black>*</font><font color=Green>Loop</font><font color=Black>&gt;</font> forLoop <font color="#0000ee">1</font> <font color=Black>(</font><font color=Black>&lt;=</font><font color="#0000ee">100</font><font color=Black>)</font> succ <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#0000ee">1</font>
<font color="#0000ee">9332621544394415268169923885626670049071596826</font>
<font color="#0000ee">4381621468592963895217599993229915608941463976</font>
<font color="#0000ee">1565182862536979208272237582511852109168640000</font>
<font color="#0000ee">00000000000000000000</font></pre>
<p>Теперь напишем <code><font color=Black>while</font></code>-цикл:</p>
<pre class="sourceCode c"><code class="sourceCode c">Result s;

<span class="kw">while</span> (pred(s))
    update(s);

<span class="kw">return</span> s;</code></pre>
<p>В этом цикле участвует один предикат и одна функция обновления результата, мы обновляем результат до тех пор пока предикат не станет ложным.</p>
<pre><font color=Black>whileLoop</font> <font color="#b2590f">::</font> <font color=Black>(</font>s <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>s <font color="#b2590f">-&gt;</font> s<font color=Black>)</font> <font color="#b2590f">-&gt;</font> s <font color="#b2590f">-&gt;</font> s
<font color=Black>whileLoop</font> pred update s0 <font color="#b2590f">=</font> runST <font color=Black>$</font> <font color="#b2590f">do</font>
    ref <font color="#b2590f">&lt;-</font> newSTRef s0
    iter ref 
    readSTRef ref
    <font color="#b2590f">where</font> iter ref <font color="#b2590f">=</font> <font color="#b2590f">do</font>
            s <font color="#b2590f">&lt;-</font> readSTRef ref
            when <font color=Black>(</font>pred s<font color=Black>)</font> <font color=Black>$</font> <font color="#b2590f">do</font>
                writeSTRef ref <font color=Black>$</font> update s
                iter ref</pre>
<p>Посчитаем сумму чисел через <code><font color=Black>while</font></code>-цикл:</p>
<pre><font color=Black>*</font><font color=Green>Loop</font><font color=Black>&gt;</font> whileLoop <font color=Black>(</font><font color=Black>(</font><font color=Black>&gt;</font><font color="#0000ee">0</font><font color=Black>)</font> <font color=Black>.</font> fst<font color=Black>)</font> <font color=Black>(</font><font color="#b2590f">\</font><font color=Black>(</font>n<font color=Black>,</font> s<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font>pred n<font color=Black>,</font> n <font color=Black>+</font> s<font color=Black>)</font><font color=Black>)</font> <font color=Black>(</font><font color="#0000ee">10</font><font color=Black>,</font> <font color="#0000ee">0</font><font color=Black>)</font>
<font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">55</font><font color=Black>)</font></pre>
<p>Первый элемент пары играет роль счётчика, а во втором мы накапливаем результат.</p>
<h3 id="быстрая-сортировка"><a href="#TOC">Быстрая сортировка</a></h3>
<p>Реализуем императивный алгоритм быстрой сортировки. Алгоритм быстрой сортировки хорош не только тем, что он работает очень быстро, но и минимальным расходом памяти. Сортировка проводится в самом массиве, с помощью обмена элементов местами. Но для этого нам понадобятся изменяемые массивы. Этот тип определён в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font><font color=Black>.</font><font color=Green>ST</font></code>. В Haskell есть несколько типов изменяемых массивов (как впрочем и неизменяемых), это связано с различными нюансами размещения элементов в массивах, о которых мы пока умолчим. Следующий класс определяет общий интерфейс к различным массивам:</p>
<pre><font color="#b2590f">class</font> <font color=Black>(</font><font color=Green>HasBounds</font> a<font color=Black>,</font> <font color=Green>Monad</font> m<font color=Black>)</font> <font color="#b2590f">=&gt;</font> <font color=Green>MArray</font> a e m <font color="#b2590f">where</font>
    newArray  <font color="#b2590f">::</font> <font color=Green>Ix</font> i <font color="#b2590f">=&gt;</font> <font color=Black>(</font>i<font color=Black>,</font> i<font color=Black>)</font> <font color="#b2590f">-&gt;</font> e <font color="#b2590f">-&gt;</font> m <font color=Black>(</font>a i e<font color=Black>)</font>
    newArray_ <font color="#b2590f">::</font> <font color=Green>Ix</font> i <font color="#b2590f">=&gt;</font> <font color=Black>(</font>i<font color=Black>,</font> i<font color=Black>)</font> <font color="#b2590f">-&gt;</font> m <font color=Black>(</font>a i e<font color=Black>)</font></pre>
<p><code><font color=Green>MArray</font></code> – это сокращение от mutable (изменяемый) array. Метод <code><font color=Black>newArray</font></code> создаёт массив типа <code><font color=Black>a</font></code>, который завёрнут в тип-монаду <code><font color=Black>m</font></code>. Первый аргумент указывает на диапазон значений индексов массива, а вторым аргументом передаётся элемент, который будет записан во все ячейки массива. Вторая функция записывает в массив элемент <code><font color=Black>undefined</font></code>.</p>
<p>Посмотрим на вспомогательные классы:</p>
<pre><font color="#b2590f">class</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Ix</font> a <font color="#b2590f">where</font>
    range <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
    index <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
    inRange <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
    rangeSize <font color="#b2590f">::</font> <font color=Black>(</font>a<font color=Black>,</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>

<font color="#b2590f">class</font> <font color=Green>HasBounds</font> a <font color="#b2590f">where</font>
    bounds <font color="#b2590f">::</font> <font color=Green>Ix</font> i <font color="#b2590f">=&gt;</font> a i e <font color="#b2590f">-&gt;</font> <font color=Black>(</font>i<font color=Black>,</font> i<font color=Black>)</font></pre>
<p>Класс <code><font color=Green>Ix</font></code> описывает тип индекса из непрерывного диапазона значений. Наверняка по имени функции и типу вы догадаетесь о назначении методов (можете свериться с интерпретатором на типах <code><font color=Green>Int</font></code> или <code><font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font></code>). Класс <code><font color=Green>HasBounds</font></code> обозначает массивы размер, которых фиксирован. Но вернёмся к массивам. Мы можем не только выделять память под массив, но и читать элементы и обновлять их:</p>
<pre><font color=Black>readArray</font>  <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>MArray</font> a e m<font color=Black>,</font> <font color=Green>Ix</font> i<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a i e <font color="#b2590f">-&gt;</font> i <font color="#b2590f">-&gt;</font> m e
<font color=Black>writeArray</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>MArray</font> a e m<font color=Black>,</font> <font color=Green>Ix</font> i<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a i e <font color="#b2590f">-&gt;</font> i <font color="#b2590f">-&gt;</font> e <font color="#b2590f">-&gt;</font> m <font color=Green>()</font></pre>
<p>В случае <code><font color=Green>ST</font></code>-ссылок у нас была функция <code><font color=Black>runST</font></code>. Она возвращала значение из памяти, но что будет возвращать аналогичная функция для массива? Посмотрим на неё:</p>
<pre><font color=Black>freeze</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ix</font> i<font color=Black>,</font> <font color=Green>MArray</font> a e m<font color=Black>,</font> <font color=Green>IArray</font> b e<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a i e <font color="#b2590f">-&gt;</font> m <font color=Black>(</font>b i e<font color=Black>)</font></pre>
<p>Возможно за всеми классами схожесть с функцией <code><font color=Black>runST</font></code> прослеживается не так чётко. Новый класс <code><font color=Green>IArray</font></code> обозначает неизменяемые (immutable) массивы. Функцией <code><font color=Black>freeze</font></code> мы превращаем изменяемый массив в неизменяемый, но завёрнутый в специальный тип-монаду. В нашем случае этим типом будет <code><font color=Green>ST</font></code>. В модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font><font color=Black>.</font><font color=Green>ST</font></code> определена специальная версия этой функции:</p>
<pre><font color=Black>runSTArray</font> <font color="#b2590f">::</font> <font color=Green>Ix</font> i <font color="#b2590f">=&gt;</font> <font color=Black>(</font><font color="#b2590f">forall</font> s <font color=Black>.</font> <font color=Green>ST</font> s <font color=Black>(</font><font color=Green>STArray</font> s i e<font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Array</font> i e</pre>
<p>Здесь <code><font color=Green>Array</font></code> – это обычный неизменяемый массив. Он живёт в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font></code> мы можем строить массивы из списков значений, преобразовывать их разными способами, превращать в обратно в списки и многое другое. Об о всём этом можно узнать из документации к модулю. Обратите на появление слова <code><font color="#b2590f">forall</font></code> и в этой функции. Оно несёт тот же смысл, что и в функции <code><font color=Black>runST</font></code>.</p>
<p>Для тренировки напишем функцию, которая меняет местами два элемента массива:</p>
<pre><font color="#b2590f">module</font> <font color=Green>Qsort</font> <font color="#b2590f">where</font>

<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>STRef</font>
<font color="#b2590f">import</font> <font color=Green>Control</font><font color=Black>.</font><font color=Green>Monad</font><font color=Black>.</font><font color=Green>ST</font>

<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font>
<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font><font color=Black>.</font><font color=Green>ST</font>
<font color="#b2590f">import</font> <font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font><font color=Black>.</font><font color=Green>MArray</font>

<font color=Black>swapElems</font> <font color="#b2590f">::</font> <font color=Green>Ix</font> i <font color="#b2590f">=&gt;</font> i <font color="#b2590f">-&gt;</font> i <font color="#b2590f">-&gt;</font> <font color=Green>STArray</font> s i e <font color="#b2590f">-&gt;</font> <font color=Green>ST</font> s <font color=Green>()</font>
<font color=Black>swapElems</font> i j arr <font color="#b2590f">=</font> <font color="#b2590f">do</font>
     vi <font color="#b2590f">&lt;-</font> readArray arr i
     vj <font color="#b2590f">&lt;-</font> readArray arr j

     writeArray arr i vj
     writeArray arr j vi</pre>
<p>Протестируем на небольшом массиве:</p>
<pre><font color=Black>test</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>test</font> i j xs <font color="#b2590f">=</font> elems <font color=Black>$</font> runSTArray <font color=Black>$</font> <font color="#b2590f">do</font>
    arr <font color="#b2590f">&lt;-</font> newListArray <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> length xs <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font> xs
    swapElems i j arr
    return arr</pre>
<p>Тир функции <code><font color=Black>test</font></code> ничем не выдаёт её содержание. Вроде функция как функция:</p>
<pre><font color=Black>test</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font></pre>
<p>Посмотрим на то, как она работает:</p>
<pre><font color=Black>*</font><font color=Green>Qsort</font><font color=Black>&gt;</font> test <font color="#0000ee">0</font> <font color="#0000ee">3</font> <font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color=Black>*</font><font color=Green>Qsort</font><font color=Black>&gt;</font> test <font color="#0000ee">0</font> <font color="#0000ee">4</font> <font color="#b2590f">[</font><font color="#0000ee">0</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>
<font color="#b2590f">[</font><font color="#0000ee">4</font><font color=Black>,</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">0</font><font color="#b2590f">]</font></pre>
<p>Теперь перейдём к сортировке. Суть метода в том, что мы выбираем один элемент массива, называемый осью (pivot) и переставляем остальные элементы массива так, чтобы все элементы меньше осевого были слева от него, а все, что больше оказались справа. Затем мы повторяем эту процедуру на массивах поменьше, тех, что находятся слева и справа от осевого элемента и так пока все элементы не отсортируются. В алгоритме очень хитрая процедура перестановки элементов, наша задача переставить элементы в массиве, то есть не пользуясь никакими дополнительными структурами данных. Я не буду говорить как это делается, просто выпишу код, а вы можете почитать об этом где-нибудь, в любом случае из кода будет понятно как это происходит:</p>
<pre><font color=Black>qsort</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color=Black>qsort</font> xs <font color="#b2590f">=</font> elems <font color=Black>$</font> runSTArray <font color=Black>$</font> <font color="#b2590f">do</font>
    arr <font color="#b2590f">&lt;-</font> newListArray <font color=Black>(</font>left<font color=Black>,</font> right<font color=Black>)</font> xs
    qsortST left right arr
    return arr
    <font color="#b2590f">where</font> left  <font color="#b2590f">=</font> <font color="#0000ee">0</font>
          right <font color="#b2590f">=</font> length xs <font color="#2149c1">-</font> <font color="#0000ee">1</font>
 
<font color=Black>qsortST</font> <font color="#b2590f">::</font> <font color=Green>Ord</font> a <font color="#b2590f">=&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Green>STArray</font> s <font color=Green>Int</font> a <font color="#b2590f">-&gt;</font> <font color=Green>ST</font> s <font color=Green>()</font>
<font color=Black>qsortST</font> left right arr <font color="#b2590f">=</font> <font color="#b2590f">do</font>
    when <font color=Black>(</font>left <font color=Black>&lt;=</font> right<font color=Black>)</font> <font color=Black>$</font> <font color="#b2590f">do</font>
        swapArray left <font color=Black>(</font>div <font color=Black>(</font>left <font color=Black>+</font> right<font color=Black>)</font> <font color="#0000ee">2</font><font color=Black>)</font> arr
        vLeft <font color="#b2590f">&lt;-</font> readArray arr left 
        <font color=Black>(</font>last<font color=Black>,</font> <font color="#b2590f">_</font><font color=Black>)</font> <font color="#b2590f">&lt;-</font> forLoop <font color=Black>(</font>left <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font> <font color=Black>(</font><font color=Black>&lt;=</font> right<font color=Black>)</font> succ 
                            <font color=Black>(</font>update vLeft<font color=Black>)</font> <font color=Black>(</font>return <font color=Black>(</font>left<font color=Black>,</font> arr<font color=Black>)</font><font color=Black>)</font>
        swapArray left last arr
        qsortST left <font color=Black>(</font>last <font color="#2149c1">-</font> <font color="#0000ee">1</font><font color=Black>)</font> arr
        qsortST <font color=Black>(</font>last <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font> right arr
    <font color="#b2590f">where</font> update vLeft i st <font color="#b2590f">=</font> <font color="#b2590f">do</font>
            <font color=Black>(</font>last<font color=Black>,</font> arr<font color=Black>)</font> <font color="#b2590f">&lt;-</font> st
            vi <font color="#b2590f">&lt;-</font> readArray arr i
            <font color="#b2590f">if</font> <font color=Black>(</font>vi <font color=Black>&lt;</font> vLeft<font color=Black>)</font> 
                <font color="#b2590f">then</font> <font color="#b2590f">do</font>
                    swapArray <font color=Black>(</font>succ last<font color=Black>)</font> i arr
                    return <font color=Black>(</font>succ last<font color=Black>,</font> arr<font color=Black>)</font>
                <font color="#b2590f">else</font> <font color="#b2590f">do</font>
                    return <font color=Black>(</font>last<font color=Black>,</font> arr<font color=Black>)</font></pre>
<p>Это далеко не самый быстрый вариант быстрой сортировки, но самый простой. Мы просто учимся обращаться с изменяемыми массивами. Протестируем:</p>
<pre><font color=Black>*</font><font color=Green>Qsort</font><font color=Black>&gt;</font> qsort <font color=Black>"abracadabra"</font>
<font color=Black>"aaaaabbcdrr"</font>
<font color=Black>*</font><font color=Green>Qsort</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> x <font color="#b2590f">=</font> <font color="#0000ee">1000000</font>
<font color=Black>*</font><font color=Green>Qsort</font><font color=Black>&gt;</font> last <font color=Black>$</font> qsort <font color="#b2590f">[</font>x<font color=Black>,</font> pred x <font color="#b2590f">..</font> <font color="#0000ee">0</font><font color="#b2590f">]</font>
<font color="#2149c1">-- двадцать лет спустя</font>
<font color="#0000ee">1000000</font></pre>
<h2 id="краткое-содержание"><a href="#TOC">Краткое содержание</a></h2>
<p>Мы посмотрели на примерах как применяются типы <code><font color=Green>State</font></code>, <code><font color=Green>Reader</font></code> и <code><font color=Green>Writer</font></code>. Также мы познакомились с монадой изменяемых значений <code><font color=Green>ST</font></code>. Она позволяет писать в императивном стиле на Haskell. Мы узнали два новых элемента построения типов:</p>
<ul>
<li><p>Типы-обёртки, которые определяются через ключевое слово <code><font color="#b2590f">newtype</font></code>.</p></li>
<li><p>Записи, они являются произведением типов с именованными полями.</p></li>
</ul>
<p>Также мы узнали несколько полезных типов:</p>
<ul>
<li><p><code><font color=Green>Map</font></code> – хранение значений по ключу (из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Map</font></code>).</p></li>
<li><p><code><font color=Green>Tree</font></code> – деревья (из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Tree</font></code>).</p></li>
<li><p><code><font color=Green>Array</font></code> – массивы (из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Array</font></code>).</p></li>
<li><p>Типы для накопления результата (из модуля <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font></code>).</p></li>
</ul>
<p>Отметим, что экземпляр класса <code><font color=Green>Monad</font></code> определён и для функций. Мы можем записать функцию двух аргументов <code><font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> c<font color=Black>)</font></code> как <code><font color=Black>(</font>a <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color="#b2590f">-&gt;</font><font color=Black>)</font> b c<font color=Black>)</font></code>. Тогда тип <code><font color=Black>(</font><font color="#b2590f">-&gt;</font><font color=Black>)</font> b</code> будет типом с одним параметром, как раз то, что нужно для класса <code><font color=Green>Monad</font></code>. По смыслу экземпляр класса <code><font color=Green>Monad</font></code> для функций совпадает с экземпляром типа <code><font color=Green>Reader</font></code>. Первый аргумент стрелочного типа <code><font color=Black>b</font></code> играет роль окружения.</p>
<h2 id="упражнения"><a href="#TOC">Упражнения</a></h2>
<ul>
<li><p>Напишите с помощью типа <code><font color=Green>Random</font></code> функцию игры в кости, два игрока бросают по очереди кости (два кубика с шестью гранями, грани пронумерованы от 1 до 6). Они бросают кубики 10 раз выигрывает тот, у кого в сумме выпадет больше очков. Функция принимает начальное состояние и выводит результат игры: суммарные баллы игроков.</p></li>
<li><p>Напишите с помощью типа <code><font color=Green>Random</font></code> функцию, которая будет создавать случайные деревья заданной глубины. Значение в узле является случайным числом от 0 до 100, также число дочерних деревьев в каждом узле случайно, оно изменяется от 0 до 10.</p></li>
<li><p>Опишите в виде конечного автомата поведение амёбы. Амёба может двигаться на плоскости по четырём направлениям. Если она чувствует свет в определённой стороне, то она ползёт туда. Если по-близости нет света, она ползает в произвольном направлении. Амёба улавливает интенсивность света, если по всем четырём сторонам интенсивность одинаковая, она стоит на месте и греется.</p></li>
<li><p>Казалось бы, зачем нам сохранять вычисления в выражениях, почему бы нам просто не вычислить их сразу? Если у нас есть описание выражения мы можем применить различные техники оптимизации, которые могут сокращать число вычислений. Например нам известно, что двойное отрицание не влияет на аргумент, мы можем выразить это так:</p>
<pre><font color="#b2590f">instance</font> <font color=Green>Num</font> <font color=Green>Exp</font> <font color="#b2590f">where</font>
    negate <font color=Black>(</font><font color=Green>Neg</font> a<font color=Black>)</font>  <font color="#b2590f">=</font> a
    negate x        <font color="#b2590f">=</font> <font color=Green>Neg</font> x
    <font color=Black>...</font>
    <font color=Black>...</font></pre>
<p>Так мы сократили вычисления на две операции. Возможны и более сложные техники оптимизации. Мы можем учесть ноль и единицу при сложении и умножении или дистрибутивность сложения относительно умножения.</p>
<p>В этом упражнении вам предлагается провести подобную оптимизацию для логических значений. У нас есть абстрактное синтаксическое дерево:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Log</font>    <font color="#b2590f">=</font> <font color=Green>True</font>
            <font color="#b2590f">|</font> <font color=Green>False</font>
            <font color="#b2590f">|</font> <font color=Green>Not</font> <font color=Green>Log</font>
            <font color="#b2590f">|</font> <font color=Green>Or</font>  <font color=Green>Log</font> <font color=Green>Log</font>
            <font color="#b2590f">|</font> <font color=Green>And</font> <font color=Green>Log</font> <font color=Green>Log</font>            </pre>
<p>Напишите функцию, которая оптимизирует выражение <code><font color=Green>Log</font></code>. Эта функция приводит <code><font color=Green>Log</font></code> к конъюнктивной нормальной форме (КНФ). Дерево в КНФ обладает такими свойствами: все узлы с <code><font color=Green>Or</font></code> находятся ближе к корню чем узлы с <code><font color=Green>And</font></code> и все узлы с <code><font color=Green>And</font></code> находятся ближе к корню чем узлы с <code><font color=Green>Not</font></code>. В КНФ выражения имеют вид:</p>
<pre><font color=Black>(</font><font color=Green>True</font> <font color=Black>`And`</font> <font color=Green>Not</font> <font color=Green>False</font> <font color=Black>`And`</font> <font color=Green>True</font><font color=Black>)</font> <font color=Black>`Or`</font> <font color=Green>True</font> <font color=Black>`Or`</font> <font color=Black>(</font><font color=Green>True</font> <font color=Black>`And`</font> <font color=Green>False</font><font color=Black>)</font>
<font color=Black>(</font><font color=Green>True</font> <font color=Black>`And`</font> <font color=Green>True</font> <font color=Black>`And`</font> <font color=Green>False</font><font color=Black>)</font> <font color=Black>`Or`</font> <font color=Green>True</font></pre>
<p>Как бы мы не шли от корня к листу сначала нам будут встречаться только операции <code><font color=Green>Or</font></code>, затем только операции <code><font color=Green>And</font></code>, затем только <code><font color=Green>Not</font></code>.</p>
<p>КНФ замечательна тем, что её вычисление может пройти досрочно. КНФ можно представить так:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Or'</font>  a <font color="#b2590f">=</font> <font color=Green>Or'</font>  <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color="#b2590f">data</font> <font color=Green>And'</font> a <font color="#b2590f">=</font> <font color=Green>And'</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font>
<font color="#b2590f">data</font> <font color=Green>Not'</font> a <font color="#b2590f">=</font> <font color=Green>Not'</font>  a
<font color="#b2590f">data</font> <font color=Green>Lit</font>    <font color="#b2590f">=</font> <font color=Green>True'</font> <font color="#b2590f">|</font> <font color=Green>False'</font>

<font color="#b2590f">type</font> <font color=Green>CNF</font> <font color="#b2590f">=</font> <font color=Green>Or'</font> <font color=Black>(</font><font color=Green>And'</font> <font color=Black>(</font><font color=Green>Not'</font> <font color=Green>Lit</font><font color=Black>)</font><font color=Black>)</font></pre>
<p>Сначала идёт список выражений разделённых конструктором <code><font color=Green>Or</font></code> (вычислять весь список не нужно, нам нужно найти первый элемент, который вернёт <code><font color=Green>True</font></code>). Затем идёт список выражений, разделённых <code><font color=Green>And</font></code> (опять же его не надо вычислять целиком, нам нужно найти первое выражение, которое вернёт <code><font color=Green>False</font></code>). В самом конце стоят отрицания.</p>
<p>В нашем случае приведение к КНФ состоит из двух этапов:</p>
<ul>
<li><p>Сначала построим выражение, в котором все конструкторы <code><font color=Green>Or</font></code> и <code><font color=Green>And</font></code> стоят ближе к корню чем конструктор <code><font color=Green>Not</font></code>. Для этого необходимо воспользоваться такими правилами:</p>
<pre><font color="#2149c1">-- удаление двойного отрицания</font>
<font color=Green>Not</font> <font color=Black>(</font><font color=Green>Not</font> a<font color=Black>)</font>  <font color=Black>==&gt;</font> a  

<font color="#2149c1">-- правила де Моргана</font>
<font color=Green>Not</font> <font color=Black>(</font><font color=Green>And</font> a b<font color=Black>)</font> <font color=Black>==&gt;</font> <font color=Green>Or</font>  <font color=Black>(</font><font color=Green>Not</font> a<font color=Black>)</font> <font color=Black>(</font><font color=Green>Not</font> b<font color=Black>)</font>
<font color=Green>Not</font> <font color=Black>(</font><font color=Green>Or</font>  a b<font color=Black>)</font> <font color=Black>==&gt;</font> <font color=Green>And</font> <font color=Black>(</font><font color=Green>Not</font> a<font color=Black>)</font> <font color=Black>(</font><font color=Green>Not</font> b<font color=Black>)</font></pre></li>
<li><p>Делаем так чтобы все конструкторы <code><font color=Green>Or</font></code> были бы ближе к корню чем конструкторы <code><font color=Green>And</font></code>. Для этого мы воспользуемся правилом дистрибутивности:</p>
<pre><font color=Green>And</font> a <font color=Black>(</font><font color=Green>Or</font> b c<font color=Black>)</font>  <font color=Black>==&gt;</font> <font color=Green>Or</font> <font color=Black>(</font><font color=Green>And</font> a b<font color=Black>)</font> <font color=Black>(</font><font color=Green>And</font> a c<font color=Black>)</font></pre>
<p>При этом мы будем учитывать коммутативность <code><font color=Green>And</font></code> и <code><font color=Green>Or</font></code>:</p>
<pre><font color=Green>And</font> a b  <font color=Black>==</font> <font color=Green>And</font> b a
<font color=Green>Or</font>  a b  <font color=Black>==</font> <font color=Green>Or</font>  b a</pre></li>
</ul></li>
<li><p>Когда вы закончите определение функции:</p>
<pre><font color=Black>transform</font> <font color="#b2590f">::</font> <font color=Green>Log</font> <font color="#b2590f">-&gt;</font> <font color=Green>CNF</font></pre>
<p>Напишите функцию, которая будет сравнивать вычисление исходного выражения напрямую и вычисление через КНФ. Эта функция будет принимать исходное значение типа <code><font color=Green>Log</font></code> и будет возвращать два числа, число операций необходимых для вычисления выражения:</p>
<pre><font color=Black>evalCount</font> <font color="#b2590f">::</font> <font color=Green>Log</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font>
<font color=Black>evalCount</font> a <font color="#b2590f">=</font> <font color=Black>(</font>evalCountLog a<font color=Black>,</font> evalCountCNF a<font color=Black>)</font>

<font color=Black>evalCountLog</font> <font color="#b2590f">::</font> <font color=Green>Log</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>evalCountLog</font> a <font color="#b2590f">=</font> <font color=Black>...</font>

<font color=Black>evalCountCNF</font> <font color="#b2590f">::</font> <font color=Green>Log</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>evalCountCNF</font> a <font color="#b2590f">=</font> <font color=Black>...</font></pre>
<p>При написании этих функций воспользуйтесь функциями-накопителями.</p></li>
<li><p>В модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>Monoid</font></code> определён специальный тип с помощью которого можно накапливать функции. Только функции должны быть специального типа. Они должны принимать и возвращать значения одного типа. Такие функции называют <em>эндоморфизмами</em>.</p>
<p>Посмотрим на их определение:</p>
<pre><font color="#b2590f">newtype</font> <font color=Green>Endo</font> a <font color="#b2590f">=</font> <font color=Green>Endo</font> <font color=Black>{</font> appEndo <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a <font color=Black>}</font>

<font color="#b2590f">instance</font> <font color=Green>Monoid</font> <font color=Black>(</font><font color=Green>Endo</font> a<font color=Black>)</font> <font color="#b2590f">where</font>
        mempty <font color="#b2590f">=</font> <font color=Green>Endo</font> id
        <font color=Green>Endo</font> f <font color=Black>`mappend`</font> <font color=Green>Endo</font> g <font color="#b2590f">=</font> <font color=Green>Endo</font> <font color=Black>(</font>f <font color=Black>.</font> g<font color=Black>)</font></pre>
<p>В качестве нейтрального элемента выступает функция тождества, а функцией объединения значений является функция композиции. Попробуйте переписать примеры из главы накопление чисел с помощью этого типа.</p></li>
<li><p>Реализуйте с помощью монады <code><font color=Green>ST</font></code> какой-нибудь алгоритм в императивном стиле. Например алгоритм поиска корней уравнения методом деления пополам. Если функция <span class="LaTeX">$f$</span> непрерывна и в двух точках <span class="LaTeX">$a$</span> и <span class="LaTeX">$b$</span> (<span class="LaTeX">$a &lt; b$</span>) значения функции имеют разные знаки, то это говорит о том, что где-то на отрезке <span class="LaTeX">$[a,\ b]$</span> уравнение <span class="LaTeX">$f(x) = 0$</span> имеет решение. Мы можем найти его так. Посмотрим какой знак у значения функции в середине отрезка. Если значение равно нулю, то нам повезло и мы нашли решение, если нет, то из двух концов отрезка выберем тот, у которого знак значения функции <span class="LaTeX">$f$</span> отличается от знака значения в середине отрезка. Далее повторим эту процедуру на новом отрезке. И так пока мы не найдём корень или отрезок не стянется в точку. Внутри функции выделите память под концы отрезка и последовательно изменяйте их внутри типа <code><font color=Green>ST</font></code>.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="6.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="8.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="6" style="list-style-type: decimal">
<li>Функторы и монады: теория
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="8" style="list-style-type: decimal">
<li>IO
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
