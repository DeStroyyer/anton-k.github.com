<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <link rel="stylesheet" href="style.css" type="text/css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#редукция-выражений">Редукция выражений</a><ul>
<li><a href="#стратегии-вычислений">Стратегии вычислений</a><ul>
<li><a href="#преимущества-и-недостатки-стратегий">Преимущества и недостатки стратегий</a></li>
</ul></li>
<li><a href="#вычисление-по-необходимости">Вычисление по необходимости</a></li>
<li><a href="#аннотации-строгости">Аннотации строгости</a><ul>
<li><a href="#принуждение-к-сзнф-с-помощью-seq">Принуждение к СЗНФ с помощью seq</a></li>
<li><a href="#функции-с-хвостовой-рекурсией">Функции с хвостовой рекурсией</a></li>
<li><a href="#тонкости-применения-seq">Тонкости применения seq</a></li>
<li><a href="#энергичные-образцы">Энергичные образцы</a></li>
<li><a href="#энергичные-типы-данных">Энергичные типы данных</a></li>
</ul></li>
<li><a href="#пример-ленивых-вычислений">Пример ленивых вычислений</a></li>
<li><a href="#краткое-содержание">Краткое содержание</a></li>
<li><a href="#упражнения">Упражнения</a></li>
</ul></li>
</ul>
</div>
<div id="header">  
<div id="nav">
<a id="prev" class="button" href="8.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="10.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>  
 </div> 

<p></p>
<h1 id="редукция-выражений"><a href="#TOC">Редукция выражений</a></h1>
<p>В этой главе мы поговорим о том как вычисляются программы. В самом начале мы говорили о том, что процесса вычисления значений нет. В том смысле, что у нас нет новых значений, у нас ничего не меняется, мы лишь расшифровываем синонимы значений.</p>
<p>Вкратце вспомним то, что мы уже знаем о вычислениях. Сначала мы с помощью типов определяем множество всех возможных значений. Значения – это деревья в узлах которых записаны конструкторы, которые мы определяем в типах. Так например мы можем определить тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Nat</font> <font color="#b2590f">=</font> <font color=Green>Zero</font> <font color="#b2590f">|</font> <font color=Green>Succ</font> <font color=Green>Nat</font></pre>
<p>Этим типом мы определяем множество допустимых значений. В данном случае это цепочки конструкторов <code><font color=Green>Succ</font></code>, которые заканчиваются конструктором <code><font color=Green>Zero</font></code>:</p>
<pre><font color=Green>Zero</font><font color=Black>,</font> <font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>,</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>,</font> <font color=Black>...</font></pre>
<p>Затем начинаем давать им новые имена, создавая константы (простые имена-синонимы)</p>
<pre><font color=Black>zero</font>    <font color="#b2590f">=</font> <font color=Green>Zero</font>
<font color=Black>one</font>     <font color="#b2590f">=</font> <font color=Green>Succ</font> zero
<font color=Black>two</font>     <font color="#b2590f">=</font> <font color=Green>Succ</font> one</pre>

<p>и функции (составные имена-синонимы):</p>
<pre><font color=Black>foldNat</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>foldNat</font> z  s  <font color=Green>Zero</font>      <font color="#b2590f">=</font> z
<font color=Black>foldNat</font> z  s  <font color=Black>(</font><font color=Green>Succ</font> n<font color=Black>)</font>  <font color="#b2590f">=</font> s <font color=Black>(</font>foldNat z s n<font color=Black>)</font>

<font color=Black>add</font> a <font color="#b2590f">=</font> foldNat a   <font color=Green>Succ</font>
<font color=Black>mul</font> a <font color="#b2590f">=</font> foldNat one <font color=Black>(</font>add a<font color=Black>)</font> </pre>
<p>Затем мы передаём нашу программу на проверку компилятору. Мы просим у него проверить не создаём ли мы случайно какие-нибудь бессмысленные выражения. Бессмысленные потому, что они пытаются создать значение, которое не вписывается в наши типы. Например если мы где-нибудь попробуем составить выражение:</p>
<pre><font color=Black>add</font> <font color=Green>Zero</font> mul</pre>
<p>Компилятор напомнит нам о том, что мы пытаемся подставить функцию <code><font color=Black>mul</font></code> на место обычного значения типа <code><font color=Green>Nat</font></code>. Тогда мы исправим выражение на:</p>
<pre><font color=Black>add</font> <font color=Green>Zero</font> two</pre>
<p>Компилятор согласится. И передаст выражение вычислителю. И тут мы говорили, что вычислитель начинает проводить расшифровку нашего описания. Он подставляет на место синонимов их определения, правые части из уравнений. Этот процесс мы называли <em>редукцией</em>. Вычислитель видит два синонима и одно значение. С какого синонима начать? С <code><font color=Black>add</font></code> или <code><font color=Black>two</font></code>?</p>
<h2 id="стратегии-вычислений"><a href="#TOC">Стратегии вычислений</a></h2>
<p>Этот вопрос приводит нас к понятию стратегии вычислений. Поскольку вычисляем мы только константы, то наше выражение также можно представить в виде дерева. Только теперь у нас в узлах записаны не только конструкторы, но и синонимы. Процесс редукции можно представить как процесс очистки такого дерева от синонимов. Посмотрим на дерево нашего значения:</p>
<p>Оказывается у нас есть две возможности очистки синонимов.</p>
<dl>
<dt><em>Cнизу-вверх</em></dt>
<dd><p> начинаем с листьев и убираем все синонимы в листьях дерева выражения. Как только в данном узле и всех дочерних узлах остались одни конструкторы можно переходить на уровень выше. Так мы поднимаемся выше и выше пока не дойдём до корня.</p>
</dd>
<dt><em>Cверху-вниз</em></dt>
<dd><p> начинаем с корня, самого внешнего синонима и заменяем его на определение (с помощью уравнения на правую часть от знака равно), если на верху снова окажется синоним, мы опять заменим его на определение и так пока на верху не появится конструктор, тогда мы спустимся в дочерние деревья и будем повторять эту процедуру пока не дойдём до листьев дерева.</p>
</dd>
</dl>
<p>Посмотрим как каждая из стратегий будет редуцировать наше выражение. Начнём со стратегии от листьев к корню (снизу-вверх):</p>
<pre>        add <font color=Green>Zero</font> two                    
<font color="#2149c1">-- видим два синонима add и two </font>
<font color="#2149c1">-- раскрываем two, ведь он находится ниже всех синонимов</font>
<font color="#b2590f">=&gt;</font>      add <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> one<font color=Black>)</font>    
<font color="#2149c1">-- ниже появился ещё один синоним, раскроем и его</font>
<font color="#b2590f">=&gt;</font>      add <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> zero<font color=Black>)</font><font color=Black>)</font>    
<font color="#2149c1">-- появился синоним zero раскроем его</font>
<font color="#b2590f">=&gt;</font>      add <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Suсс</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font>
<font color="#2149c1">-- все узлы ниже содержат конструкторы, поднимаемся вверх до синонима</font>
<font color="#2149c1">-- заменяем add на его правую часть</font>
<font color="#b2590f">=&gt;</font>      foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font>  
<font color="#2149c1">-- самый нижний синоним foldNat, раскроем его</font>
<font color="#2149c1">-- сопоставление с образцом проходит во втором уравнении для foldNat</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font>
<font color="#2149c1">-- снова раскрываем foldNat</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>Zero</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font>
<font color="#2149c1">-- снова раскрываем foldNat, но на этот раз нам подходит</font>
<font color="#2149c1">-- первое уравнение из определения foldNat</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color="#2149c1">-- синонимов больше нет можно вернуть значение</font>
<font color="#2149c1">-- результат:</font>
        <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font></pre>
<p>В этой стратегии для каждой функции мы сначала вычисляем до конца все аргументы, потом подставляем расшифрованные значения в определение функции.</p>
<p>Теперь посмотрим на вычисление от корня к листьям (сверху-вниз):</p>
<pre>        add <font color=Green>Zero</font> two
<font color="#2149c1">-- видим два синонима add и two, начинаем с того, что ближе всех к корню</font>
<font color="#b2590f">=&gt;</font>      foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> two
<font color="#2149c1">-- теперь выше всех foldNat, раскроем его</font></pre>
<p>Но для того чтобы раскрыть <code><font color=Black>foldNat</font></code> нам нужно узнать какое уравнение выбрать для этого нам нужно понять какой конструктор находится в корне у второго аргумента, если это <code><font color=Green>Zero</font></code>, то мы выберем первое уравнение, а если это <code><font color=Green>Succ</font></code>, то второе:</p>
<pre><font color="#2149c1">-- в уравнении для foldNat видим декомпозицию по второму </font>
<font color="#2149c1">-- аргументу. Узнаем какой конструктор в корне у two</font>
<font color="#b2590f">=&gt;</font>      foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> one<font color=Black>)</font>
<font color="#2149c1">-- Это Succ нам нужно второе уравнение:</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> one<font color=Black>)</font>
<font color="#2149c1">-- В корне м ыполучили конструктор, можем спуститься ниже.</font>
<font color="#2149c1">-- Там мы видим foldNat, для того чтобы раскрыть его нам</font>
<font color="#2149c1">-- снова нужно понять какой конструктор в корне у второго аргумента:</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> <font color=Black>(</font><font color=Green>Succ</font> zero<font color=Black>)</font><font color=Black>)</font>
<font color="#2149c1">-- Это опять Succ переходим ко второму уравнению для foldNat</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> zero<font color=Black>)</font><font color=Black>)</font>
<font color="#2149c1">-- Снова раскрываем второй аргумент у foldNat</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> <font color=Green>Zero</font><font color=Black>)</font><font color=Black>)</font>
<font color="#2149c1">-- Ага это Zero, выбираем первое уравнение</font>
<font color="#b2590f">=&gt;</font>      <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font>
<font color="#2149c1">-- Синонимов больше нет можно вернуть значение</font>
<font color="#2149c1">-- результат:</font>
        <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>Zero</font><font color=Black>)</font></pre>
<p>В этой стратегии мы всегда раскрываем самый верхний уровень выражения, можно представить как мы вытягиваем конструкторы от корня по цепочке. У этих стратегий есть специальные имена:</p>
<ul>
<li><p>вычисление <em>по значению</em> (call by value), когда мы идём от листьев к корню.</p></li>
<li><p>вычисление <em>по имени</em> (call by name), когда мы идём от корня к листьям.</p></li>
</ul>
<p>Отметим, что стратегию вычисления по значению также принято называть <em>энергичными вычислениями</em> (eqger evaluation) или <em>аппликативной</em> (applicative) стратегией редукции. Вычисление по имени также принято называть <em>нормальной</em> (normal) стратегией редукции.</p>
<h3 id="преимущества-и-недостатки-стратегий"><a href="#TOC">Преимущества и недостатки стратегий</a></h3>
<p>В чём преимущества, той и другой стратегии.</p>
<blockquote>
<p>Если выражение вычисляется полностью, первая стратегия более эффективна по расходу памяти.</p>
</blockquote>
<p><em>Вычисляется полностью</em> означает все компоненты выражения участвуют в вычислении. Например то выражении, которое мы рассмотрели так подробно, вычисляется полностью. Приведём пример выражения, при вычислении которого нужна лишь часть аргументов, для этого определим функцию:</p>
<pre><font color=Black>isZero</font> <font color="#b2590f">::</font> <font color=Green>Nat</font> <font color="#b2590f">-&gt;</font> <font color=Green>Bool</font>
<font color=Black>isZero</font> <font color=Green>Zero</font>     <font color="#b2590f">=</font> <font color=Green>True</font>
<font color=Black>isZero</font> <font color="#b2590f">_</font>        <font color="#b2590f">=</font> <font color=Green>False</font></pre>
<p>Она проверяет является ли нулём данное число, теперь представим как будет вычисляться выражение, в той и другой стратегии:</p>
<pre><font color=Black>isZero</font> <font color=Black>(</font>add <font color=Green>Zero</font> two<font color=Black>)</font></pre>
<p>Первая стратегия сначала вычислит все аргументы у <code><font color=Black>add</font></code> потом расшифрует <code><font color=Black>add</font></code> и только в самом конце доберётся до <code><font color=Black>isZero</font></code>. На это уйдёт восемь шагов (семь на вычисление <code><font color=Black>add</font> <font color=Green>Zero</font> two</code>). В то время как вторая стратегия начнёт с <code><font color=Black>isZero</font></code>. Для вычисления <code><font color=Black>isZero</font></code> ей потребуется узнать какой конструктор в корне у выражения <code><font color=Black>add</font> <font color=Green>Zero</font> two</code>. Она узнает это за два шага. Итого три шага. Налицо экономия усилий.</p>
<p>Почему вторая стратегия экономит память? Поскольку мы всегда вычисляем аргументы функции, мы можем не хранить описания в памяти а сразу при подстановке в функцию начинать редукцию. Эту ситуацию можно понять на таком примере, посчитаем сумму чисел от одного до четырёх с помощью такой функции:</p>
<pre><font color=Black>sum</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Int</font>
<font color=Black>sum</font> <font color=Green>[]</font>      res <font color="#b2590f">=</font> res
<font color=Black>sum</font> <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font>  res <font color="#b2590f">=</font> sum xs <font color=Black>(</font>res <font color=Black>+</font> x<font color=Black>)</font> </pre>
<p>Посмотрим на то как вычисляет первая стратегия, с учётом того что мы вычисляем значения при подстановке:</p>
<pre>        sum <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font> <font color="#0000ee">0</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>   <font color=Black>(</font><font color="#0000ee">0</font> <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font>    
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>   <font color="#0000ee">1</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>     <font color=Black>(</font><font color="#0000ee">1</font> <font color=Black>+</font> <font color="#0000ee">2</font><font color=Black>)</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>     <font color="#0000ee">3</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">4</font><font color="#b2590f">]</font>       <font color=Black>(</font><font color="#0000ee">3</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">4</font><font color="#b2590f">]</font>       <font color="#0000ee">6</font>
<font color="#b2590f">=&gt;</font>      sum <font color=Green>[]</font>        <font color=Black>(</font><font color="#0000ee">6</font><font color=Black>+</font><font color="#0000ee">4</font><font color=Black>)</font>
<font color="#b2590f">=&gt;</font>      sum <font color=Green>[]</font>        <font color="#0000ee">10</font>
<font color="#b2590f">=&gt;</font>      <font color="#0000ee">10</font></pre>
<p>Теперь посмотрим на вторую стратегию:</p>
<pre>        sum <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font> <font color="#0000ee">0</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">2</font><font color=Black>,</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>   <font color="#0000ee">0</font><font color=Black>+</font><font color="#0000ee">1</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">3</font><font color=Black>,</font><font color="#0000ee">4</font><font color="#b2590f">]</font>     <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">2</font>
<font color="#b2590f">=&gt;</font>      sum <font color="#b2590f">[</font><font color="#0000ee">4</font><font color="#b2590f">]</font>       <font color=Black>(</font><font color=Black>(</font><font color="#0000ee">0</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">3</font>
<font color="#b2590f">=&gt;</font>      sum <font color=Green>[]</font>        <font color=Black>(</font><font color=Black>(</font><font color=Black>(</font><font color="#0000ee">0</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">4</font>
<font color="#b2590f">=&gt;</font>      <font color=Black>(</font><font color=Black>(</font><font color=Black>(</font><font color="#0000ee">0</font><font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">4</font>
<font color="#b2590f">=&gt;</font>      <font color=Black>(</font><font color=Black>(</font><font color="#0000ee">1</font><font color=Black>+</font><font color="#0000ee">2</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">4</font>
<font color="#b2590f">=&gt;</font>      <font color=Black>(</font><font color="#0000ee">3</font><font color=Black>+</font><font color="#0000ee">3</font><font color=Black>)</font><font color=Black>+</font><font color="#0000ee">4</font>
<font color="#b2590f">=&gt;</font>      <font color="#0000ee">6</font><font color=Black>+</font><font color="#0000ee">4</font>
<font color="#b2590f">=&gt;</font>      <font color="#0000ee">10</font></pre>
<p>А теперь представьте, что мы решили посчитать сумму чисел от 1 до миллиона. Сколько вычислений нам придётся накопить! В этом недостаток второй стратегии. Но есть и ещё один недостаток, рассмотрим выражение:</p>
<pre><font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> add <font color=Black>(</font>add x x<font color=Black>)</font> x<font color=Black>)</font> <font color=Black>(</font>add <font color=Green>Zero</font> two<font color=Black>)</font></pre>
<p>Первая стратегия сначала редуцирует выражение <code><font color=Black>add</font> <font color=Green>Zero</font> two</code> в то время как вторая подставит это выражение в функцию и утроит свою работу!</p>
<p>Но у второй стратегии есть одно очень веское преимущество, она может вычислять больше выражений чем вторая. Определим значение бесконечность:</p>
<pre><font color=Black>infinity</font>    <font color="#b2590f">::</font> <font color=Green>Nat</font>
<font color=Black>infinity</font>    <font color="#b2590f">=</font> <font color=Green>Succ</font> infinity</pre>
<p>Это рекурсивное определение, если мы попытаемся его распечатать мы получим бесконечную последовательность <code><font color=Green>Succ</font></code>. Чем не бесконечность? Теперь посмотрим на выражение:</p>
<pre><font color=Black>isZero</font> infinity</pre>
<p>Первая стратегия захлебнётся, вычисляя аргумент функции <code><font color=Black>isZero</font></code>, в то время как вторая найдёт решение за два шага.</p>
<p>Подведём итоги. Плюсы вычисления по значению:</p>
<ul>
<li><p>Эффективный расход памяти в том случае если все<br /> составляющие выражения участвуют в вычислении.</p></li>
<li><p>Она не может дублировать вычисления, как стратегия вычисления по имени.</p></li>
</ul>
<p>Плюсы вычисления по имени:</p>
<ul>
<li><p>Меньше вычислений в том случае, если при вычислении выражения<br /> участвует лишь часть составляющих.</p></li>
<li><p>Большая выразительность. Мы можем вычислить больше значений.</p></li>
</ul>
<p>Какую из них выбрать? В Haskell пошли по второму пути. Всё-таки преимущество выразительности языка оказалось самым существенным. Но для того чтобы избежать недостатков стратегии вычисления по имени оно было модифицировано. Давайте посмотрим как.</p>
<h2 id="вычисление-по-необходимости"><a href="#TOC">Вычисление по необходимости</a></h2>
<p>  Вернёмся к выражению:</p>
<pre><font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> add <font color=Black>(</font>add x x<font color=Black>)</font> x<font color=Black>)</font> <font color=Black>(</font>add <font color=Green>Zero</font> two<font color=Black>)</font></pre>
<p>Нам нужно как-то рассказать функции о том, что имя <code><font color=Black>x</font></code> в её теле указывает на одно и то же значение. И если в одном из <code><font color=Black>x</font></code> значение будет вычислено переиспользовать эти результаты в других <code><font color=Black>x</font></code>. Вместо значения мы будем передовать в функцию <em>ссылку</em> на область памяти, которая содержит рецепт получения этого значения. Напомню, что мы по-прежнему вычисляем значение сверху вниз, сейчас мы просто хотим избавиться от проблемы дублирования. Вернитесь к примеру с вычислением по имени и просмотрите его ещё раз. Обратите внимание на то, что значения вычислялись лишь при сопоставлении с образцом. Мы вычисляем верхний конструктор аргумента лишь для того, чтобы понять какое уравнение для <code><font color=Black>foldNat</font></code> выбрать. Теперь мы будем хранить ссылку на <code><font color=Black>(</font>add <font color=Green>Zero</font> two<font color=Black>)</font></code> в памяти и как только, внешняя функция запросит верхний конструктор мы обновим значение в памяти новым вычисленным до корневого конструктора значением. Если в любом другом месте функции мы вновь обратимся к значению, мы не будем его перевычислять, а сразу вернём конструктор. Посмотрим как это происходит на примере:</p>
<pre><font color="#2149c1">--  выражение                               | память:</font>
<font color=Black>--------------------------------------------|-------------------------</font>
    <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> add <font color=Black>(</font>add x x<font color=Black>)</font> x<font color=Black>)</font> <font color=Green>M</font>               <font color="#b2590f">|</font> <font color=Green>M</font> <font color="#b2590f">=</font> <font color=Black>(</font>add <font color=Green>Zero</font> two<font color=Black>)</font>
<font color="#2149c1">-- подставим ссылку в тело функции          |</font>
<font color="#b2590f">=&gt;</font>  add <font color=Black>(</font>add <font color=Green>M</font> <font color=Green>M</font><font color=Black>)</font> <font color=Green>M</font>                         <font color="#b2590f">|</font>
<font color="#2149c1">-- раскроем самый верхний синоним           |</font>
<font color="#b2590f">=&gt;</font>  foldNat <font color=Black>(</font>add <font color=Green>M</font> <font color=Green>M</font><font color=Black>)</font> <font color=Green>Succ</font> <font color=Green>M</font>                <font color="#b2590f">|</font>
<font color="#2149c1">-- для foldNat узнаем верхний конструктор   |</font>
<font color="#2149c1">-- последнего аргумента (пропуская          |</font>
<font color="#2149c1">-- промежуточные шаги, такие же как выше)   |</font>
<font color="#b2590f">=&gt;</font>                                          <font color="#b2590f">|</font> <font color=Green>M</font>  <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>M1</font>
                                            <font color="#b2590f">|</font> <font color=Green>M1</font> <font color="#b2590f">=</font> foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> one
<font color="#2149c1">-- по M выбираем второе уравнение           |</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Black>(</font>add <font color=Green>M</font> <font color=Green>M</font><font color=Black>)</font> <font color=Green>Succ</font> <font color=Green>M1</font><font color=Black>)</font>         <font color="#b2590f">|</font>
<font color="#2149c1">-- запросим следующий верхний конструктор:  |</font>
<font color="#b2590f">=&gt;</font>                                          <font color="#b2590f">|</font> <font color=Green>M</font>  <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>M1</font>
                                            <font color="#b2590f">|</font> <font color=Green>M1</font> <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>M2</font>
                                            <font color="#b2590f">|</font> <font color=Green>M2</font> <font color="#b2590f">=</font> foldNat <font color=Green>Succ</font> <font color=Green>Zero</font> zero
<font color="#2149c1">-- по M1 выбираем второе уравнение          |</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Black>(</font>add <font color=Green>M</font> <font color=Green>M</font><font color=Black>)</font> <font color=Green>Succ</font> <font color=Green>M2</font><font color=Black>)</font><font color=Black>)</font>  <font color="#b2590f">|</font> 
<font color="#2149c1">-- теперь для определения уравнения foldNat |</font>
<font color="#2149c1">-- раскроем M2                              |</font>
<font color="#b2590f">=&gt;</font>                                          <font color="#b2590f">|</font> <font color=Green>M</font>  <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>M1</font>
                                            <font color="#b2590f">|</font> <font color=Green>M1</font> <font color="#b2590f">=</font> <font color=Green>Succ</font> <font color=Green>M2</font>
                                            <font color="#b2590f">|</font> <font color=Green>M2</font> <font color="#b2590f">=</font> <font color=Green>Zero</font>
<font color="#2149c1">-- выбираем первое уравнение для foldNat:   |</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>add <font color=Green>M</font> <font color=Green>M</font><font color=Black>)</font><font color=Black>)</font>                    <font color="#b2590f">|</font>
<font color="#2149c1">-- раскрываем самый верхний синоним:        |</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>M</font> <font color=Green>Succ</font> <font color=Green>M</font><font color=Black>)</font><font color=Black>)</font>           <font color="#b2590f">|</font>
<font color="#2149c1">-- теперь, поскольку M уже вычислялось, в   |</font>
<font color="#2149c1">-- памяти уже записан верхний конструктор,  |</font>
<font color="#2149c1">-- мы знаем, что это Succ и выбираем второе |</font>
<font color="#2149c1">-- уравнение:                               |</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>M</font> <font color=Green>Succ</font> <font color=Green>M1</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font>   <font color="#b2590f">|</font>
<font color="#2149c1">-- и M1 тоже уже вычислялось, сразу         |</font>
<font color="#2149c1">-- выбираем второе уравнение                |----+</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font>foldNat <font color=Green>M</font> <font color=Green>Succ</font> <font color=Green>M2</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font> <font color="#b2590f">|</font>
<font color="#2149c1">-- M2 вычислено, идём на первое уравнение   |----+</font>
<font color="#b2590f">=&gt;</font> <font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Black>(</font><font color=Green>Succ</font> <font color=Green>M</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font><font color=Black>)</font>       <font color="#b2590f">|</font>
<font color="#2149c1">-- далее остаётся только подставить уже     |</font>
<font color="#2149c1">-- вычисленные значения M                   |</font>
<font color="#2149c1">-- и вернуть значение.                      |</font></pre>
<p>Итак подставляется не значение а ссылка на него, вычисленная часть значения используется сразу в нескольких местах. Эта стратегия редукции называется вычислением <em>по необходимости</em> (call by need) или <em>ленивой</em> стратегией вычислений (lazy evaluation).</p>
<p>Теперь немного терминологии. Значение может находится в четырёх состояниях:</p>
<ul>
<li><p>Нормальная форма (normal form, далее НФ), когда оно полностью вычислено (нет синонимов);</p></li>
<li><p>Слабая заголовочная НФ (weak head NF, далее СЗНФ), когда известен хотя бы один верхний конструктор;</p></li>
<li><p>Отложенное вычисление (thunk), когда известен лишь рецепт вычисления;</p></li>
<li><p>Дно (bottom, часто рисуют как <span class="LaTeX">$\bot$</span>), когда известно, что значение не определено.</p></li>
</ul>
<p>Вы могли понаблюдать за значением в первых трёх состояниях на примере выше. Но что такое <span class="LaTeX">$\bot$</span>? Вспомним определение для функции извлечения головы списка <code><font color=Black>head</font></code>:</p>
<pre><font color=Black>head</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>head</font> <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">_</font><font color=Black>)</font>  <font color="#b2590f">=</font> a
<font color=Black>head</font> <font color=Green>[]</font>     <font color="#b2590f">=</font> error <font color=Black>"error: empty list"</font> </pre>
<p>Второе уравнение возвращает <span class="LaTeX">$\bot$</span>. У нас есть две функции, которые возвращают это “значение”:</p>
<pre><font color=Black>undefined</font>   <font color="#b2590f">::</font> a
<font color=Black>error</font>       <font color="#b2590f">::</font> <font color=Green>String</font> <font color="#b2590f">-&gt;</font> a</pre>
<p>Первая – это <span class="LaTeX">$\bot$</span> в чистом виде, а вторая не только возвращает неопределённое значение, но и приводит к выводу на экран сообщения об ошибке. Обратите внимание на тип этих функций, результат может быть значением любого типа. Это наблюдение приводит нас к ещё одной тонкости. Когда мы определяем тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Bool</font>       <font color="#b2590f">=</font> <font color=Green>False</font> <font color="#b2590f">|</font> <font color=Green>True</font>
<font color="#b2590f">data</font> <font color=Green>Maybe</font> a    <font color="#b2590f">=</font> <font color=Green>Nothing</font> <font color="#b2590f">|</font> <font color=Green>Just</font> a</pre>
<p>На самом деле мы пишем:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Bool</font>       <font color="#b2590f">=</font> undefined <font color="#b2590f">|</font> <font color=Green>False</font> <font color="#b2590f">|</font> <font color=Green>True</font>
<font color="#b2590f">data</font> <font color=Green>Maybe</font> a    <font color="#b2590f">=</font> undefined <font color="#b2590f">|</font> <font color=Green>Nothing</font> <font color="#b2590f">|</font> <font color=Green>Just</font> a</pre>
<p>Компилятор автоматически прибавляет ещё одно значение к любому определённому пользователем типу. Такие типы называют <em>поднятыми</em> (lifted type). А значения таких типов принято называть <em>запакованными</em> (boxed). Не запакованное (unboxed) значение – это простое примитивное значение. Например целое или действительное число в том виде, в котором оно хранится на компьютере. В Haskell даже числа “запакованы”. Поскольку нам необходимо, чтобы <code><font color=Black>undefined</font></code> могло возвращать в том числе и значение типа <code><font color=Green>Int</font></code>:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Int</font> <font color="#b2590f">=</font> undefined  <font color="#b2590f">|</font> <font color=Green>I</font><font color=Black><em>#</em></font> <font color=Green>Int</font><font color=Black><em>#</em></font> </pre>
<p>Тип <code><font color=Green>Int</font><font color=Black><em>#</em></font></code> – это низкоуровневое представление ограниченного целого числа. Принято писать не запакованные типы с решёткой на конце. <code><font color=Green>I</font><font color=Black><em>#</em></font></code> – это конструктор. Нам приходится запаковывать значения ещё и потому, что значение может принимать несколько состояний (в зависимости от того, насколько оно вычислено), всё это ведёт к тому, что у нас хранится не просто значение, а значение с какой-то дополнительной информацией, которая зависит от конкретной реализации языка Haskell.</p>
<p>Мы решили проблему дублирования вычислений, но наше решение усугубило проблему расхода памяти. Ведь теперь мы храним не просто значения, но ещё и дополнительную информацию, которая отвечает за проведение вычислений. Эта проблема может проявляться в очень простых задачах. Например попробуем вычислить сумму чисел от одного до миллиарда:</p>
<pre><font color=Black>sum</font> <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e9</font><font color="#b2590f">]</font>
<font color=Black>&lt;</font>interactive<font color=Black>&gt;:</font> out <font color="#b2590f">of</font> memory <font color=Black>(</font>requested <font color="#0000ee">2097152</font> bytes<font color=Black>)</font></pre>
<p>Интуитивно кажется, что для решения этой задачи нам нужно лишь две ячейки памяти. В одной мы будем постоянно прибавлять к значению единицу, пока не дойдём до миллиарда, так мы последовательно будем получать элементы списка, а в другой мы будем хранить значение суммы. Мы начнём с нуля и будем прибавлять значения первой ячейки. У ленивой стратегии другое мнение на этот счёт. Если вы вернётесь к примеру выше, то заметите, что <code><font color=Black>sum</font></code> копит отложенные выражения до самого последнего момента. Поскольку память ограничена, такой момент не наступает. Как нам быть? В Haskell по умолчанию все вычисления проводятся по необходимости, но предусмотрены и средства для имитации вычисления по значению. Давайте посмотрим на них.</p>
<h2 id="аннотации-строгости"><a href="#TOC">Аннотации строгости</a></h2>
<p>Языки с ленивой стратегией вычислений называют не строгими (non-strict), а языки с энергичной стратегией вычислений соответственно~– строгими.</p>
<h3 id="принуждение-к-сзнф-с-помощью-seq"><a href="#TOC">Принуждение к СЗНФ с помощью seq</a></h3>
<p>Мы говорили о том, что при вычислении по имени значения вычисляются только при сопоставлении с образцом или в <code><font color="#b2590f">case</font></code>-выражениях. Есть специальная функция <code><font color=Black>seq</font></code>, которая форсирует приведение к СЗНФ:</p>
<pre><font color=Black>seq</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> b</pre>
<p>Она принимает два аргумента, при выполнении функции первый аргумент приводится к СЗНФ и <em>затем</em> возвращается второй. Вернёмся к примеру с <code><font color=Black>sum</font></code>. Привести к СЗНФ число – означает вычислить его полностью. Определим функцию <code><font color=Black>sum'</font></code>, которая перед рекурсивным вызовом вычисляет промежуточный результат:</p>
<pre><font color=Black>sum'</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>sum'</font> <font color="#b2590f">=</font> iter <font color="#0000ee">0</font> 
    <font color="#b2590f">where</font> iter res <font color=Green>[]</font>        <font color="#b2590f">=</font> res
          iter res <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>    <font color="#b2590f">=</font> <font color="#b2590f">let</font> res' <font color="#b2590f">=</font> res <font color=Black>+</font> a
                               <font color="#b2590f">in</font>  res' <font color=Black>`seq`</font> iter res' <font color="#b2590f">as</font> </pre>
<p>Сохраним результат в отдельном модуле <code><font color=Green>Strict</font><font color=Black>.</font>hs</code> и попробуем теперь вычислить значение, придётся подождать:</p>
<pre><font color=Green>Strict</font><font color=Black>&gt;</font> sum' <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e9</font><font color="#b2590f">]</font></pre>
<p>И мы ждём, и ждём, и ждём. Но переполнения памяти не происходит. Это хорошо. Но давайте прервём вычисления. Нажмём <code><font color=Black>ctrl</font><font color=Black>+</font>c</code>. Функция <code><font color=Black>sum'</font></code> вычисляется, но вычисляется очень медленно. Мы можем существенно ускорить её, если <em>скомпилируем</em> модуль <code><font color=Green>Strict</font></code>. Для компиляции модуля переключимся в его текущую директорию и вызовем компилятор <code><font color=Black>ghc</font></code> с флагом <code><font color=Black>--make</font></code>:</p>
<pre><font color=Black>ghc</font> <font color="#2149c1">--make Strict</font></pre>
<p>Появились два файла <code><font color=Green>Strict</font><font color=Black>.</font>hi</code> и <code><font color=Green>Strict</font><font color=Black>.</font>o</code>. Теперь мы можем загрузить модуль <code><font color=Green>Strict</font></code> в интерпретатор и сравнить выполнение двух функций:</p>
<pre><font color=Green>Strict</font><font color=Black>&gt;</font> sum' <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e6</font><font color="#b2590f">]</font>
<font color="#0000ee">5.000005e11</font>
<font color=Black>(</font><font color="#0000ee">0.00</font> secs<font color=Black>,</font> <font color="#0000ee">89133484</font> bytes<font color=Black>)</font>
<font color=Green>Strict</font><font color=Black>&gt;</font> sum <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e6</font><font color="#b2590f">]</font>
<font color="#0000ee">5.000005e11</font>
<font color=Black>(</font><font color="#0000ee">0.57</font> secs<font color=Black>,</font> <font color="#0000ee">142563064</font> bytes<font color=Black>)</font></pre>
<p>Обратите внимание на прирост скорости. Умение понимать в каких случаях стоит ограничить лень очень важно. И в программах на Haskell тоже. Также компилировать модули можно из интерпретатора. Для этого воспользуемся командой <code><font color="#b2590f">:!</font></code>, она выполняет системные команды в интерпретаторе <code><font color=Black>ghci</font></code>:</p>
<pre><font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:!</font> ghc <font color="#2149c1">--make Strict</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Strict</font>           <font color=Black>(</font> <font color=Green>Strict</font><font color=Black>.</font>hs<font color=Black>,</font> <font color=Green>Strict</font><font color=Black>.</font>o <font color=Black>)</font></pre>
<p>Отметим наличие специальной функции применения, которая просит перед применением привести аргумент к СЗНФ, эта функция определена в <code><font color=Green>Prelude</font></code>:</p>
<pre><font color=Black>(</font><font color=Black>$!</font><font color=Black>)</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> b
 f <font color=Black>$!</font> a <font color="#b2590f">=</font> a <font color=Black>`seq`</font> f a</pre>
<p>С этой функцией мы можем определить функцию <code><font color=Black>sum</font></code> так:</p>
<pre><font color=Black>sum'</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>sum'</font> <font color="#b2590f">=</font> iter <font color="#0000ee">0</font> 
    <font color="#b2590f">where</font> iter res <font color=Green>[]</font>        <font color="#b2590f">=</font> res
          iter res <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>    <font color="#b2590f">=</font> flip iter <font color="#b2590f">as</font> <font color=Black>$!</font> res <font color=Black>+</font> a</pre>
<h3 id="функции-с-хвостовой-рекурсией"><a href="#TOC">Функции с хвостовой рекурсией</a></h3>
<p>Определим функцию, которая не будет лениться при вычислении произведения чисел, мы назовём её <code><font color=Black>product'</font></code>:</p>
<pre><font color=Black>product'</font> <font color="#b2590f">::</font> <font color=Green>Num</font> a <font color="#b2590f">=&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>product'</font> <font color="#b2590f">=</font> iter <font color="#0000ee">1</font>
    <font color="#b2590f">where</font> iter res <font color=Green>[]</font>        <font color="#b2590f">=</font> res
          iter res <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>    <font color="#b2590f">=</font> <font color="#b2590f">let</font> res' <font color="#b2590f">=</font> res <font color=Black>*</font> a
                               <font color="#b2590f">in</font>  res' <font color=Black>`seq`</font> iter res' <font color="#b2590f">as</font> </pre>
<p>Смотрите функция <code><font color=Black>sum</font></code> изменилась лишь в двух местах. Это говорит о том, что пора задуматься о том, а нет ли такой общей функции, которая включает в себя и то и другое поведение. Такая функция есть и называется она <code><font color=Black>foldl'</font></code>, вот её определение:</p>
<pre><font color=Black>foldl'</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>foldl'</font> op init <font color="#b2590f">=</font> iter init
    <font color="#b2590f">where</font> iter res <font color=Green>[]</font>        <font color="#b2590f">=</font> res
          iter res <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>    <font color="#b2590f">=</font> <font color="#b2590f">let</font> res' <font color="#b2590f">=</font> res <font color=Black>`op`</font> a
                               <font color="#b2590f">in</font>  res' <font color=Black>`seq`</font> iter res' <font color="#b2590f">as</font> </pre>
<p>Мы вынесли в аргументы функции бинарную операцию и начальное значение. Всё остальное осталось прежним. Эта функция живёт в модуле <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code>. Теперь мы можем определить функции <code><font color=Black>sum'</font></code> и <code><font color=Black>prod'</font></code>:</p>
<pre><font color=Black>sum'</font>        <font color="#b2590f">=</font> foldl' <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#0000ee">0</font>
<font color=Black>product'</font>    <font color="#b2590f">=</font> foldl' <font color=Black>(</font><font color=Black>*</font><font color=Black>)</font> <font color="#0000ee">1</font></pre>
<p>Также в <code><font color=Green>Prelude</font></code> определена функция <code><font color=Black>foldl</font></code>. Она накапливает значения в аргументе, но без принуждения вычислять промежуточные результаты:</p>
<pre><font color=Black>foldl</font> <font color="#b2590f">::</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>b<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>foldl</font> op init <font color="#b2590f">=</font> iter init
    <font color="#b2590f">where</font> iter res <font color=Green>[]</font>        <font color="#b2590f">=</font> res
          iter res <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>    <font color="#b2590f">=</font> iter <font color=Black>(</font>res <font color=Black>`op`</font> a<font color=Black>)</font> <font color="#b2590f">as</font> </pre>
<p>Такая функция называется функцией с <em>хвостовой рекурсией</em> (tail-recursive function). Рекурсия хвостовая тогда, когда рекурсивный вызов функции является последним действием, которое выполняется в функции. Посмотрите на второе уравнение функции <code><font color=Black>iter</font></code>. Мы вызываем функцию <code><font color=Black>iter</font></code> рекурсивно последним делом. В языках с вычислением по значению часто хвостовая рекурсия имеет преимущество за счёт экономии памяти (тот момент который мы обсуждали в самом начале). Но как видно из этого раздела в ленивых языках это не так. Библиотечная функция <code><font color=Black>sum</font></code> будет накапливать выражения перед вычислением с риском исчерпать всю доступную память, потому что она определена через <code><font color=Black>foldl</font></code>.</p>
<h3 id="тонкости-применения-seq"><a href="#TOC">Тонкости применения seq</a></h3>
<p>Хочу подчеркнуть, что функция <code><font color=Black>seq</font></code> не вычисляет свой первый аргумент полностью. Первый аргумент не приводится к нормальной форме. Мы лишь просим вычислитель узнать какой конструктор находится в корне у данного выражения. Например в выражении <code><font color=Black>isZero</font> <font color=Black>$!</font> infinity</code> знак <code><font color=Black>$!</font></code> ничем не отличается от простого применения мы и так будем приводить аргумент <code><font color=Black>infinity</font></code> к СЗНФ, когда нам понадобится узнать какое из уравнений для <code><font color=Black>isZero</font></code> выбрать, ведь в аргументе функции есть сопоставление с образцом.</p>
<p>Посмотрим на один типичный пример. Вычисление среднего для списка чисел. Среднее равно сумме всех элементов списка, разделённой на длину списка. Для того чтобы вычислить значение за один проход мы будем одновременно вычислять и сумму элементов и значение длины. Также мы понимаем, что нам не нужно откладывать вычисления, воспользуемся функцией <code><font color=Black>foldl'</font></code>:</p>
<pre><font color=Black>mean</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Double</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Black>mean</font> <font color="#b2590f">=</font> division <font color=Black>.</font> foldl' count <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">0</font><font color=Black>)</font>
    <font color="#b2590f">where</font> count  <font color=Black>(</font>sum<font color=Black>,</font> leng<font color=Black>)</font> a <font color="#b2590f">=</font> <font color=Black>(</font>sum<font color=Black>+</font>a<font color=Black>,</font> leng<font color=Black>+</font><font color="#0000ee">1</font><font color=Black>)</font>
          division <font color=Black>(</font>sum<font color=Black>,</font> leng<font color=Black>)</font> <font color="#b2590f">=</font> sum <font color=Black>/</font> fromIntegral leng</pre>
<p>Проходим по списку, копим сумму в первом элементе пары и длину во втором. В самом конце делим первый элемент на второй. Обратите внимание на функцию <code><font color=Black>fromIntegral</font></code> она преобразует значения из целых чисел, в какие-нибудь другие из класса <code><font color=Green>Num</font></code>. Сохраним это определение в модуле <code><font color=Green>Strict</font></code> скомпилируем модуль и загрузим в интерпретатор, не забудьте импортировать модуль <code><font color=Green>Data</font><font color=Black>.</font><font color=Green>List</font></code>, он нужен для функции <code><font color=Black>foldl'</font></code>. Посмотрим, что у нас получилось:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> mean <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e7</font><font color="#b2590f">]</font>
<font color="#0000ee">5000000.5</font>
<font color=Black>(</font><font color="#0000ee">49.65</font> secs<font color=Black>,</font> <font color="#0000ee">2476557164</font> bytes<font color=Black>)</font></pre>
<p>Получилось очень медленно, странно ведь порядок этой функции должен быть таким же что и у <code><font color=Black>sum'</font></code>. Посмотрим на скорость <code><font color=Black>sum'</font></code>:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> sum' <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e7</font><font color="#b2590f">]</font>
<font color="#0000ee">5.0000005e13</font>
<font color=Black>(</font><font color="#0000ee">0.50</font> secs<font color=Black>,</font> <font color="#0000ee">881855740</font> bytes<font color=Black>)</font></pre>
<p>В 100 раз быстрее. Теперь представьте, что у нас 10 таких функций как <code><font color=Black>mean</font></code> они разбросаны по всему коду и делают своё чёрное ленивое дело. Причина такого поведения кроется в том, что мы опять завернули значение в другой тип, на этот раз в пару. Когда вычислитель дойдёт до <code><font color=Black>seq</font></code>, он остановится на выражении <code><font color=Black>(</font>thunk<font color=Black>,</font> thunk<font color=Black>)</font></code> вместо двух чисел. Он вновь будет накапливать отложенные вычисления, а не значения.</p>
<p>Перепишем <code><font color=Black>mean</font></code>, теперь мы будем вычислять значения пары по отдельности и попросим вычислитель привести к СЗНФ каждое из них перед вычислением итогового значения:</p>
<pre><font color=Black>mean'</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Double</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Black>mean'</font> <font color="#b2590f">=</font> division <font color=Black>.</font> iter <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">0</font><font color=Black>)</font>
    <font color="#b2590f">where</font> iter res          <font color=Green>[]</font>      <font color="#b2590f">=</font> res
          iter <font color=Black>(</font>sum<font color=Black>,</font> leng<font color=Black>)</font>  <font color=Black>(</font>a<font color="#b2590f">:</font><font color="#b2590f">as</font><font color=Black>)</font>  <font color="#b2590f">=</font> 
                <font color="#b2590f">let</font> s <font color="#b2590f">=</font> sum  <font color=Black>+</font> a
                    l <font color="#b2590f">=</font> leng <font color=Black>+</font> <font color="#0000ee">1</font>
                <font color="#b2590f">in</font>  s <font color=Black>`seq`</font> l <font color=Black>`seq`</font> iter <font color=Black>(</font>s<font color=Black>,</font> l<font color=Black>)</font> <font color="#b2590f">as</font>
          
          division <font color=Black>(</font>sum<font color=Black>,</font> leng<font color=Black>)</font> <font color="#b2590f">=</font> sum <font color=Black>/</font> fromIntegral leng</pre>
<p>Такой вот монстр. Функция <code><font color=Black>seq</font></code> право ассоциативна поэтому скобки будут группироваться в нужном порядке. В этом определении мы просим вычислитель привести к СЗНФ <em>числа</em>, а не пары чисел, как в прошлой версии. Для чисел СЗНФ совпадает с НФ, и всё должно пройти гладко, но сохраним это определение и проверим результат:</p>
<pre><font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:!</font> ghc <font color="#2149c1">--make Strict</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Strict</font>           <font color=Black>(</font> <font color=Green>Strict</font><font color=Black>.</font>hs<font color=Black>,</font> <font color=Green>Strict</font><font color=Black>.</font>o <font color=Black>)</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>load <font color=Green>Strict</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Strict</font><font color=Black>.</font>
<font color=Black>(</font><font color="#0000ee">0.00</font> secs<font color=Black>,</font> <font color="#0000ee">0</font> bytes<font color=Black>)</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> mean' <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e7</font><font color="#b2590f">]</font>
<font color="#0000ee">5000000.5</font>
<font color=Black>(</font><font color="#0000ee">0.65</font> secs<font color=Black>,</font> <font color="#0000ee">1083157384</font> bytes<font color=Black>)</font></pre>
<p>Получилось! Скорость чуть хуже чем у <code><font color=Black>sum'</font></code>, но не в сто раз.</p>
<h3 id="энергичные-образцы"><a href="#TOC">Энергичные образцы</a></h3>
<p>В GHC предусмотрены специальные обозначения для принудительного приведения выражения к СЗНФ. Они не входят в стандарт языка Haskell, поэтому для того, чтобы воспользоваться ими, нам необходимо подключить их. Расширения подключаются с помощью специального комментария в самом начале модуля:</p>
<pre><font color="#2149c1">{-# LANGUAGE BangPatterns #-}</font></pre>
<p>Эта запись активирует расширение языка с именем <code><font color=Green>BangPatterns</font></code>. Ядро языка Haskell фиксировано стандартом, но каждый разработчик компилятора может вносить свои дополнения. Они подключаются через директиву <code><font color=Green>LANGUAGE</font></code>:</p>
<pre><font color="#2149c1">{-# LANGUAGE 
        Расширение1, 
        Расширение2, 
        Расширение3 #-}</font></pre>
<p>Мы заключаем директиву в специальные комментарии с решёткой, говорим <code><font color=Green>LANGUAGE</font></code> а затем через запятую перечисляем имена расширений, которые нам понадобятся. Расширения активны только в рамках данного модуля. Например если мы импортируем функции из модуля, в котором включены расширения, то эти расширения не распространяются дальше на другие модули. Такие комментарии с решёткой называют <em>прагмами</em> (pragma).</p>
<p>Нас интересует расширение <code><font color=Green>BangPatterns</font></code> (bang – восклицательный знак, вы сейчас поймёте почему оно так называется). Посмотрим на функцию, которая использует энергичные образцы:</p>
<pre><font color=Black>iter</font> <font color=Black>(</font><font color=Black>!</font>sum<font color=Black>,</font> <font color=Black>!</font>leng<font color=Black>)</font> a <font color="#b2590f">=</font> <font color=Black>(</font>step <font color=Black>+</font> a<font color=Black>,</font> leng <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font></pre>
<p>В декомпозиции пары перед переменными у нас появились восклицательные знаки. Они говорят вычислителю о том, чтобы он так уж и быть сделал ещё одно усилие и заглянул в корень значений переменных, которые были переданы в эту функцию.</p>
<p>Вычислитель говорит ладно-ладно сделаю. А там числа! И получается, что они не накапливаются. С помощью энергичных образцов мы можем переписать функцию <code><font color=Black>mean'</font></code> через <code><font color=Black>foldl'</font></code>, а не выписывать её целиком:</p>
<pre><font color=Black>mean''</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Double</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Black>mean''</font> <font color="#b2590f">=</font> division <font color=Black>.</font> foldl' iter <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">0</font><font color=Black>)</font>
    <font color="#b2590f">where</font> iter <font color=Black>(</font><font color=Black>!</font>sum<font color=Black>,</font> <font color=Black>!</font>leng<font color=Black>)</font> a <font color="#b2590f">=</font> <font color=Black>(</font>sum  <font color=Black>+</font> a<font color=Black>,</font> leng <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font>
          division <font color=Black>(</font>sum<font color=Black>,</font> leng<font color=Black>)</font> <font color="#b2590f">=</font> sum <font color=Black>/</font> fromIntegral leng</pre>
<p>Проверим в интерпретаторе</p>
<pre><font color=Black>*</font><font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:!</font> ghc <font color="#2149c1">--make Strict</font>
<font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">of</font> <font color="#0000ee">1</font><font color="#b2590f">]</font> <font color=Green>Compiling</font> <font color=Green>Strict</font>           <font color=Black>(</font> <font color=Green>Strict</font><font color=Black>.</font>hs<font color=Black>,</font> <font color=Green>Strict</font><font color=Black>.</font>o <font color=Black>)</font>
<font color=Black>*</font><font color=Green>Strict</font><font color=Black>&gt;</font> <font color="#b2590f">:</font>l <font color=Green>Strict</font>
<font color=Green>Ok</font><font color=Black>,</font> modules loaded<font color="#b2590f">:</font> <font color=Green>Strict</font><font color=Black>.</font>
<font color=Black>(</font><font color="#0000ee">0.00</font> secs<font color=Black>,</font> <font color="#0000ee">581304</font> bytes<font color=Black>)</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> mean'' <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e7</font><font color="#b2590f">]</font>
<font color="#0000ee">5000000.5</font>
<font color=Black>(</font><font color="#0000ee">0.78</font> secs<font color=Black>,</font> <font color="#0000ee">1412862488</font> bytes<font color=Black>)</font>
<font color=Green>Prelude</font> <font color=Green>Strict</font><font color=Black>&gt;</font> mean' <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font> <font color="#0000ee">1e7</font><font color="#b2590f">]</font>
<font color="#0000ee">5000000.5</font>
<font color=Black>(</font><font color="#0000ee">0.65</font> secs<font color=Black>,</font> <font color="#0000ee">1082640204</font> bytes<font color=Black>)</font></pre>
<p>Функция работает чуть медленнее, чем исходная версия, но не сильно.</p>
<h3 id="энергичные-типы-данных"><a href="#TOC">Энергичные типы данных</a></h3>
<p>Расширение <code><font color=Green>BangPatterns</font></code> позволяет указывать какие значения привести к СЗНФ не только в образцах, но и в типах данных. Мы можем создать тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>P</font> a b <font color="#b2590f">=</font> <font color=Green>P</font> <font color=Black>!</font>a <font color=Black>!</font>b</pre>
<p>Этот тип обозначает пару, элементы которой обязаны находиться в СЗНФ. Теперь мы можем написать ещё один вариант функции поиска среднего:</p>
<pre><font color=Black>mean'''</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Double</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Green>Double</font>
<font color=Black>mean'''</font> <font color="#b2590f">=</font> division <font color=Black>.</font> foldl' iter <font color=Black>(</font><font color=Green>P</font> <font color="#0000ee">0</font> <font color="#0000ee">0</font><font color=Black>)</font>
    <font color="#b2590f">where</font> iter <font color=Black>(</font><font color=Green>P</font> sum leng<font color=Black>)</font> a <font color="#b2590f">=</font> <font color=Green>P</font> <font color=Black>(</font>sum  <font color=Black>+</font> a<font color=Black>)</font> <font color=Black>(</font>leng <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font>
          division <font color=Black>(</font><font color=Green>P</font> sum leng<font color=Black>)</font> <font color="#b2590f">=</font> sum <font color=Black>/</font> fromIntegral leng</pre>
<h2 id="пример-ленивых-вычислений"><a href="#TOC">Пример ленивых вычислений</a></h2>
<p>У вас может сложиться ошибочное представление, что ленивые вычисления созданы только для того, чтобы с ними бороться. Пока мы рассматривали лишь недостатки, вскользь упомянув о преимуществе выразительности. Ленивые вычисления могут и экономить память! Мы можем строить огромные промежуточные данные, обрабатывать их разными способами при условии, что в конце программы нам потребуется лишь часть этих данных или конечный алгоритм будет накапливать определённую статистику.</p>
<p>Рассмотрим такое выражение:</p>
<pre><font color="#b2590f">let</font> longList <font color="#b2590f">=</font> produce x
<font color="#b2590f">in</font>  sum' <font color=Black>$</font> filter p <font color=Black>$</font> map f longList </pre>
<p>Функция <code><font color=Black>produce</font></code> строит огромный список промежуточных данных. Далее мы преобразуем эти данные функцией <code><font color=Black>f</font></code> и фильтруем их предикатом <code><font color=Black>p</font></code>. Всё это делается для того, чтобы посчитать сумму всех элементов в списке. Посмотрим как повела бы себя в такой ситуации энергичная стратегия вычислений. Сначала был бы вычислен список <code><font color=Black>longList</font></code>, причём полностью. Затем все элементы были бы преобразованы функцией <code><font color=Black>f</font></code>. У нас в памяти уже два огромных списка. Теперь мы фильтруем весь список и в самом конце суммируем. Было бы очень плохо заставлять энергичный вычислитель редуцировать такое выражение.</p>
<p>А в это время ленивый вычислитель поступит так. Сначала всё выражение будет сохранено в виде описания, затем он скажет разверну сначала <code><font color=Black>sum'</font></code>, эта функция запросит первый элемент списка, что приведёт к вызову <code><font color=Black>filter</font></code>. Фильтр будет запрашивать следующий элемент списка у подчинённых ему функций до тех пор, пока предикат <code><font color=Black>p</font></code> не вернёт <code><font color=Green>True</font></code> на одном из них. Всё это время функция <code><font color=Black>map</font></code> будет вытягивать из <code><font color=Black>produce</font></code> по одному элементу. Причём память, выделенная на промежуточные не нужные значения (на них <code><font color=Black>p</font></code> вернул <code><font color=Green>False</font></code>) будет переиспользована. Как только <code><font color=Black>sum'</font></code> прибавит первый элемент, она запросит следующий, проснётся фильтр и так далее. Вся функция будет работать в постоянном ограниченном объёме памяти, который не зависит от величины списка <code><font color=Black>longList</font></code>!</p>
<p>Примерам ленивых вычислений будет посвящена отдельная глава, а пока приведём один пример. Найдём корень уравнения с помощью метода неподвижной точки. У нас есть функция <code><font color=Black>f</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> a</code>, и нам нужно найти решение уравнения:</p>
<pre><font color=Black>f</font> x <font color="#b2590f">=</font> x</pre>
<p>Можно начать с какого-нибудь стартового значения, и подставлять, подставлять, подставлять его в <code><font color=Black>f</font></code> до тех пор, пока значение не перестанет изменяться. Так мы найдём решение.</p>
<pre><font color=Black>x1</font> <font color="#b2590f">=</font> f x0
<font color=Black>x2</font> <font color="#b2590f">=</font> f x1
<font color=Black>x3</font> <font color="#b2590f">=</font> f x2
<font color=Black>...</font>
<font color=Black>до</font> тех пор пока abs <font color=Black>(</font>x<font color="#b2590f">[</font><font color=Green>N</font><font color="#b2590f">]</font> <font color="#2149c1">-</font> x<font color="#b2590f">[</font><font color=Green>N</font><font color="#2149c1">-</font><font color="#0000ee">1</font><font color="#b2590f">]</font><font color=Black>)</font> <font color=Black>&lt;=</font> eps</pre>
<p>Первое наблюдение: функция принимает не произвольные значения, а те для которых имеет смысл операции: минус, поиск абсолютного значения и сравнение на больще/меньше. Тип нашей функции:</p>
<pre><font color=Black>f</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> a<font color=Black>,</font> <font color=Green>Num</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> a</pre>
<p>Ленивые вычисления позволяют нам отделить шаг генерации решений, от шага проверки сходимости. Сначала мы сделаем список всех подстановок функции <code><font color=Black>f</font></code>, а затем найдём в этом списке два соседних элемента расстояние между которыми достаточно мало. Итак первый шаг, генерируем всю последовательность:</p>
<pre><font color=Black>xNs</font> <font color="#b2590f">=</font> iterate f x0</pre>
<p>Мы воспользовались стандартной функцией <code><font color=Black>iterate</font></code> из <code><font color=Green>Prelude</font></code>. Теперь ищем два соседних числа:</p>
<pre><font color=Black>converge</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> a<font color=Black>,</font> <font color=Green>Num</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> <font color="#b2590f">[</font>a<font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>converge</font> eps <font color=Black>(</font>a<font color="#b2590f">:</font>b<font color="#b2590f">:</font>xs<font color=Black>)</font> 
    <font color="#b2590f">|</font> abs <font color=Black>(</font>a <font color="#2149c1">-</font> b<font color=Black>)</font> <font color=Black>&lt;=</font> eps    <font color="#b2590f">=</font> a
    <font color="#b2590f">|</font> otherwise             <font color="#b2590f">=</font> converge eps <font color=Black>(</font>b<font color="#b2590f">:</font>xs<font color=Black>)</font></pre>
<p>Поскольку список бесконечный мы можем не проверять случаи для пустого списка. Итоговое решение:</p>
<pre><font color=Black>roots</font> <font color="#b2590f">::</font> <font color=Black>(</font><font color=Green>Ord</font> a<font color=Black>,</font> <font color=Green>Num</font> a<font color=Black>)</font> <font color="#b2590f">=&gt;</font> a <font color="#b2590f">-&gt;</font> a <font color="#b2590f">-&gt;</font> <font color=Black>(</font>a <font color="#b2590f">-&gt;</font> a<font color=Black>)</font> <font color="#b2590f">-&gt;</font> a
<font color=Black>roots</font> eps x0 f <font color="#b2590f">=</font> converge eps <font color=Black>$</font> iterate f x0</pre>
<p>За счёт ленивых вычислений функции <code><font color=Black>converge</font></code> и <code><font color=Black>iterate</font></code> работают синхронно. Функция <code><font color=Black>converge</font></code> запрашивает новое значение и <code><font color=Black>iterate</font></code> передаёт его, но только одно! Найдём решение какого-нибудь уравнения. Запустим интерпретатор. Мы ленимся и не создаём новый модуль для такой “большой” функции. Определяем её сразу в интерпретаторе.</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> converge eps <font color=Black>(</font>a<font color="#b2590f">:</font>b<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> <font color="#b2590f">if</font> abs <font color=Black>(</font>a<font color="#2149c1">-</font>b<font color=Black>)</font><font color=Black>&lt;=</font>eps <font color="#b2590f">then</font> a <font color="#b2590f">else</font> converge eps <font color=Black>(</font>b<font color="#b2590f">:</font>xs<font color=Black>)</font>
<font color=Green>Prelude</font><font color=Black>&gt;</font> <font color="#b2590f">let</font> roots eps x0 f <font color="#b2590f">=</font> converge eps <font color=Black>$</font> iterate f x0</pre>
<p>Найдём корень уравнения:</p>
<p><span class="LaTeX">$x (x-2) = 0$</span></p>
<p><span class="LaTeX">$x^2 - 2 x = 0$</span></p>
<p><span class="LaTeX">$\frac{1}{2} x^2 = x$</span></p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> roots <font color="#0000ee">0.001</font> <font color="#0000ee">5</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x<font color=Black>*</font>x<font color=Black>/</font><font color="#0000ee">2</font><font color=Black>)</font></pre>
<p>Метод завис, остаётся только нажать <code><font color=Black>ctrl</font><font color=Black>+</font>c</code> для остановки. На самом деле есть одно условие для сходимости метода. Метод сойдётся, если модуль производной функции <code><font color=Black>f</font></code> меньше единицы. Иначе есть возможность, что мы будем бесконечно генерировать новые подстановки. Вычислим производную нашей функции:</p>
<p><span class="LaTeX">$\frac{d}{dx} \frac{1}{2} x^2 = x$</span></p>
<p>Нам следует ожидать решения в интервале от минус единицы до единицы:</p>
<pre><font color=Green>Prelude</font><font color=Black>&gt;</font> roots <font color="#0000ee">0.001</font> <font color="#0000ee">0.5</font> <font color=Black>(</font><font color="#b2590f">\</font>x <font color="#b2590f">-&gt;</font> x<font color=Black>*</font>x<font color=Black>/</font><font color="#0000ee">2</font><font color=Black>)</font>
<font color="#0000ee">3.0517578125e-5</font></pre>
<p>Мы нашли решение, корень равен нулю. В этой записи <code><font color=Green>Ne</font><font color="#2149c1">-</font><font color="#0000ee">5</font></code> означает <span class="LaTeX">$N \cdot 10^{-5}$</span></p>
<h2 id="краткое-содержание"><a href="#TOC">Краткое содержание</a></h2>
<p>В этой главе мы узнали о том как происходят вычисления в Haskell. Мы узнали, что они ленивые. Всё вычисляется как можно позже и как можно меньше. Такие вычисления называются вычислениями по необходимости.</p>
<p>Также мы узнали о вычислениях по значению и вычислениях по имени.</p>
<ul>
<li><p>В <em>вычислениях по значению</em> редукция проводится от листьев дерева выражения к корню</p></li>
<li><p>В <em>вычислениях по имени</em> редукция проводится от корня дерева выражения к листьям.</p></li>
</ul>
<p>Вычисление по необходимости является улучшением вычисления по имени. Мы не дублируем выражения во время применения. Мы сохраняем значения в памяти и подставляем в функцию ссылки на значения. После вычисления значения происходит его обновление в памяти. Так если в одном месте выражение уже было вычислено и мы обратимся к нему по ссылке из другого места, то мы не будем перевычислять его, а просто считаем готовое значение.</p>
<p>Мы познакомились с терминологией процесса вычислений. Выражение может находится в <em>нормальной форме</em>. Это значит что оно вычислено. Может находится в <em>слабой заголовочной нормальной форме</em>. Это значит, что мы знаем хотя бы один конструктор в корне выражения. Также возможно выражение ещё не вычислялось, тогда оно является <em>отложенным</em> (thunk).</p>
<p>Суть ленивых вычислений заключается в том, что они происходят синхронно. Если у нас есть композиция двух функций:</p>
<p><span class="LaTeX">$g\ (f\ x)$</span></p>
<p>Внутренняя функция <code><font color=Black>f</font></code> не начнёт вычисления до тех пор пока значения не понадобятся внешней функции <code><font color=Black>g</font></code>. О последствиях этого мы остановимся подробнее в отдельной главе. Значения могут потребоваться только при сопоставлении с образцом. Когда мы хотим узнать какое из уравнений нам выбрать.</p>
<p>Иногда ленивые вычисления не эффективны по расходу памяти. Это происходит когда выражение состоит из большого числа подвыражений, которые будут вычислены в любом случае. В Haskell у нас есть способы борьбы с ленью. Это функция <code><font color=Black>seq</font></code>, энергичные образцы и энергичные типы данных.</p>
<p>Функция <code><font color=Black>seq</font></code>:</p>
<pre><font color=Black>seq</font> <font color="#b2590f">::</font> a <font color="#b2590f">-&gt;</font> b <font color="#b2590f">-&gt;</font> b</pre>
<p>Сначала приводит к слабой заголовочной форме свой первый аргумент, а затем возвращает второй. Взрывные образцы выполняют те же функции, но они используются в декомпозиции аргументов или в объявлении типа.</p>
<h2 id="упражнения"><a href="#TOC">Упражнения</a></h2>
<ul>
<li><p>Потренируйтесь в понимании того как происходят ленивые вычисления. Вычислите на бумаге следующие выражения (если это возможно):</p>
<ul>
<li><p><code><font color=Black>sum</font> <font color=Black>$</font> take <font color="#0000ee">3</font> <font color=Black>$</font> filter <font color=Black>(</font>odd <font color=Black>.</font> fst<font color=Black>)</font> <font color=Black>$</font>          zip <font color="#b2590f">[</font><font color="#0000ee">1</font> <font color="#b2590f">..</font><font color="#b2590f">]</font> <font color="#b2590f">[</font><font color="#0000ee">1</font><font color=Black>,</font> undefined<font color=Black>,</font> <font color="#0000ee">2</font><font color=Black>,</font> undefined<font color=Black>,</font> <font color="#0000ee">3</font><font color=Black>,</font> undefined<font color=Black>,</font> undefined<font color="#b2590f">]</font></code></p></li>
<li><code><font color=Black>take</font> <font color="#0000ee">2</font> <font color=Black>$</font> foldr <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#0000ee">0</font> <font color=Black>$</font> map <font color=Green>Succ</font> <font color=Black>$</font> repeat <font color=Green>Zero</font></code></li>
<li><p><code><font color=Black>take</font> <font color="#0000ee">2</font> <font color=Black>$</font> foldl <font color=Black>(</font><font color=Black>+</font><font color=Black>)</font> <font color="#0000ee">0</font> <font color=Black>$</font> map <font color=Green>Succ</font> <font color=Black>$</font> repeat <font color=Green>Zero</font></code></p></li>
</ul></li>
<li><p>Функция <code><font color=Black>seq</font></code> приводит первый аргумент к СЗНФ, убедитесь в этом на таком эксперименте. Определите тип:</p>
<pre><font color="#b2590f">data</font> <font color=Green>TheDouble</font> <font color="#b2590f">=</font> <font color=Green>TheDouble</font> <font color=Black>{</font> runTheDouble <font color="#b2590f">::</font> <font color=Green>Double</font> <font color=Black>}</font></pre>
<p>Он запаковывает действительные числа в конструктор. Определите для этого типа экземпляр класса <code><font color=Green>Num</font></code> и посмотрите как быстро будет работать функция <code><font color=Black>sum'</font></code> на таких числах. Как изменится скорость если мы заменим в определении типа <code><font color="#b2590f">data</font></code> на <code><font color="#b2590f">newtype</font></code>? как изменится скорость, если мы вернём <code><font color="#b2590f">data</font></code>, но сделаем тип <code><font color=Green>TheDouble</font></code> энергичным? Поэкспериментируйте.</p></li>
<li><p>Посмотрите на приведение к СЗНФ в энергичных типах данных. Определите два типа:</p>
<pre><font color="#b2590f">data</font> <font color=Green>Strict</font> a <font color="#b2590f">=</font> <font color=Green>Strict</font> <font color=Black>!</font>a
<font color="#b2590f">data</font> <font color=Green>Lazy</font>   a <font color="#b2590f">=</font> <font color=Green>Lazy</font>    a</pre>
<p>И повычисляйте в интерпретаторе различные значения с <code><font color=Black>undefined</font></code>, <code><font color=Black>const</font></code>, <code><font color=Black>(</font><font color=Black>$!</font><font color=Black>)</font></code> и <code><font color=Black>seq</font></code>:</p>
<pre><font color=Black>&gt;</font> <font color=Black>seq</font> <font color=Black>(</font><font color=Green>Lazy</font> undefined<font color=Black>)</font> <font color=Black>"Hi"</font>
<font color=Black>&gt;</font> <font color=Black>seq</font> <font color=Black>(</font><font color=Green>Strict</font> undefined<font color=Black>)</font> <font color=Black>"Hi"</font>
<font color=Black>&gt;</font> <font color=Black>seq</font> <font color=Black>(</font><font color=Green>Lazy</font> <font color=Black>(</font><font color=Green>Strict</font> undefined<font color=Black>)</font><font color=Black>)</font> <font color=Black>"Hi"</font>
<font color=Black>&gt;</font> <font color=Black>seq</font> <font color=Black>(</font><font color=Green>Strict</font> <font color=Black>(</font><font color=Green>Strict</font> <font color=Black>(</font><font color=Green>Strict</font> undefined<font color=Black>)</font><font color=Black>)</font><font color=Black>)</font> <font color=Black>"Hi"</font></pre></li>
<li><p>Посмотрите на такую функцию вычисления суммы всех чётных и нечётных чисел в списке.</p>
<pre><font color=Black>sum2</font> <font color="#b2590f">::</font> <font color="#b2590f">[</font><font color=Green>Int</font><font color="#b2590f">]</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font>
<font color=Black>sum2</font> <font color="#b2590f">=</font> iter <font color=Black>(</font><font color="#0000ee">0</font><font color=Black>,</font> <font color="#0000ee">0</font><font color=Black>)</font>
    <font color="#b2590f">where</font> iter c  <font color=Green>[]</font>     <font color="#b2590f">=</font> c
          iter c  <font color=Black>(</font>x<font color="#b2590f">:</font>xs<font color=Black>)</font> <font color="#b2590f">=</font> iter <font color=Black>(</font>tick x c<font color=Black>)</font> xs

<font color=Black>tick</font> <font color="#b2590f">::</font> <font color=Green>Int</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font> <font color="#b2590f">-&gt;</font> <font color=Black>(</font><font color=Green>Int</font><font color=Black>,</font> <font color=Green>Int</font><font color=Black>)</font>
<font color=Black>tick</font> x <font color=Black>(</font>c0<font color=Black>,</font> c1<font color=Black>)</font> <font color="#b2590f">|</font> even x    <font color="#b2590f">=</font> <font color=Black>(</font>c0<font color=Black>,</font> c1 <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>)</font>
                <font color="#b2590f">|</font> otherwise <font color="#b2590f">=</font> <font color=Black>(</font>c0 <font color=Black>+</font> <font color="#0000ee">1</font><font color=Black>,</font> c1<font color=Black>)</font></pre>
<p>Эта функция очень медленная. Кто-то слишком много ленится. Узнайте кто, и ускорьте функцию.</p></li>
</ul>
<div id="footer">  
<div id="nav">
<a id="prev" class="button" href="8.html"><strong><code><font color="#b2590f">&lt;-</font></code></strong></a><a id="next" class="button" href="10.html"><strong><code><font color="#b2590f">-&gt;</font></code></strong></a>
<div id="home">
<a href="toc.html"><code><font color="#b2590f">::</font></code> Содержание <code><font color="#b2590f">::</font></code></a>
</div></div>
<div id="nav"> <div id="prev-name">
<ol start="8" style="list-style-type: decimal">
<li>IO
</div> <div id="wrap-next-name"><div id="next-name">
<ol start="10" style="list-style-type: decimal">
<li>Реализация Haskell в GHC
</div></div></div>  
 </div> 
</li>
</ol></li>
</ol>
<div id="license">
Зарегистрировано под лицензией <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative commons Attribution-NonCommercial-NoDerivs</a> 3.0 Generic (CC BY-NC-ND 3.0)
</div>
</body>
</html>
